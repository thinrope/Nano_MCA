
mca-app.elf:     file format elf32-littlearm


Disassembly of section .text:

0800c800 <__WFI>:
 800c800:	bf30      	wfi
 800c802:	4770      	bx	lr

0800c804 <__WFE>:
 800c804:	bf20      	wfe
 800c806:	4770      	bx	lr

0800c808 <__SEV>:
 800c808:	bf40      	sev
 800c80a:	4770      	bx	lr

0800c80c <__ISB>:
 800c80c:	f3bf 8f6f 	isb	sy
 800c810:	4770      	bx	lr

0800c812 <__DSB>:
 800c812:	f3bf 8f4f 	dsb	sy
 800c816:	4770      	bx	lr

0800c818 <__DMB>:
 800c818:	f3bf 8f5f 	dmb	sy
 800c81c:	4770      	bx	lr

0800c81e <__SVC>:
 800c81e:	df01      	svc	1
 800c820:	4770      	bx	lr

0800c822 <__MRS_CONTROL>:
 800c822:	f3ef 8014 	mrs	r0, CONTROL
 800c826:	4770      	bx	lr

0800c828 <__MSR_CONTROL>:
 800c828:	f380 8814 	msr	CONTROL, r0
 800c82c:	f3bf 8f6f 	isb	sy
 800c830:	4770      	bx	lr

0800c832 <__MRS_PSP>:
 800c832:	f3ef 8009 	mrs	r0, PSP
 800c836:	4770      	bx	lr

0800c838 <__MSR_PSP>:
 800c838:	f380 8809 	msr	PSP, r0
 800c83c:	4770      	bx	lr

0800c83e <__MRS_MSP>:
 800c83e:	f3ef 8008 	mrs	r0, MSP
 800c842:	4770      	bx	lr

0800c844 <__MSR_MSP>:
 800c844:	f380 8808 	msr	MSP, r0
 800c848:	4770      	bx	lr

0800c84a <__SETPRIMASK>:
 800c84a:	b672      	cpsid	i
 800c84c:	4770      	bx	lr

0800c84e <__RESETPRIMASK>:
 800c84e:	b662      	cpsie	i
 800c850:	4770      	bx	lr

0800c852 <__SETFAULTMASK>:
 800c852:	b671      	cpsid	f
 800c854:	4770      	bx	lr

0800c856 <__RESETFAULTMASK>:
 800c856:	b661      	cpsie	f
 800c858:	4770      	bx	lr

0800c85a <__BASEPRICONFIG>:
 800c85a:	f380 8811 	msr	BASEPRI, r0
 800c85e:	4770      	bx	lr

0800c860 <__GetBASEPRI>:
 800c860:	f3ef 8012 	mrs	r0, BASEPRI_MASK
 800c864:	4770      	bx	lr

0800c866 <__REV_HalfWord>:
 800c866:	ba40      	rev16	r0, r0
 800c868:	4770      	bx	lr

0800c86a <__REV_Word>:
 800c86a:	ba00      	rev	r0, r0
 800c86c:	4770      	bx	lr
 800c86e:	144c      	.short	0x144c
 800c870:	18000801 	.word	0x18000801
 800c874:	18382000 	.word	0x18382000
 800c878:	18382000 	.word	0x18382000
 800c87c:	4db02000 	.word	0x4db02000
 800c880:	00002000 	.word	0x00002000

0800c884 <NMIException>:
const static char *msgbfe = "Bus Fault Exception";
const static char *msgufe = "Usage Fault Exception";
#endif

void NMIException(void)
{}
 800c884:	4770      	bx	lr

0800c886 <DebugMonitor>:
	__Display_Str(100, 20, RED, BKGND_COLOR, msgufe);
	while (1) {}
}

void DebugMonitor(void)
{}
 800c886:	4770      	bx	lr

0800c888 <SVCHandler>:

void SVCHandler(void)
{}
 800c888:	4770      	bx	lr

0800c88a <PendSVC>:

void PendSVC(void)
{}
 800c88a:	4770      	bx	lr

0800c88c <SysTickHandler>:

void SysTickHandler(void)
{}
 800c88c:	4770      	bx	lr

0800c88e <WWDG_IRQHandler>:

void WWDG_IRQHandler(void)
{}
 800c88e:	4770      	bx	lr

0800c890 <PVD_IRQHandler>:

void PVD_IRQHandler(void)
{}
 800c890:	4770      	bx	lr

0800c892 <TAMPER_IRQHandler>:

void TAMPER_IRQHandler(void)
{}
 800c892:	4770      	bx	lr

0800c894 <RTC_IRQHandler>:

void RTC_IRQHandler(void)
{}
 800c894:	4770      	bx	lr

0800c896 <FLASH_IRQHandler>:

void FLASH_IRQHandler(void)
{}
 800c896:	4770      	bx	lr

0800c898 <RCC_IRQHandler>:

void RCC_IRQHandler(void)
{}
 800c898:	4770      	bx	lr

0800c89a <EXTI0_IRQHandler>:

void EXTI0_IRQHandler(void)
{}
 800c89a:	4770      	bx	lr

0800c89c <EXTI1_IRQHandler>:

void EXTI1_IRQHandler(void)
{}
 800c89c:	4770      	bx	lr

0800c89e <EXTI2_IRQHandler>:

void EXTI2_IRQHandler(void)
{}
 800c89e:	4770      	bx	lr

0800c8a0 <EXTI3_IRQHandler>:

void EXTI3_IRQHandler(void)
{}
 800c8a0:	4770      	bx	lr

0800c8a2 <EXTI4_IRQHandler>:

void EXTI4_IRQHandler(void)
{}
 800c8a2:	4770      	bx	lr

0800c8a4 <DMAChannel1_IRQHandler>:

void            DMAChannel1_IRQHandler(void)
{
 800c8a4:	b510      	push	{r4, lr}
	u8 ss = scan_segment;
 800c8a6:	4b0d      	ldr	r3, [pc, #52]	; (800c8dc <DMAChannel1_IRQHandler+0x38>)

	DMA_CCR1 = 0x00000000; // disable DMA1
 800c8a8:	490d      	ldr	r1, [pc, #52]	; (800c8e0 <DMAChannel1_IRQHandler+0x3c>)
 800c8aa:	2000      	movs	r0, #0
void EXTI4_IRQHandler(void)
{}

void            DMAChannel1_IRQHandler(void)
{
	u8 ss = scan_segment;
 800c8ac:	781a      	ldrb	r2, [r3, #0]

	DMA_CCR1 = 0x00000000; // disable DMA1
 800c8ae:	6008      	str	r0, [r1, #0]
	DMA_IFCR = 0x00000002; // clear transfer complete interrupt for DMA channel1
 800c8b0:	480c      	ldr	r0, [pc, #48]	; (800c8e4 <DMAChannel1_IRQHandler+0x40>)
 800c8b2:	2402      	movs	r4, #2
 800c8b4:	6004      	str	r4, [r0, #0]
	if (ss >= SCAN_SEGMENTS - 1)
		ss = 0;
	else
		ss++;

	DMA_CMAR1 = (u32)&scan_buffer + ss * SCAN_SEGMENT_SZ * sizeof(scan_buffer[0]);
 800c8b6:	4c0c      	ldr	r4, [pc, #48]	; (800c8e8 <DMAChannel1_IRQHandler+0x44>)
void            DMAChannel1_IRQHandler(void)
{
	u8 ss = scan_segment;

	DMA_CCR1 = 0x00000000; // disable DMA1
	DMA_IFCR = 0x00000002; // clear transfer complete interrupt for DMA channel1
 800c8b8:	f1d2 0201 	rsbs	r2, r2, #1
 800c8bc:	bf38      	it	cc
 800c8be:	2200      	movcc	r2, #0
	if (ss >= SCAN_SEGMENTS - 1)
		ss = 0;
	else
		ss++;

	DMA_CMAR1 = (u32)&scan_buffer + ss * SCAN_SEGMENT_SZ * sizeof(scan_buffer[0]);
 800c8c0:	eb04 24c2 	add.w	r4, r4, r2, lsl #11
 800c8c4:	3010      	adds	r0, #16
 800c8c6:	6004      	str	r4, [r0, #0]
	DMA_CNDTR1 = SCAN_SEGMENT_SZ;
 800c8c8:	3808      	subs	r0, #8
 800c8ca:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800c8ce:	6004      	str	r4, [r0, #0]
	DMA_CCR1 = 0x00003583; // enable DMA1
 800c8d0:	f243 5083 	movw	r0, #13699	; 0x3583
 800c8d4:	6008      	str	r0, [r1, #0]
	scan_segment = ss;
 800c8d6:	701a      	strb	r2, [r3, #0]
}
 800c8d8:	bd10      	pop	{r4, pc}
 800c8da:	bf00      	nop
 800c8dc:	20004b3c 	.word	0x20004b3c
 800c8e0:	40020008 	.word	0x40020008
 800c8e4:	40020004 	.word	0x40020004
 800c8e8:	20003b34 	.word	0x20003b34

0800c8ec <DMAChannel2_IRQHandler>:


void            DMAChannel2_IRQHandler(void)
{
}
 800c8ec:	4770      	bx	lr

0800c8ee <DMAChannel3_IRQHandler>:

void            DMAChannel3_IRQHandler(void)
{
}
 800c8ee:	4770      	bx	lr

0800c8f0 <DMAChannel4_IRQHandler>:

void            DMAChannel4_IRQHandler(void)
{
}
 800c8f0:	4770      	bx	lr

0800c8f2 <DMAChannel5_IRQHandler>:

void            DMAChannel5_IRQHandler(void)
{
}
 800c8f2:	4770      	bx	lr

0800c8f4 <DMAChannel6_IRQHandler>:

void            DMAChannel6_IRQHandler(void)
{
}
 800c8f4:	4770      	bx	lr

0800c8f6 <DMAChannel7_IRQHandler>:

void            DMAChannel7_IRQHandler(void)
{
}
 800c8f6:	4770      	bx	lr

0800c8f8 <ADC_IRQHandler>:

void            ADC_IRQHandler(void)
{
}
 800c8f8:	4770      	bx	lr

0800c8fa <CAN_RX1_IRQHandler>:
	__USB_Istr();
}

void            CAN_RX1_IRQHandler(void)
{
}
 800c8fa:	4770      	bx	lr

0800c8fc <CAN_SCE_IRQHandler>:

void            CAN_SCE_IRQHandler(void)
{
}
 800c8fc:	4770      	bx	lr

0800c8fe <EXTI9_5_IRQHandler>:

void            EXTI9_5_IRQHandler(void)
{
}
 800c8fe:	4770      	bx	lr

0800c900 <TIM1_BRK_IRQHandler>:

void            TIM1_BRK_IRQHandler(void)
{
}
 800c900:	4770      	bx	lr

0800c902 <TIM1_UP_IRQHandler>:

void            TIM1_UP_IRQHandler(void)
{
}
 800c902:	4770      	bx	lr

0800c904 <TIM1_TRG_COM_IRQHandler>:

void            TIM1_TRG_COM_IRQHandler(void)
{
}
 800c904:	4770      	bx	lr

0800c906 <TIM1_CC_IRQHandler>:

void            TIM1_CC_IRQHandler(void)
{
}
 800c906:	4770      	bx	lr

0800c908 <TIM2_IRQHandler>:

// TIM2 is used as a PWM output to the dc bias offset opamp
void            TIM2_IRQHandler(void)
{
}
 800c908:	4770      	bx	lr

0800c90a <TIM4_IRQHandler>:


// TIM4 drives the reference output
void            TIM4_IRQHandler(void)
{
}
 800c90a:	4770      	bx	lr

0800c90c <I2C1_EV_IRQHandler>:

void            I2C1_EV_IRQHandler(void)
{
}
 800c90c:	4770      	bx	lr

0800c90e <I2C1_ER_IRQHandler>:

void            I2C1_ER_IRQHandler(void)
{
}
 800c90e:	4770      	bx	lr

0800c910 <I2C2_EV_IRQHandler>:

void            I2C2_EV_IRQHandler(void)
{
}
 800c910:	4770      	bx	lr

0800c912 <I2C2_ER_IRQHandler>:

void            I2C2_ER_IRQHandler(void)
{
}
 800c912:	4770      	bx	lr

0800c914 <SPI1_IRQHandler>:

void            SPI1_IRQHandler(void)
{
}
 800c914:	4770      	bx	lr

0800c916 <SPI2_IRQHandler>:

void            SPI2_IRQHandler(void)
{
}
 800c916:	4770      	bx	lr

0800c918 <USART1_IRQHandler>:

void            USART1_IRQHandler(void)
{
}
 800c918:	4770      	bx	lr

0800c91a <USART2_IRQHandler>:

void            USART2_IRQHandler(void)
{
}
 800c91a:	4770      	bx	lr

0800c91c <USART3_IRQHandler>:

void            USART3_IRQHandler(void)
{
}
 800c91c:	4770      	bx	lr

0800c91e <EXTI15_10_IRQHandler>:

void            EXTI15_10_IRQHandler(void)
{
}
 800c91e:	4770      	bx	lr

0800c920 <RTCAlarm_IRQHandler>:

void            RTCAlarm_IRQHandler(void)
{
}
 800c920:	4770      	bx	lr

0800c922 <USBWakeUp_IRQHandler>:

void            USBWakeUp_IRQHandler(void)
{
}
 800c922:	4770      	bx	lr

0800c924 <TIM3_IRQHandler>:
void            TIM3_IRQHandler(void)
{
	keycodes key;
	configurations *cp = &configuration;

	TIM3_SR = 0; // clear the interrupt flag
 800c924:	4b3c      	ldr	r3, [pc, #240]	; (800ca18 <TIM3_IRQHandler+0xf4>)
              its mainly uesed for system clock delay
	      and detect the key periodically
******************************************************************************/
// ADC data comes in at 2 mHz rate, with 10 mS 20,000 samples
void            TIM3_IRQHandler(void)
{
 800c926:	b537      	push	{r0, r1, r2, r4, r5, lr}
	keycodes key;
	configurations *cp = &configuration;

	TIM3_SR = 0; // clear the interrupt flag
 800c928:	2200      	movs	r2, #0
 800c92a:	601a      	str	r2, [r3, #0]
	sys_time++;
 800c92c:	4b3b      	ldr	r3, [pc, #236]	; (800ca1c <TIM3_IRQHandler+0xf8>)
 800c92e:	681a      	ldr	r2, [r3, #0]
 800c930:	3201      	adds	r2, #1
 800c932:	601a      	str	r2, [r3, #0]
	if (ctr_refresh >= 0)
 800c934:	4b3a      	ldr	r3, [pc, #232]	; (800ca20 <TIM3_IRQHandler+0xfc>)
 800c936:	881a      	ldrh	r2, [r3, #0]
 800c938:	b212      	sxth	r2, r2
 800c93a:	2a00      	cmp	r2, #0
 800c93c:	db03      	blt.n	800c946 <TIM3_IRQHandler+0x22>
		ctr_refresh--;	// display updates
 800c93e:	881a      	ldrh	r2, [r3, #0]
 800c940:	3a01      	subs	r2, #1
 800c942:	b292      	uxth	r2, r2
 800c944:	801a      	strh	r2, [r3, #0]
	if (ctr_key >= 0)
 800c946:	4b37      	ldr	r3, [pc, #220]	; (800ca24 <TIM3_IRQHandler+0x100>)
 800c948:	881a      	ldrh	r2, [r3, #0]
 800c94a:	b212      	sxth	r2, r2
 800c94c:	2a00      	cmp	r2, #0
 800c94e:	db03      	blt.n	800c958 <TIM3_IRQHandler+0x34>
		ctr_key--;		// keystroke checking etc
 800c950:	881a      	ldrh	r2, [r3, #0]
 800c952:	3a01      	subs	r2, #1
 800c954:	b292      	uxth	r2, r2
 800c956:	801a      	strh	r2, [r3, #0]
	if (ctr_beep >= 0)
 800c958:	4b33      	ldr	r3, [pc, #204]	; (800ca28 <TIM3_IRQHandler+0x104>)
 800c95a:	881a      	ldrh	r2, [r3, #0]
 800c95c:	b212      	sxth	r2, r2
 800c95e:	2a00      	cmp	r2, #0
 800c960:	db03      	blt.n	800c96a <TIM3_IRQHandler+0x46>
		ctr_beep--;		// sound
 800c962:	881a      	ldrh	r2, [r3, #0]
 800c964:	3a01      	subs	r2, #1
 800c966:	b292      	uxth	r2, r2
 800c968:	801a      	strh	r2, [r3, #0]

	if (ctr_key == 0) { // check key press every 20ms
 800c96a:	4b2e      	ldr	r3, [pc, #184]	; (800ca24 <TIM3_IRQHandler+0x100>)
 800c96c:	881a      	ldrh	r2, [r3, #0]
 800c96e:	b9b2      	cbnz	r2, 800c99e <TIM3_IRQHandler+0x7a>
		ctr_key = KEY_SAMPLE;
 800c970:	f04f 020a 	mov.w	r2, #10
 800c974:	801a      	strh	r2, [r3, #0]
		key = Get_Key();	// Get_Key handles repeats etc.
 800c976:	f000 fb67 	bl	800d048 <Get_Key>
		if(key != KEYCODE_VOID){
 800c97a:	2801      	cmp	r0, #1
 800c97c:	d00f      	beq.n	800c99e <TIM3_IRQHandler+0x7a>
			switch(cp->mode){
 800c97e:	4b2b      	ldr	r3, [pc, #172]	; (800ca2c <TIM3_IRQHandler+0x108>)
 800c980:	799b      	ldrb	r3, [r3, #6]
 800c982:	2b01      	cmp	r3, #1
 800c984:	d006      	beq.n	800c994 <TIM3_IRQHandler+0x70>
 800c986:	d302      	bcc.n	800c98e <TIM3_IRQHandler+0x6a>
 800c988:	2b02      	cmp	r3, #2
 800c98a:	d108      	bne.n	800c99e <TIM3_IRQHandler+0x7a>
 800c98c:	e005      	b.n	800c99a <TIM3_IRQHandler+0x76>
				case PHA:
					Do_Keys_PHA(key);
 800c98e:	f000 f8d7 	bl	800cb40 <Do_Keys_PHA>
					break;
 800c992:	e004      	b.n	800c99e <TIM3_IRQHandler+0x7a>
				case RATE:
					Do_Keys_Rate(key);
 800c994:	f000 f890 	bl	800cab8 <Do_Keys_Rate>
					break;
 800c998:	e001      	b.n	800c99e <TIM3_IRQHandler+0x7a>
				//case SCOPE:
				//case DERIV:
				//	Do_Keys_Scope(key);
				//	break;
				case MENU:
					Do_Keys_Menu(key);
 800c99a:	f001 fe7f 	bl	800e69c <Do_Keys_Menu>
					break;
			}
		}
	}

	if (ctr_beep == 0) {	// Turn off the beep signal
 800c99e:	4b22      	ldr	r3, [pc, #136]	; (800ca28 <TIM3_IRQHandler+0x104>)
 800c9a0:	881b      	ldrh	r3, [r3, #0]
 800c9a2:	b923      	cbnz	r3, 800c9ae <TIM3_IRQHandler+0x8a>
		TIM4_CR1 &= ~(0x0001);  //CEN=0, TIMER4 Enable
 800c9a4:	4b22      	ldr	r3, [pc, #136]	; (800ca30 <TIM3_IRQHandler+0x10c>)
 800c9a6:	681a      	ldr	r2, [r3, #0]
 800c9a8:	f022 0201 	bic.w	r2, r2, #1
 800c9ac:	601a      	str	r2, [r3, #0]
	}

	if (ctr_refresh == 0){
 800c9ae:	4b1c      	ldr	r3, [pc, #112]	; (800ca20 <TIM3_IRQHandler+0xfc>)
 800c9b0:	881a      	ldrh	r2, [r3, #0]
 800c9b2:	2a00      	cmp	r2, #0
 800c9b4:	d12e      	bne.n	800ca14 <TIM3_IRQHandler+0xf0>
		ctr_refresh = cp->refresh_time * 1000;
 800c9b6:	4c1d      	ldr	r4, [pc, #116]	; (800ca2c <TIM3_IRQHandler+0x108>)
 800c9b8:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800c9bc:	8962      	ldrh	r2, [r4, #10]
 800c9be:	434a      	muls	r2, r1
 800c9c0:	b292      	uxth	r2, r2
 800c9c2:	801a      	strh	r2, [r3, #0]
		Update_Battery();
 800c9c4:	f000 fb24 	bl	800d010 <Update_Battery>
		switch(cp->mode){
 800c9c8:	79a3      	ldrb	r3, [r4, #6]
 800c9ca:	b113      	cbz	r3, 800c9d2 <TIM3_IRQHandler+0xae>
 800c9cc:	2b01      	cmp	r3, #1
 800c9ce:	d105      	bne.n	800c9dc <TIM3_IRQHandler+0xb8>
 800c9d0:	e002      	b.n	800c9d8 <TIM3_IRQHandler+0xb4>
			case PHA:
				Display_Spectrum();
 800c9d2:	f002 fa91 	bl	800eef8 <Display_Spectrum>
				break;
 800c9d6:	e001      	b.n	800c9dc <TIM3_IRQHandler+0xb8>
			case RATE:
				Display_Rate();
 800c9d8:	f002 f99a 	bl	800ed10 <Display_Rate>
			//	Display_Scope();
			//	break;
			case MENU:
				break;
		}
		if(!stop){		// stop == TRUE also stops signal collection in main.c
 800c9dc:	4b15      	ldr	r3, [pc, #84]	; (800ca34 <TIM3_IRQHandler+0x110>)
 800c9de:	781b      	ldrb	r3, [r3, #0]
 800c9e0:	b90b      	cbnz	r3, 800c9e6 <TIM3_IRQHandler+0xc2>
			Update_Rate();
 800c9e2:	f002 f859 	bl	800ea98 <Update_Rate>
		}
		if (SD_Card_On()){
 800c9e6:	f000 fae3 	bl	800cfb0 <SD_Card_On>
 800c9ea:	4c13      	ldr	r4, [pc, #76]	; (800ca38 <TIM3_IRQHandler+0x114>)
 800c9ec:	b108      	cbz	r0, 800c9f2 <TIM3_IRQHandler+0xce>
			SD_Card = FALSE;	// no TF, micro SD card
 800c9ee:	2300      	movs	r3, #0
 800c9f0:	e00f      	b.n	800ca12 <TIM3_IRQHandler+0xee>
		} else {	// card detected
			if(SD_Card == FALSE){
 800c9f2:	7825      	ldrb	r5, [r4, #0]
 800c9f4:	b975      	cbnz	r5, 800ca14 <TIM3_IRQHandler+0xf0>
				if (FAT_Info()){
 800c9f6:	f000 fda3 	bl	800d540 <FAT_Info>
 800c9fa:	b148      	cbz	r0, 800ca10 <TIM3_IRQHandler+0xec>
					__Display_Str(0, 0, RED, BKGND_COLOR, SD_Msgs[SDErr]);
 800c9fc:	4b0f      	ldr	r3, [pc, #60]	; (800ca3c <TIM3_IRQHandler+0x118>)
 800c9fe:	4628      	mov	r0, r5
 800ca00:	689b      	ldr	r3, [r3, #8]
 800ca02:	4629      	mov	r1, r5
 800ca04:	9300      	str	r3, [sp, #0]
 800ca06:	221f      	movs	r2, #31
 800ca08:	462b      	mov	r3, r5
 800ca0a:	f7f7 fb90 	bl	800412e <__Display_Str>
 800ca0e:	e001      	b.n	800ca14 <TIM3_IRQHandler+0xf0>
				} else {
					SD_Card = TRUE;
 800ca10:	2301      	movs	r3, #1
 800ca12:	7023      	strb	r3, [r4, #0]
				}
			}
		}
	}
}
 800ca14:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 800ca16:	bf00      	nop
 800ca18:	40000410 	.word	0x40000410
 800ca1c:	20004b38 	.word	0x20004b38
 800ca20:	20004b48 	.word	0x20004b48
 800ca24:	20004b4a 	.word	0x20004b4a
 800ca28:	20004b34 	.word	0x20004b34
 800ca2c:	20003ac8 	.word	0x20003ac8
 800ca30:	40000800 	.word	0x40000800
 800ca34:	2000183c 	.word	0x2000183c
 800ca38:	20004d7c 	.word	0x20004d7c
 800ca3c:	2000180c 	.word	0x2000180c

0800ca40 <UsageFaultException>:
{
	__Display_Str(100, 20, RED, BKGND_COLOR, msgbfe);
	while (1) {}
}
void UsageFaultException(void)
{
 800ca40:	b507      	push	{r0, r1, r2, lr}
	__Display_Str(100, 20, RED, BKGND_COLOR, msgufe);
 800ca42:	4b05      	ldr	r3, [pc, #20]	; (800ca58 <UsageFaultException+0x18>)
 800ca44:	2064      	movs	r0, #100	; 0x64
 800ca46:	681b      	ldr	r3, [r3, #0]
 800ca48:	2114      	movs	r1, #20
 800ca4a:	9300      	str	r3, [sp, #0]
 800ca4c:	221f      	movs	r2, #31
 800ca4e:	2300      	movs	r3, #0
 800ca50:	f7f7 fb6d 	bl	800412e <__Display_Str>
 800ca54:	e7fe      	b.n	800ca54 <UsageFaultException+0x14>
 800ca56:	bf00      	nop
 800ca58:	0801019c 	.word	0x0801019c

0800ca5c <BusFaultException>:
	__Display_Str(100, 20, RED, BKGND_COLOR, msgmm);
	while (1) {}
}

void BusFaultException(void)
{
 800ca5c:	b507      	push	{r0, r1, r2, lr}
	__Display_Str(100, 20, RED, BKGND_COLOR, msgbfe);
 800ca5e:	4b05      	ldr	r3, [pc, #20]	; (800ca74 <BusFaultException+0x18>)
 800ca60:	2064      	movs	r0, #100	; 0x64
 800ca62:	685b      	ldr	r3, [r3, #4]
 800ca64:	2114      	movs	r1, #20
 800ca66:	9300      	str	r3, [sp, #0]
 800ca68:	221f      	movs	r2, #31
 800ca6a:	2300      	movs	r3, #0
 800ca6c:	f7f7 fb5f 	bl	800412e <__Display_Str>
 800ca70:	e7fe      	b.n	800ca70 <BusFaultException+0x14>
 800ca72:	bf00      	nop
 800ca74:	0801019c 	.word	0x0801019c

0800ca78 <MemManageException>:
	__Display_Str(100, 20, RED, BKGND_COLOR, msghard);
	while (1) {}
}

void MemManageException(void)
{
 800ca78:	b507      	push	{r0, r1, r2, lr}
	__Display_Str(100, 20, RED, BKGND_COLOR, msgmm);
 800ca7a:	4b05      	ldr	r3, [pc, #20]	; (800ca90 <MemManageException+0x18>)
 800ca7c:	2064      	movs	r0, #100	; 0x64
 800ca7e:	689b      	ldr	r3, [r3, #8]
 800ca80:	2114      	movs	r1, #20
 800ca82:	9300      	str	r3, [sp, #0]
 800ca84:	221f      	movs	r2, #31
 800ca86:	2300      	movs	r3, #0
 800ca88:	f7f7 fb51 	bl	800412e <__Display_Str>
 800ca8c:	e7fe      	b.n	800ca8c <MemManageException+0x14>
 800ca8e:	bf00      	nop
 800ca90:	0801019c 	.word	0x0801019c

0800ca94 <HardFaultException>:

void NMIException(void)
{}

void HardFaultException(void)
{
 800ca94:	b507      	push	{r0, r1, r2, lr}
	__Display_Str(100, 20, RED, BKGND_COLOR, msghard);
 800ca96:	4b05      	ldr	r3, [pc, #20]	; (800caac <HardFaultException+0x18>)
 800ca98:	2064      	movs	r0, #100	; 0x64
 800ca9a:	68db      	ldr	r3, [r3, #12]
 800ca9c:	2114      	movs	r1, #20
 800ca9e:	9300      	str	r3, [sp, #0]
 800caa0:	221f      	movs	r2, #31
 800caa2:	2300      	movs	r3, #0
 800caa4:	f7f7 fb43 	bl	800412e <__Display_Str>
 800caa8:	e7fe      	b.n	800caa8 <HardFaultException+0x14>
 800caaa:	bf00      	nop
 800caac:	0801019c 	.word	0x0801019c

0800cab0 <USB_LP_CAN_RX0_IRQHandler>:
}

void            USB_LP_CAN_RX0_IRQHandler(void)
{
	//__Display_Str(100, 20, RED, PRN, "USB_LP_CAN_RX0_IRQHandler");
	__USB_Istr();
 800cab0:	f7f7 bb2e 	b.w	8004110 <__USB_Istr>

0800cab4 <USB_HP_CAN_TX_IRQHandler>:
}

void            USB_HP_CAN_TX_IRQHandler(void)
{
	//__Display_Str(100, 20, RED, PRN, "USB_HP_CAN_TX_IRQHandler");
	__CTR_HP();
 800cab4:	f7f7 bb2e 	b.w	8004114 <__CTR_HP>

0800cab8 <Do_Keys_Rate>:
 Description : adjusts cursor
*******************************************************************************/

#define KEY_PERIOD 200		// spacing of key processing, controls auto repeat

void Do_Keys_Rate (keycodes key){
 800cab8:	b538      	push	{r3, r4, r5, lr}
	s16 tmp, step;
	s16 cursor;

	Display_Info("Do_Keys_Rate", 0);
 800caba:	2100      	movs	r1, #0
 Description : adjusts cursor
*******************************************************************************/

#define KEY_PERIOD 200		// spacing of key processing, controls auto repeat

void Do_Keys_Rate (keycodes key){
 800cabc:	4604      	mov	r4, r0
	s16 tmp, step;
	s16 cursor;

	Display_Info("Do_Keys_Rate", 0);
 800cabe:	481d      	ldr	r0, [pc, #116]	; (800cb34 <Do_Keys_Rate+0x7c>)
 800cac0:	f000 fc21 	bl	800d306 <Display_Info>
	cursor = confp->rate_cursor;
 800cac4:	4b1c      	ldr	r3, [pc, #112]	; (800cb38 <Do_Keys_Rate+0x80>)
	switch (key){
 800cac6:	3c02      	subs	r4, #2
void Do_Keys_Rate (keycodes key){
	s16 tmp, step;
	s16 cursor;

	Display_Info("Do_Keys_Rate", 0);
	cursor = confp->rate_cursor;
 800cac8:	681b      	ldr	r3, [r3, #0]
 800caca:	f8b3 5062 	ldrh.w	r5, [r3, #98]	; 0x62
	switch (key){
 800cace:	2c06      	cmp	r4, #6
 800cad0:	d82b      	bhi.n	800cb2a <Do_Keys_Rate+0x72>
 800cad2:	e8df f004 	tbb	[pc, r4]
 800cad6:	1204      	.short	0x1204
 800cad8:	232a2a2a 	.word	0x232a2a2a
 800cadc:	1a          	.byte	0x1a
 800cadd:	00          	.byte	0x00
		case KEYCODE_PLAY:
			stop = !stop;
 800cade:	4a17      	ldr	r2, [pc, #92]	; (800cb3c <Do_Keys_Rate+0x84>)
 800cae0:	7813      	ldrb	r3, [r2, #0]
 800cae2:	f1d3 0301 	rsbs	r3, r3, #1
 800cae6:	bf38      	it	cc
 800cae8:	2300      	movcc	r3, #0
 800caea:	7013      	strb	r3, [r2, #0]
			if(stop)
 800caec:	b113      	cbz	r3, 800caf4 <Do_Keys_Rate+0x3c>
				ADC_Stop();
 800caee:	f000 f9db 	bl	800cea8 <ADC_Stop>
 800caf2:	e01a      	b.n	800cb2a <Do_Keys_Rate+0x72>
			else
				ADC_Start();
 800caf4:	f000 f9e2 	bl	800cebc <ADC_Start>
 800caf8:	e017      	b.n	800cb2a <Do_Keys_Rate+0x72>
			break;
		case KEYCODE_M:
			confp->rtn_mode = confp->mode;
 800cafa:	799a      	ldrb	r2, [r3, #6]
			confp->mode = MENU;
			Display_Menu(confp->menu_index);
 800cafc:	8898      	ldrh	r0, [r3, #4]
				ADC_Stop();
			else
				ADC_Start();
			break;
		case KEYCODE_M:
			confp->rtn_mode = confp->mode;
 800cafe:	71da      	strb	r2, [r3, #7]
			confp->mode = MENU;
 800cb00:	2202      	movs	r2, #2
 800cb02:	719a      	strb	r2, [r3, #6]
			Display_Menu(confp->menu_index);
 800cb04:	f001 fd6c 	bl	800e5e0 <Display_Menu>
			break;
 800cb08:	e00f      	b.n	800cb2a <Do_Keys_Rate+0x72>
			break;
		case KEYCODE_DOWN:		// no zoom in rate mode
			break;
		case KEYCODE_RIGHT:
			step = 2;
			cursor += step;
 800cb0a:	3502      	adds	r5, #2
			if(cursor >= confp->graph_width){		// stop on far right side
 800cb0c:	8a9b      	ldrh	r3, [r3, #20]
			break;
		case KEYCODE_DOWN:		// no zoom in rate mode
			break;
		case KEYCODE_RIGHT:
			step = 2;
			cursor += step;
 800cb0e:	b2ad      	uxth	r5, r5
			if(cursor >= confp->graph_width){		// stop on far right side
 800cb10:	b229      	sxth	r1, r5
 800cb12:	b21a      	sxth	r2, r3
 800cb14:	4291      	cmp	r1, r2
 800cb16:	db06      	blt.n	800cb26 <Do_Keys_Rate+0x6e>
				cursor = confp->graph_width - 1;
 800cb18:	1e5d      	subs	r5, r3, #1
 800cb1a:	e003      	b.n	800cb24 <Do_Keys_Rate+0x6c>
			}
			Display_Rate();
			break;
		case KEYCODE_LEFT:
			step = 2;
			cursor -= step;
 800cb1c:	3d02      	subs	r5, #2
 800cb1e:	b22d      	sxth	r5, r5
 800cb20:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
 800cb24:	b2ad      	uxth	r5, r5
			if(cursor < 0){		// stop on far right side
				cursor = 0;
			}
			Display_Rate();
 800cb26:	f002 f8f3 	bl	800ed10 <Display_Rate>
			break;
	}
	confp->rate_cursor = cursor;
 800cb2a:	4b03      	ldr	r3, [pc, #12]	; (800cb38 <Do_Keys_Rate+0x80>)
 800cb2c:	681b      	ldr	r3, [r3, #0]
 800cb2e:	f8a3 5062 	strh.w	r5, [r3, #98]	; 0x62
}
 800cb32:	bd38      	pop	{r3, r4, r5, pc}
 800cb34:	080106b7 	.word	0x080106b7
 800cb38:	20001800 	.word	0x20001800
 800cb3c:	2000183c 	.word	0x2000183c

0800cb40 <Do_Keys_PHA>:
	 it reaches end of window then shift the window.
*******************************************************************************/

#define KEY_PERIOD 200		// spacing of key processing, controls auto repeat

void Do_Keys_PHA (keycodes key){
 800cb40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	s16 tmp, step, channels;
	s16 cursor_hi, cursor_lo, window_hi, window_lo, zoom;

	Display_Info("Do_Keys_PHA", 0);
 800cb44:	2100      	movs	r1, #0
	 it reaches end of window then shift the window.
*******************************************************************************/

#define KEY_PERIOD 200		// spacing of key processing, controls auto repeat

void Do_Keys_PHA (keycodes key){
 800cb46:	4604      	mov	r4, r0
	s16 tmp, step, channels;
	s16 cursor_hi, cursor_lo, window_hi, window_lo, zoom;

	Display_Info("Do_Keys_PHA", 0);
 800cb48:	4858      	ldr	r0, [pc, #352]	; (800ccac <Do_Keys_PHA+0x16c>)
 800cb4a:	f000 fbdc 	bl	800d306 <Display_Info>
	channels = confp->pha_channels;
 800cb4e:	4b58      	ldr	r3, [pc, #352]	; (800ccb0 <Do_Keys_PHA+0x170>)
 800cb50:	681b      	ldr	r3, [r3, #0]
	cursor_hi = confp->pha_cursor_hi;
	cursor_lo = confp->pha_cursor_lo;
	window_hi = confp->pha_window_hi;
	window_lo = confp->pha_window_lo;
	zoom = confp->pha_zoom;
 800cb52:	f893 1044 	ldrb.w	r1, [r3, #68]	; 0x44
void Do_Keys_PHA (keycodes key){
	s16 tmp, step, channels;
	s16 cursor_hi, cursor_lo, window_hi, window_lo, zoom;

	Display_Info("Do_Keys_PHA", 0);
	channels = confp->pha_channels;
 800cb56:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
	cursor_hi = confp->pha_cursor_hi;
	cursor_lo = confp->pha_cursor_lo;
	window_hi = confp->pha_window_hi;
	window_lo = confp->pha_window_lo;
	zoom = confp->pha_zoom;
	if(zoom >= 8)
 800cb58:	2907      	cmp	r1, #7
	s16 tmp, step, channels;
	s16 cursor_hi, cursor_lo, window_hi, window_lo, zoom;

	Display_Info("Do_Keys_PHA", 0);
	channels = confp->pha_channels;
	cursor_hi = confp->pha_cursor_hi;
 800cb5a:	f8b3 6046 	ldrh.w	r6, [r3, #70]	; 0x46
	cursor_lo = confp->pha_cursor_lo;
 800cb5e:	f8b3 8048 	ldrh.w	r8, [r3, #72]	; 0x48
	window_hi = confp->pha_window_hi;
 800cb62:	f8b3 5040 	ldrh.w	r5, [r3, #64]	; 0x40
	window_lo = confp->pha_window_lo;
 800cb66:	f8b3 7042 	ldrh.w	r7, [r3, #66]	; 0x42
	zoom = confp->pha_zoom;
 800cb6a:	468a      	mov	sl, r1
	if(zoom >= 8)
 800cb6c:	dd01      	ble.n	800cb72 <Do_Keys_PHA+0x32>
 800cb6e:	2001      	movs	r0, #1
 800cb70:	e009      	b.n	800cb86 <Do_Keys_PHA+0x46>
		step = 1;
	else
		step = (window_hi - window_lo) / 64;
 800cb72:	fa0f fc85 	sxth.w	ip, r5
 800cb76:	b238      	sxth	r0, r7
 800cb78:	ebbc 0000 	subs.w	r0, ip, r0
 800cb7c:	bf48      	it	mi
 800cb7e:	303f      	addmi	r0, #63	; 0x3f
 800cb80:	1180      	asrs	r0, r0, #6
 800cb82:	46b9      	mov	r9, r7
 800cb84:	b280      	uxth	r0, r0
	// Handle keys here as mode dependant
	switch (key){
 800cb86:	3c02      	subs	r4, #2
 800cb88:	2c06      	cmp	r4, #6
 800cb8a:	f200 8081 	bhi.w	800cc90 <Do_Keys_PHA+0x150>
 800cb8e:	e8df f004 	tbb	[pc, r4]
 800cb92:	1204      	.short	0x1204
 800cb94:	64281a7f 	.word	0x64281a7f
 800cb98:	4b          	.byte	0x4b
 800cb99:	00          	.byte	0x00
		case KEYCODE_PLAY:
			stop = !stop;
 800cb9a:	4a46      	ldr	r2, [pc, #280]	; (800ccb4 <Do_Keys_PHA+0x174>)
 800cb9c:	7813      	ldrb	r3, [r2, #0]
 800cb9e:	f1d3 0301 	rsbs	r3, r3, #1
 800cba2:	bf38      	it	cc
 800cba4:	2300      	movcc	r3, #0
 800cba6:	7013      	strb	r3, [r2, #0]
			if(stop)
 800cba8:	b113      	cbz	r3, 800cbb0 <Do_Keys_PHA+0x70>
				ADC_Stop();
 800cbaa:	f000 f97d 	bl	800cea8 <ADC_Stop>
 800cbae:	e06f      	b.n	800cc90 <Do_Keys_PHA+0x150>
			else
				ADC_Start();
 800cbb0:	f000 f984 	bl	800cebc <ADC_Start>
 800cbb4:	e06c      	b.n	800cc90 <Do_Keys_PHA+0x150>
			break;
		case KEYCODE_M:
			confp->rtn_mode = confp->mode;
 800cbb6:	799a      	ldrb	r2, [r3, #6]
			confp->mode = MENU;
			Display_Menu(confp->menu_index);
 800cbb8:	8898      	ldrh	r0, [r3, #4]
				ADC_Stop();
			else
				ADC_Start();
			break;
		case KEYCODE_M:
			confp->rtn_mode = confp->mode;
 800cbba:	71da      	strb	r2, [r3, #7]
			confp->mode = MENU;
 800cbbc:	2202      	movs	r2, #2
 800cbbe:	719a      	strb	r2, [r3, #6]
			Display_Menu(confp->menu_index);
 800cbc0:	f001 fd0e 	bl	800e5e0 <Display_Menu>
			break;
 800cbc4:	e064      	b.n	800cc90 <Do_Keys_PHA+0x150>
		case KEYCODE_UP:		// zoom in on cursor by factor of 2
			if(confp->pha_zoom >= (MAX_CHANNELS / confp->graph_width))
 800cbc6:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 800cbca:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800cbce:	fb90 f3f3 	sdiv	r3, r0, r3
 800cbd2:	4299      	cmp	r1, r3
 800cbd4:	da5c      	bge.n	800cc90 <Do_Keys_PHA+0x150>
				break;		// limit zoom in
			zoom *= 2;		// shrink window by 2
 800cbd6:	ea4f 0a41 	mov.w	sl, r1, lsl #1
			tmp = channels / zoom;
 800cbda:	b213      	sxth	r3, r2
 800cbdc:	fb93 f5fa 	sdiv	r5, r3, sl
 800cbe0:	e00d      	b.n	800cbfe <Do_Keys_PHA+0xbe>
			if(window_lo < 0)
				window_lo = 0;
			Display_Spectrum();
			break;
		case KEYCODE_DOWN:		// zoom out by factor of 2
			if(confp->pha_zoom <= 1)
 800cbe2:	2901      	cmp	r1, #1
 800cbe4:	d954      	bls.n	800cc90 <Do_Keys_PHA+0x150>
				break;		// limit zoom in
			zoom /= 2;		// shrink window by 2
 800cbe6:	ea4f 0a51 	mov.w	sl, r1, lsr #1
			if(zoom <= 1){	// compensate for division truncation
 800cbea:	fa0f f58a 	sxth.w	r5, sl
 800cbee:	2d01      	cmp	r5, #1
 800cbf0:	dc02      	bgt.n	800cbf8 <Do_Keys_PHA+0xb8>
 800cbf2:	b295      	uxth	r5, r2
 800cbf4:	2700      	movs	r7, #0
 800cbf6:	e04b      	b.n	800cc90 <Do_Keys_PHA+0x150>
				window_hi = confp->pha_channels;
				window_lo = 0;
				break;
			}
			tmp = channels / zoom;
 800cbf8:	b213      	sxth	r3, r2
 800cbfa:	fb93 f5f5 	sdiv	r5, r3, r5
			window_hi = cursor_hi + (tmp / 2);
 800cbfe:	b2af      	uxth	r7, r5
 800cc00:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 800cc04:	eb06 0565 	add.w	r5, r6, r5, asr #1
 800cc08:	b2ad      	uxth	r5, r5
			if(window_hi > channels)
 800cc0a:	b229      	sxth	r1, r5
 800cc0c:	4299      	cmp	r1, r3
 800cc0e:	dd01      	ble.n	800cc14 <Do_Keys_PHA+0xd4>
				window_hi = channels - 1;
 800cc10:	1e55      	subs	r5, r2, #1
 800cc12:	b2ad      	uxth	r5, r5
			window_lo = cursor_lo - (tmp / 2);
 800cc14:	b23f      	sxth	r7, r7
 800cc16:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
 800cc1a:	eba8 0767 	sub.w	r7, r8, r7, asr #1
 800cc1e:	b23f      	sxth	r7, r7
 800cc20:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
 800cc24:	b2bf      	uxth	r7, r7
 800cc26:	e031      	b.n	800cc8c <Do_Keys_PHA+0x14c>
			if(window_lo < 0)
				window_lo = 0;
			Display_Spectrum();
			break;
		case KEYCODE_RIGHT:
			tmp = cursor_hi - cursor_lo;
 800cc28:	b2b1      	uxth	r1, r6
			cursor_hi += step;
 800cc2a:	180e      	adds	r6, r1, r0
 800cc2c:	b2b6      	uxth	r6, r6
			if(cursor_hi >= channels){		// stop on far right side
 800cc2e:	b230      	sxth	r0, r6
 800cc30:	b213      	sxth	r3, r2
 800cc32:	4298      	cmp	r0, r3
 800cc34:	db01      	blt.n	800cc3a <Do_Keys_PHA+0xfa>
				cursor_hi = channels - 1;
 800cc36:	1e56      	subs	r6, r2, #1
 800cc38:	b2b6      	uxth	r6, r6
			}
			cursor_lo = cursor_hi - tmp;
			tmp = window_hi - window_lo;
			if(cursor_hi > window_hi){		// adjust window when cursor hits end
 800cc3a:	b230      	sxth	r0, r6
 800cc3c:	b22a      	sxth	r2, r5
 800cc3e:	4290      	cmp	r0, r2
			tmp = cursor_hi - cursor_lo;
			cursor_hi += step;
			if(cursor_hi >= channels){		// stop on far right side
				cursor_hi = channels - 1;
			}
			cursor_lo = cursor_hi - tmp;
 800cc40:	b2b3      	uxth	r3, r6
			tmp = window_hi - window_lo;
			if(cursor_hi > window_hi){		// adjust window when cursor hits end
 800cc42:	dd03      	ble.n	800cc4c <Do_Keys_PHA+0x10c>
				window_hi = cursor_hi;
				window_lo = window_hi - tmp;
 800cc44:	1bef      	subs	r7, r5, r7
 800cc46:	1bdf      	subs	r7, r3, r7
 800cc48:	b2bf      	uxth	r7, r7
 800cc4a:	461d      	mov	r5, r3
			tmp = cursor_hi - cursor_lo;
			cursor_hi += step;
			if(cursor_hi >= channels){		// stop on far right side
				cursor_hi = channels - 1;
			}
			cursor_lo = cursor_hi - tmp;
 800cc4c:	ebc8 0801 	rsb	r8, r8, r1
 800cc50:	ebc8 0803 	rsb	r8, r8, r3
 800cc54:	fa1f f888 	uxth.w	r8, r8
 800cc58:	e018      	b.n	800cc8c <Do_Keys_PHA+0x14c>
				window_lo = window_hi - tmp;
			}
			Display_Spectrum();
			break;
		case KEYCODE_LEFT:
			tmp = cursor_hi - cursor_lo;
 800cc5a:	fa1f f288 	uxth.w	r2, r8
			cursor_lo -= step;
 800cc5e:	ebc0 0802 	rsb	r8, r0, r2
 800cc62:	fa0f f888 	sxth.w	r8, r8
 800cc66:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
 800cc6a:	fa1f f888 	uxth.w	r8, r8
			if(cursor_lo < 0){		// stop on far right side
				cursor_lo = 0;
			}
			cursor_hi = cursor_lo + tmp;
			tmp = window_hi - window_lo;
			if(cursor_lo < window_lo){		// adjust window when cursor hits end
 800cc6e:	fa0f f088 	sxth.w	r0, r8
 800cc72:	b239      	sxth	r1, r7
 800cc74:	4288      	cmp	r0, r1
			tmp = cursor_hi - cursor_lo;
			cursor_lo -= step;
			if(cursor_lo < 0){		// stop on far right side
				cursor_lo = 0;
			}
			cursor_hi = cursor_lo + tmp;
 800cc76:	fa1f f388 	uxth.w	r3, r8
			tmp = window_hi - window_lo;
			if(cursor_lo < window_lo){		// adjust window when cursor hits end
 800cc7a:	46b9      	mov	r9, r7
 800cc7c:	da03      	bge.n	800cc86 <Do_Keys_PHA+0x146>
				window_lo = cursor_lo;
				window_hi = window_lo + tmp;
 800cc7e:	1bed      	subs	r5, r5, r7
 800cc80:	195d      	adds	r5, r3, r5
 800cc82:	b2ad      	uxth	r5, r5
 800cc84:	461f      	mov	r7, r3
			tmp = cursor_hi - cursor_lo;
			cursor_lo -= step;
			if(cursor_lo < 0){		// stop on far right side
				cursor_lo = 0;
			}
			cursor_hi = cursor_lo + tmp;
 800cc86:	1ab6      	subs	r6, r6, r2
 800cc88:	199e      	adds	r6, r3, r6
 800cc8a:	b2b6      	uxth	r6, r6
			tmp = window_hi - window_lo;
			if(cursor_lo < window_lo){		// adjust window when cursor hits end
				window_lo = cursor_lo;
				window_hi = window_lo + tmp;
			}
			Display_Spectrum ();
 800cc8c:	f002 f934 	bl	800eef8 <Display_Spectrum>
			break;
	}
	confp->pha_cursor_hi = cursor_hi;
 800cc90:	4b07      	ldr	r3, [pc, #28]	; (800ccb0 <Do_Keys_PHA+0x170>)
 800cc92:	681b      	ldr	r3, [r3, #0]
 800cc94:	f8a3 6046 	strh.w	r6, [r3, #70]	; 0x46
	confp->pha_cursor_lo = cursor_lo;
 800cc98:	f8a3 8048 	strh.w	r8, [r3, #72]	; 0x48
	confp->pha_window_hi = window_hi;
 800cc9c:	f8a3 5040 	strh.w	r5, [r3, #64]	; 0x40
	confp->pha_window_lo = window_lo;
 800cca0:	f8a3 7042 	strh.w	r7, [r3, #66]	; 0x42
	confp->pha_zoom = zoom;
 800cca4:	f883 a044 	strb.w	sl, [r3, #68]	; 0x44
}
 800cca8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800ccac:	080106c4 	.word	0x080106c4
 800ccb0:	20001800 	.word	0x20001800
 800ccb4:	2000183c 	.word	0x2000183c

0800ccb8 <Clear_All_Data>:

/*******************************************************************************
 Function Name : Clear_All
 Description : clear all data
 *******************************************************************************/
void Clear_All_Data(void) {
 800ccb8:	b510      	push	{r4, lr}
	Display_Info("Clear_All_Data", 0);
 800ccba:	2100      	movs	r1, #0
 800ccbc:	4806      	ldr	r0, [pc, #24]	; (800ccd8 <Clear_All_Data+0x20>)
 800ccbe:	f000 fb22 	bl	800d306 <Display_Info>
	stop = FALSE;				// stop / start sampling
 800ccc2:	4b06      	ldr	r3, [pc, #24]	; (800ccdc <Clear_All_Data+0x24>)
 800ccc4:	2200      	movs	r2, #0
 800ccc6:	701a      	strb	r2, [r3, #0]
	Acq_Clear_All();
 800ccc8:	f001 ff38 	bl	800eb3c <Acq_Clear_All>
	Disp_Clear_All();
 800cccc:	f002 f9ea 	bl	800f0a4 <Disp_Clear_All>
	ADC_Start();
}
 800ccd0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void Clear_All_Data(void) {
	Display_Info("Clear_All_Data", 0);
	stop = FALSE;				// stop / start sampling
	Acq_Clear_All();
	Disp_Clear_All();
	ADC_Start();
 800ccd4:	f000 b8f2 	b.w	800cebc <ADC_Start>
 800ccd8:	080106d0 	.word	0x080106d0
 800ccdc:	2000183c 	.word	0x2000183c

0800cce0 <main>:

/*******************************************************************************
 Function Name : main
 Description :
*******************************************************************************/
void   main(void){
 800cce0:	b513      	push	{r0, r1, r4, lr}
	/*--------------initialize the hardware-----------*/
	NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0xC000);
	NVIC_Configuration();
	/*----------display APP version ----------*/
	// (0,0) lower left
	__Display_Str(0, 112, TXT_COLOR, BKGND_COLOR, msg_app_ver);
 800cce2:	4c46      	ldr	r4, [pc, #280]	; (800cdfc <main+0x11c>)
*******************************************************************************/
void   main(void){
	u16 i, x, y;
	u16 pict_y;

	Display_Info("main", 0);
 800cce4:	2100      	movs	r1, #0
 800cce6:	4846      	ldr	r0, [pc, #280]	; (800ce00 <main+0x120>)
 800cce8:	f000 fb0d 	bl	800d306 <Display_Info>
	/*--------------initialize the hardware-----------*/
	NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0xC000);
 800ccec:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 800ccf0:	f44f 4140 	mov.w	r1, #49152	; 0xc000
 800ccf4:	f002 fd46 	bl	800f784 <NVIC_SetVectorTable>
	NVIC_Configuration();
 800ccf8:	f000 fa1c 	bl	800d134 <NVIC_Configuration>
	/*----------display APP version ----------*/
	// (0,0) lower left
	__Display_Str(0, 112, TXT_COLOR, BKGND_COLOR, msg_app_ver);
 800ccfc:	6823      	ldr	r3, [r4, #0]
 800ccfe:	2000      	movs	r0, #0
 800cd00:	2170      	movs	r1, #112	; 0x70
 800cd02:	9300      	str	r3, [sp, #0]
 800cd04:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800cd08:	4603      	mov	r3, r0
 800cd0a:	f7f7 fa10 	bl	800412e <__Display_Str>
	__Display_Str(0, 96, TXT_COLOR, BKGND_COLOR, msg_chans);
 800cd0e:	6863      	ldr	r3, [r4, #4]
 800cd10:	2000      	movs	r0, #0
 800cd12:	2160      	movs	r1, #96	; 0x60
 800cd14:	9300      	str	r3, [sp, #0]
 800cd16:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800cd1a:	4603      	mov	r3, r0
 800cd1c:	f7f7 fa07 	bl	800412e <__Display_Str>
	__Display_Str(0, 80, RED, BKGND_COLOR, msg_free);
 800cd20:	68a3      	ldr	r3, [r4, #8]
 800cd22:	2000      	movs	r0, #0
 800cd24:	2150      	movs	r1, #80	; 0x50
 800cd26:	221f      	movs	r2, #31
 800cd28:	9300      	str	r3, [sp, #0]
 800cd2a:	4603      	mov	r3, r0
 800cd2c:	f7f7 f9ff 	bl	800412e <__Display_Str>
	__Display_Str(0, 64, RED, BKGND_COLOR, msg_warr);
 800cd30:	68e3      	ldr	r3, [r4, #12]
 800cd32:	2000      	movs	r0, #0
 800cd34:	221f      	movs	r2, #31
 800cd36:	2140      	movs	r1, #64	; 0x40
 800cd38:	9300      	str	r3, [sp, #0]
 800cd3a:	4603      	mov	r3, r0
 800cd3c:	f7f7 f9f7 	bl	800412e <__Display_Str>
	/*--------initialization --------*/
	Read_Config();
 800cd40:	f001 fbda 	bl	800e4f8 <Read_Config>
	if(confp->initialized != INIT_FLAG){	// check for first time run
 800cd44:	4b2f      	ldr	r3, [pc, #188]	; (800ce04 <main+0x124>)
 800cd46:	681b      	ldr	r3, [r3, #0]
 800cd48:	681a      	ldr	r2, [r3, #0]
 800cd4a:	4b2f      	ldr	r3, [pc, #188]	; (800ce08 <main+0x128>)
 800cd4c:	429a      	cmp	r2, r3
 800cd4e:	d001      	beq.n	800cd54 <main+0x74>
		Reset_Config();
 800cd50:	f001 fb58 	bl	800e404 <Reset_Config>
	}
	// initialize based on saved parameters
	Set_Base(0);	// fastest sample speed
	Set_Range(confp->sig_range);
 800cd54:	4c2b      	ldr	r4, [pc, #172]	; (800ce04 <main+0x124>)
	Read_Config();
	if(confp->initialized != INIT_FLAG){	// check for first time run
		Reset_Config();
	}
	// initialize based on saved parameters
	Set_Base(0);	// fastest sample speed
 800cd56:	2000      	movs	r0, #0
 800cd58:	f000 f892 	bl	800ce80 <Set_Base>
	Set_Range(confp->sig_range);
 800cd5c:	6823      	ldr	r3, [r4, #0]
 800cd5e:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800cd60:	f000 f85a 	bl	800ce18 <Set_Range>
	Set_Orientation(confp->orient);
 800cd64:	6823      	ldr	r3, [r4, #0]
 800cd66:	7b58      	ldrb	r0, [r3, #13]
 800cd68:	f000 f9f4 	bl	800d154 <Set_Orientation>
	Delay_MS(4000);
 800cd6c:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 800cd70:	f000 f928 	bl	800cfc4 <Delay_MS>
	Clear_Screen( BKGND_COLOR );
 800cd74:	2000      	movs	r0, #0
 800cd76:	f000 fa0b 	bl	800d190 <Clear_Screen>
	confp->mode = confp->rtn_mode;
 800cd7a:	6823      	ldr	r3, [r4, #0]
 800cd7c:	79da      	ldrb	r2, [r3, #7]
	switch(confp->mode){
 800cd7e:	2a01      	cmp	r2, #1
	Set_Base(0);	// fastest sample speed
	Set_Range(confp->sig_range);
	Set_Orientation(confp->orient);
	Delay_MS(4000);
	Clear_Screen( BKGND_COLOR );
	confp->mode = confp->rtn_mode;
 800cd80:	719a      	strb	r2, [r3, #6]
	switch(confp->mode){
 800cd82:	d008      	beq.n	800cd96 <main+0xb6>
 800cd84:	d302      	bcc.n	800cd8c <main+0xac>
 800cd86:	2a02      	cmp	r2, #2
 800cd88:	d10d      	bne.n	800cda6 <main+0xc6>
 800cd8a:	e009      	b.n	800cda0 <main+0xc0>
		case PHA:
			Init_Spectrum();
 800cd8c:	f002 f890 	bl	800eeb0 <Init_Spectrum>
			Display_Spectrum ();
 800cd90:	f002 f8b2 	bl	800eef8 <Display_Spectrum>
			break;
 800cd94:	e007      	b.n	800cda6 <main+0xc6>
		case RATE:
			Init_Rate();
 800cd96:	f002 f871 	bl	800ee7c <Init_Rate>
			Display_Rate();
 800cd9a:	f001 ffb9 	bl	800ed10 <Display_Rate>
			break;
 800cd9e:	e002      	b.n	800cda6 <main+0xc6>
		case MENU:
			Display_Menu(confp->menu_index);
 800cda0:	8898      	ldrh	r0, [r3, #4]
 800cda2:	f001 fc1d 	bl	800e5e0 <Display_Menu>
			break;
	}
	if (SD_Card_On() == 0){
 800cda6:	f000 f903 	bl	800cfb0 <SD_Card_On>
 800cdaa:	4604      	mov	r4, r0
 800cdac:	b970      	cbnz	r0, 800cdcc <main+0xec>
		if (FAT_Info()){
 800cdae:	f000 fbc7 	bl	800d540 <FAT_Info>
 800cdb2:	b158      	cbz	r0, 800cdcc <main+0xec>
			if (FAT_Info()){
 800cdb4:	f000 fbc4 	bl	800d540 <FAT_Info>
 800cdb8:	b140      	cbz	r0, 800cdcc <main+0xec>
				__Display_Str(0, 0, RED, BKGND_COLOR, SD_Msgs[SDErr]);
 800cdba:	4b14      	ldr	r3, [pc, #80]	; (800ce0c <main+0x12c>)
 800cdbc:	4620      	mov	r0, r4
 800cdbe:	689b      	ldr	r3, [r3, #8]
 800cdc0:	4621      	mov	r1, r4
 800cdc2:	9300      	str	r3, [sp, #0]
 800cdc4:	221f      	movs	r2, #31
 800cdc6:	4623      	mov	r3, r4
 800cdc8:	f7f7 f9b1 	bl	800412e <__Display_Str>
			}
		}
	}
	Beep(BEEP_500Hz, 500);
 800cdcc:	200a      	movs	r0, #10
 800cdce:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800cdd2:	f000 f8c1 	bl	800cf58 <Beep>
	/*--------application main loop --------*/
	ctr_key = KEY_SAMPLE;
 800cdd6:	4b0e      	ldr	r3, [pc, #56]	; (800ce10 <main+0x130>)
 800cdd8:	f04f 020a 	mov.w	r2, #10
 800cddc:	801a      	strh	r2, [r3, #0]
	ctr_refresh = confp->refresh_time * 1000;	// in mS
 800cdde:	4b09      	ldr	r3, [pc, #36]	; (800ce04 <main+0x124>)
 800cde0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800cde4:	681b      	ldr	r3, [r3, #0]
 800cde6:	895b      	ldrh	r3, [r3, #10]
 800cde8:	435a      	muls	r2, r3
 800cdea:	4b0a      	ldr	r3, [pc, #40]	; (800ce14 <main+0x134>)
 800cdec:	b292      	uxth	r2, r2
 800cdee:	801a      	strh	r2, [r3, #0]
	Scan_Samples();	// never returns from this call
}
 800cdf0:	b002      	add	sp, #8
 800cdf2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	}
	Beep(BEEP_500Hz, 500);
	/*--------application main loop --------*/
	ctr_key = KEY_SAMPLE;
	ctr_refresh = confp->refresh_time * 1000;	// in mS
	Scan_Samples();	// never returns from this call
 800cdf6:	f001 bd5f 	b.w	800e8b8 <Scan_Samples>
 800cdfa:	bf00      	nop
 800cdfc:	080101ac 	.word	0x080101ac
 800ce00:	080106df 	.word	0x080106df
 800ce04:	20001800 	.word	0x20001800
 800ce08:	00120915 	.word	0x00120915
 800ce0c:	2000180c 	.word	0x2000180c
 800ce10:	20004b4a 	.word	0x20004b4a
 800ce14:	20004b48 	.word	0x20004b48

0800ce18 <Set_Range>:
	 if attenuator = 1 11 <= range <= 18
 *******************************************************************************/
void Set_Range(fixed range)
{
	TRACE("Set_Range");
	if(range == 0){
 800ce18:	b920      	cbnz	r0, 800ce24 <Set_Range+0xc>
		// Connected To GND
		RANGE_A_LOW();
 800ce1a:	4b15      	ldr	r3, [pc, #84]	; (800ce70 <Set_Range+0x58>)
 800ce1c:	2201      	movs	r2, #1
 800ce1e:	601a      	str	r2, [r3, #0]
		RANGE_B_LOW();
 800ce20:	4a14      	ldr	r2, [pc, #80]	; (800ce74 <Set_Range+0x5c>)
 800ce22:	e006      	b.n	800ce32 <Set_Range+0x1a>
		RANGE_C_LOW();
		RANGE_D_LOW();
	} else if(range <= FIXED_HALF){
 800ce24:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 800ce28:	dc09      	bgt.n	800ce3e <Set_Range+0x26>
		RANGE_A_HIGH();
 800ce2a:	4b13      	ldr	r3, [pc, #76]	; (800ce78 <Set_Range+0x60>)
 800ce2c:	2201      	movs	r2, #1
 800ce2e:	601a      	str	r2, [r3, #0]
		RANGE_B_HIGH();
 800ce30:	4a12      	ldr	r2, [pc, #72]	; (800ce7c <Set_Range+0x64>)
 800ce32:	2120      	movs	r1, #32
 800ce34:	6011      	str	r1, [r2, #0]
		RANGE_C_HIGH();
 800ce36:	3910      	subs	r1, #16
 800ce38:	6011      	str	r1, [r2, #0]
		RANGE_D_HIGH();
 800ce3a:	2202      	movs	r2, #2
 800ce3c:	e015      	b.n	800ce6a <Set_Range+0x52>
	}else if(range <= fixed_from_int(4)){
 800ce3e:	f5b0 6f7a 	cmp.w	r0, #4000	; 0xfa0
 800ce42:	dc07      	bgt.n	800ce54 <Set_Range+0x3c>
		RANGE_A_HIGH();
 800ce44:	4b0c      	ldr	r3, [pc, #48]	; (800ce78 <Set_Range+0x60>)
 800ce46:	2201      	movs	r2, #1
 800ce48:	601a      	str	r2, [r3, #0]
		RANGE_B_HIGH();
 800ce4a:	4b0c      	ldr	r3, [pc, #48]	; (800ce7c <Set_Range+0x64>)
 800ce4c:	321f      	adds	r2, #31
 800ce4e:	601a      	str	r2, [r3, #0]
		RANGE_C_HIGH();
 800ce50:	3a10      	subs	r2, #16
 800ce52:	e007      	b.n	800ce64 <Set_Range+0x4c>
		RANGE_A_LOW();
		RANGE_B_HIGH();
		RANGE_C_HIGH();
		RANGE_D_LOW();
	} else if(range > fixed_from_int(4)){
		RANGE_A_HIGH();
 800ce54:	4b08      	ldr	r3, [pc, #32]	; (800ce78 <Set_Range+0x60>)
 800ce56:	2201      	movs	r2, #1
 800ce58:	601a      	str	r2, [r3, #0]
		RANGE_B_LOW();
 800ce5a:	4b06      	ldr	r3, [pc, #24]	; (800ce74 <Set_Range+0x5c>)
 800ce5c:	321f      	adds	r2, #31
 800ce5e:	601a      	str	r2, [r3, #0]
		RANGE_C_HIGH();
 800ce60:	3a10      	subs	r2, #16
 800ce62:	3b04      	subs	r3, #4
 800ce64:	601a      	str	r2, [r3, #0]
		RANGE_D_LOW();
 800ce66:	4b02      	ldr	r3, [pc, #8]	; (800ce70 <Set_Range+0x58>)
 800ce68:	3a0e      	subs	r2, #14
 800ce6a:	601a      	str	r2, [r3, #0]
 800ce6c:	4770      	bx	lr
 800ce6e:	bf00      	nop
 800ce70:	40010c14 	.word	0x40010c14
 800ce74:	40011014 	.word	0x40011014
 800ce78:	40010c10 	.word	0x40010c10
 800ce7c:	40011010 	.word	0x40011010

0800ce80 <Set_Base>:
 0 <= base <= 21
*******************************************************************************/
void Set_Base(char Base)
{
	TRACE("Set_Base");
	TIM1_PSC = Scan_PSC[Base];
 800ce80:	4b07      	ldr	r3, [pc, #28]	; (800cea0 <Set_Base+0x20>)
 800ce82:	4a08      	ldr	r2, [pc, #32]	; (800cea4 <Set_Base+0x24>)
 800ce84:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
	TIM1_ARR = Scan_ARR[Base];
 800ce88:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 800ce8c:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 0 <= base <= 21
*******************************************************************************/
void Set_Base(char Base)
{
	TRACE("Set_Base");
	TIM1_PSC = Scan_PSC[Base];
 800ce8e:	6011      	str	r1, [r2, #0]
	TIM1_ARR = Scan_ARR[Base];
 800ce90:	3204      	adds	r2, #4
 800ce92:	6013      	str	r3, [r2, #0]
	TIM1_CCR1 = (Scan_ARR[Base] + 1) / 2;
 800ce94:	3301      	adds	r3, #1
 800ce96:	105b      	asrs	r3, r3, #1
 800ce98:	3208      	adds	r2, #8
 800ce9a:	6013      	str	r3, [r2, #0]
}
 800ce9c:	4770      	bx	lr
 800ce9e:	bf00      	nop
 800cea0:	080101bc 	.word	0x080101bc
 800cea4:	40012c28 	.word	0x40012c28

0800cea8 <ADC_Stop>:
Description : start the ADC sampling scan
*******************************************************************************/
void ADC_Stop(void)
{
	TRACE("ADC_Stop");
   	DMA_CCR1 = 0x00000000; // disable DMA1
 800cea8:	4a02      	ldr	r2, [pc, #8]	; (800ceb4 <ADC_Stop+0xc>)
 800ceaa:	2300      	movs	r3, #0
 800ceac:	6013      	str	r3, [r2, #0]
   	scan_mode = IDLE;     // 0=idle, 1=pre-fetch, 2=trig-fetch, 3=post-fetch
 800ceae:	4a02      	ldr	r2, [pc, #8]	; (800ceb8 <ADC_Stop+0x10>)
 800ceb0:	7013      	strb	r3, [r2, #0]
}
 800ceb2:	4770      	bx	lr
 800ceb4:	40020008 	.word	0x40020008
 800ceb8:	20003b30 	.word	0x20003b30

0800cebc <ADC_Start>:
/*******************************************************************************
Function Name : ADC_Start
Description : start the ADC sampling scan
*******************************************************************************/
void ADC_Start(void)
{
 800cebc:	b508      	push	{r3, lr}
	TRACE("ADC_Start");
	ADC_Stop(); // disable DMA1
 800cebe:	f7ff fff3 	bl	800cea8 <ADC_Stop>
	DMA_CPAR1 = ADC1_DR_ADDR; // base address of the peripheral's data register for DMA1
 800cec2:	4a07      	ldr	r2, [pc, #28]	; (800cee0 <ADC_Start+0x24>)
 800cec4:	4b07      	ldr	r3, [pc, #28]	; (800cee4 <ADC_Start+0x28>)
 800cec6:	601a      	str	r2, [r3, #0]
	DMA_CMAR1 = (u32)scan_buffer;
 800cec8:	4a07      	ldr	r2, [pc, #28]	; (800cee8 <ADC_Start+0x2c>)
 800ceca:	3304      	adds	r3, #4
 800cecc:	601a      	str	r2, [r3, #0]
	DMA_CNDTR1 = SCAN_SEGMENT_SZ;
 800cece:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800ced2:	3b08      	subs	r3, #8
 800ced4:	601a      	str	r2, [r3, #0]
	DMA_CCR1 = 0x00003583; // enable DMA1
 800ced6:	f243 5283 	movw	r2, #13699	; 0x3583
 800ceda:	3b04      	subs	r3, #4
 800cedc:	601a      	str	r2, [r3, #0]
}
 800cede:	bd08      	pop	{r3, pc}
 800cee0:	4001244c 	.word	0x4001244c
 800cee4:	40020010 	.word	0x40020010
 800cee8:	20003b34 	.word	0x20003b34

0800ceec <Cal_HW>:
This is used to set the hardware 0, to offset dc bias with opamp
ADC input between ground and analog supply, opamp converts
negative signals to be positive
*******************************************************************************/
void Cal_HW()
{
 800ceec:	b510      	push	{r4, lr}
	u32 tim2;
	u16 adc0, adc1;
	configurations *cp = &configuration;

	TRACE("Cal_HW");
	ADC_Stop();
 800ceee:	f7ff ffdb 	bl	800cea8 <ADC_Stop>
	// Rerun internal ADC calibration
	ADC1_CR2 |=0x00000001;
 800cef2:	4b17      	ldr	r3, [pc, #92]	; (800cf50 <Cal_HW+0x64>)
 800cef4:	681a      	ldr	r2, [r3, #0]
 800cef6:	f042 0201 	orr.w	r2, r2, #1
 800cefa:	601a      	str	r2, [r3, #0]
	ADC2_CR2 |=0x00000001;       //ADON=1 : ADC1 & ADC2 Start
 800cefc:	4a15      	ldr	r2, [pc, #84]	; (800cf54 <Cal_HW+0x68>)
 800cefe:	6811      	ldr	r1, [r2, #0]
 800cf00:	f041 0101 	orr.w	r1, r1, #1
 800cf04:	6011      	str	r1, [r2, #0]
	ADC1_CR2 |=0x00000008;
 800cf06:	681a      	ldr	r2, [r3, #0]
 800cf08:	f042 0208 	orr.w	r2, r2, #8
 800cf0c:	601a      	str	r2, [r3, #0]
	while(ADC1_CR2 & 0x00000008);//ADC1 Initialize calibration register
 800cf0e:	4b10      	ldr	r3, [pc, #64]	; (800cf50 <Cal_HW+0x64>)
 800cf10:	681b      	ldr	r3, [r3, #0]
 800cf12:	f013 0f08 	tst.w	r3, #8
 800cf16:	d1fa      	bne.n	800cf0e <Cal_HW+0x22>
	ADC2_CR2 |=0x00000008;
 800cf18:	4b0e      	ldr	r3, [pc, #56]	; (800cf54 <Cal_HW+0x68>)
 800cf1a:	681a      	ldr	r2, [r3, #0]
 800cf1c:	f042 0208 	orr.w	r2, r2, #8
 800cf20:	601a      	str	r2, [r3, #0]
	while(ADC2_CR2 & 0x00000008);//ADC2 Initialize calibration register
 800cf22:	4b0c      	ldr	r3, [pc, #48]	; (800cf54 <Cal_HW+0x68>)
 800cf24:	681b      	ldr	r3, [r3, #0]
 800cf26:	f013 0f08 	tst.w	r3, #8
 800cf2a:	d1fa      	bne.n	800cf22 <Cal_HW+0x36>
	ADC1_CR2 |=0x00000004;
 800cf2c:	4b08      	ldr	r3, [pc, #32]	; (800cf50 <Cal_HW+0x64>)
 800cf2e:	681a      	ldr	r2, [r3, #0]
 800cf30:	f042 0204 	orr.w	r2, r2, #4
 800cf34:	601a      	str	r2, [r3, #0]
	while(ADC1_CR2 & 0x00000004);//ADC1 calibration
 800cf36:	4b06      	ldr	r3, [pc, #24]	; (800cf50 <Cal_HW+0x64>)
 800cf38:	681b      	ldr	r3, [r3, #0]
 800cf3a:	f013 0f04 	tst.w	r3, #4
 800cf3e:	d1fa      	bne.n	800cf36 <Cal_HW+0x4a>
	ADC2_CR2 |=0x00000004;
 800cf40:	4b04      	ldr	r3, [pc, #16]	; (800cf54 <Cal_HW+0x68>)
 800cf42:	681a      	ldr	r2, [r3, #0]
 800cf44:	f042 0204 	orr.w	r2, r2, #4
 800cf48:	601a      	str	r2, [r3, #0]
	ADC_Start();
	// analog zero is adjusted in sig_acq.c
}
 800cf4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	ADC2_CR2 |=0x00000008;
	while(ADC2_CR2 & 0x00000008);//ADC2 Initialize calibration register
	ADC1_CR2 |=0x00000004;
	while(ADC1_CR2 & 0x00000004);//ADC1 calibration
	ADC2_CR2 |=0x00000004;
	ADC_Start();
 800cf4e:	e7b5      	b.n	800cebc <ADC_Start>
 800cf50:	40012408 	.word	0x40012408
 800cf54:	40012808 	.word	0x40012808

0800cf58 <Beep>:
 * Drive the beeper sounder		Input: index of frequency and duration in mS
 *******************************************************************************/
void Beep(beep_t Freq, u16 Duration)
{
	TRACE("Beep");
	TIM4_PSC = Fout_PSC[Freq];		// Prescaler
 800cf58:	4b0b      	ldr	r3, [pc, #44]	; (800cf88 <Beep+0x30>)
 800cf5a:	4a0c      	ldr	r2, [pc, #48]	; (800cf8c <Beep+0x34>)
 800cf5c:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800cf60:	6d98      	ldr	r0, [r3, #88]	; 0x58
	TIM4_ARR = Fout_ARR[Freq];        //Cycle
 800cf62:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 * Drive the beeper sounder		Input: index of frequency and duration in mS
 *******************************************************************************/
void Beep(beep_t Freq, u16 Duration)
{
	TRACE("Beep");
	TIM4_PSC = Fout_PSC[Freq];		// Prescaler
 800cf66:	6010      	str	r0, [r2, #0]
	TIM4_ARR = Fout_ARR[Freq];        //Cycle
 800cf68:	3204      	adds	r2, #4
 800cf6a:	6013      	str	r3, [r2, #0]
	TIM4_CCR1 = (Fout_ARR[Freq] + 1) / 2;	// 50% duty cycle
 800cf6c:	3301      	adds	r3, #1
 800cf6e:	085b      	lsrs	r3, r3, #1
 800cf70:	3208      	adds	r2, #8
 800cf72:	6013      	str	r3, [r2, #0]
	TIM4_CR1 |=0x0001;//CEN=1, TIMER4 Enable
 800cf74:	4b06      	ldr	r3, [pc, #24]	; (800cf90 <Beep+0x38>)
 800cf76:	681a      	ldr	r2, [r3, #0]
 800cf78:	f042 0201 	orr.w	r2, r2, #1
 800cf7c:	601a      	str	r2, [r3, #0]
	ctr_beep = Duration;
 800cf7e:	4b05      	ldr	r3, [pc, #20]	; (800cf94 <Beep+0x3c>)
 800cf80:	f823 1cf4 	strh.w	r1, [r3, #-244]
}
 800cf84:	4770      	bx	lr
 800cf86:	bf00      	nop
 800cf88:	080101bc 	.word	0x080101bc
 800cf8c:	40000828 	.word	0x40000828
 800cf90:	40000800 	.word	0x40000800
 800cf94:	20004c28 	.word	0x20004c28

0800cf98 <USB_On>:
Return:	 0: USB plug in, 0xff:USB plug out
*******************************************************************************/
char USB_On(void)
{
	TRACE("USB_On");
   	if (GPIOB_IDR & 0x0400)
 800cf98:	4b04      	ldr	r3, [pc, #16]	; (800cfac <USB_On+0x14>)
 800cf9a:	6818      	ldr	r0, [r3, #0]
 800cf9c:	f400 6080 	and.w	r0, r0, #1024	; 0x400
    	return 0;
   	else
      	return 0xff;
}
 800cfa0:	2800      	cmp	r0, #0
 800cfa2:	bf0c      	ite	eq
 800cfa4:	20ff      	moveq	r0, #255	; 0xff
 800cfa6:	2000      	movne	r0, #0
 800cfa8:	4770      	bx	lr
 800cfaa:	bf00      	nop
 800cfac:	40010c08 	.word	0x40010c08

0800cfb0 <SD_Card_On>:
Return:	 0: SD card plug in, 0xff:SD card plug out
*******************************************************************************/
char SD_Card_On(void)
{
	TRACE("SD_Card_On");
   	if (GPIOD_IDR & 0x0400)
 800cfb0:	4b03      	ldr	r3, [pc, #12]	; (800cfc0 <SD_Card_On+0x10>)
 800cfb2:	6818      	ldr	r0, [r3, #0]
 800cfb4:	f410 6080 	ands.w	r0, r0, #1024	; 0x400
     	return 0xff;
   	else
      	return 0; // SD_Card_ON
}
 800cfb8:	bf18      	it	ne
 800cfba:	20ff      	movne	r0, #255	; 0xff
 800cfbc:	4770      	bx	lr
 800cfbe:	bf00      	nop
 800cfc0:	40011408 	.word	0x40011408

0800cfc4 <Delay_MS>:
void Delay_MS(u16 delay)
{
	u32 end;

	TRACE("Delay_MS");
  	end = delay + sys_time;
 800cfc4:	4b04      	ldr	r3, [pc, #16]	; (800cfd8 <Delay_MS+0x14>)
 800cfc6:	f853 3cf0 	ldr.w	r3, [r3, #-240]
 800cfca:	18c3      	adds	r3, r0, r3
  	while (sys_time < end);
 800cfcc:	4a02      	ldr	r2, [pc, #8]	; (800cfd8 <Delay_MS+0x14>)
 800cfce:	f852 2cf0 	ldr.w	r2, [r2, #-240]
 800cfd2:	429a      	cmp	r2, r3
 800cfd4:	d3fa      	bcc.n	800cfcc <Delay_MS+0x8>
}
 800cfd6:	4770      	bx	lr
 800cfd8:	20004c28 	.word	0x20004c28

0800cfdc <Wait_For_Key>:
 wait for keypress
*******************************************************************************/
keycodes Wait_For_Key(void)
{
	TRACE("Wait_For_Key");
}
 800cfdc:	4770      	bx	lr

0800cfde <Get_Scan_Pos>:
   u16 t;
   u8  ss;

	TRACE("Get_Scan_Pos");
   	do {
    	ss = scan_segment;
 800cfde:	4a0a      	ldr	r2, [pc, #40]	; (800d008 <Get_Scan_Pos+0x2a>)
     	t = (ss + 1) * SCAN_SEGMENT_SZ;
     	t = t - DMA_CNDTR1;
 800cfe0:	490a      	ldr	r1, [pc, #40]	; (800d00c <Get_Scan_Pos+0x2e>)
   u16 t;
   u8  ss;

	TRACE("Get_Scan_Pos");
   	do {
    	ss = scan_segment;
 800cfe2:	f812 3cec 	ldrb.w	r3, [r2, #-236]
     	t = (ss + 1) * SCAN_SEGMENT_SZ;
     	t = t - DMA_CNDTR1;
 800cfe6:	6809      	ldr	r1, [r1, #0]
   u8  ss;

	TRACE("Get_Scan_Pos");
   	do {
    	ss = scan_segment;
     	t = (ss + 1) * SCAN_SEGMENT_SZ;
 800cfe8:	1c58      	adds	r0, r3, #1
     	t = t - DMA_CNDTR1;
   	} while (ss != scan_segment);
 800cfea:	f812 2cec 	ldrb.w	r2, [r2, #-236]
   u8  ss;

	TRACE("Get_Scan_Pos");
   	do {
    	ss = scan_segment;
     	t = (ss + 1) * SCAN_SEGMENT_SZ;
 800cfee:	0280      	lsls	r0, r0, #10
     	t = t - DMA_CNDTR1;
 800cff0:	1a40      	subs	r0, r0, r1
   	} while (ss != scan_segment);
 800cff2:	4293      	cmp	r3, r2

	TRACE("Get_Scan_Pos");
   	do {
    	ss = scan_segment;
     	t = (ss + 1) * SCAN_SEGMENT_SZ;
     	t = t - DMA_CNDTR1;
 800cff4:	b280      	uxth	r0, r0
   	} while (ss != scan_segment);
 800cff6:	d1f2      	bne.n	800cfde <Get_Scan_Pos>
   	if (t >= SCAN_BUFFER_SZ) t -= SCAN_BUFFER_SZ;
 800cff8:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 800cffc:	bf24      	itt	cs
 800cffe:	f5a0 6000 	subcs.w	r0, r0, #2048	; 0x800
 800d002:	b280      	uxthcs	r0, r0
   	return t;
}
 800d004:	4770      	bx	lr
 800d006:	bf00      	nop
 800d008:	20004c28 	.word	0x20004c28
 800d00c:	4002000c 	.word	0x4002000c

0800d010 <Update_Battery>:
	u16 bat_avg, bat_now;

	//TRACE("Update_Battery");
	bat_sum = 3200 * 32;
	bat_avg = bat_sum / 32,
	bat_now = *((vu16 *)(ADC1_DR_ADDR + 2));
 800d010:	4b0a      	ldr	r3, [pc, #40]	; (800d03c <Update_Battery+0x2c>)
 800d012:	881a      	ldrh	r2, [r3, #0]
	bat_avg = bat_sum / 32;
	bat_sum = bat_sum + bat_now - bat_avg;
 800d014:	4b0a      	ldr	r3, [pc, #40]	; (800d040 <Update_Battery+0x30>)
	u16 bat_avg, bat_now;

	//TRACE("Update_Battery");
	bat_sum = 3200 * 32;
	bat_avg = bat_sum / 32,
	bat_now = *((vu16 *)(ADC1_DR_ADDR + 2));
 800d016:	b292      	uxth	r2, r2
	bat_avg = bat_sum / 32;
	bat_sum = bat_sum + bat_now - bat_avg;
 800d018:	f502 32c0 	add.w	r2, r2, #98304	; 0x18000
 800d01c:	f502 7260 	add.w	r2, r2, #896	; 0x380
 800d020:	f843 2ce8 	str.w	r2, [r3, #-232]
	if (GPIOB_IDR & 0x0400) pwr_lvl = 4; // USB power
 800d024:	4a07      	ldr	r2, [pc, #28]	; (800d044 <Update_Battery+0x34>)
 800d026:	6812      	ldr	r2, [r2, #0]
 800d028:	f412 6f80 	tst.w	r2, #1024	; 0x400
 800d02c:	d001      	beq.n	800d032 <Update_Battery+0x22>
 800d02e:	2204      	movs	r2, #4
 800d030:	e000      	b.n	800d034 <Update_Battery+0x24>
	else if (bat_avg > 3000) pwr_lvl = 3;
 800d032:	2203      	movs	r2, #3
 800d034:	f803 2ce4 	strb.w	r2, [r3, #-228]
 800d038:	4770      	bx	lr
 800d03a:	bf00      	nop
 800d03c:	4001244e 	.word	0x4001244e
 800d040:	20004c28 	.word	0x20004c28
 800d044:	40010c08 	.word	0x40010c08

0800d048 <Get_Key>:
	static s16 key_down_ctr;
	keycodes key;
	register configurations *cp = &configuration;

	//key = __Get_Key();
	if(cp->orient == VERT){
 800d048:	4b36      	ldr	r3, [pc, #216]	; (800d124 <Get_Key+0xdc>)
		if (!(GPIOD_IDR & KEY_M)) key = KEYCODE_M;
 800d04a:	4937      	ldr	r1, [pc, #220]	; (800d128 <Get_Key+0xe0>)
	static s16 key_down_ctr;
	keycodes key;
	register configurations *cp = &configuration;

	//key = __Get_Key();
	if(cp->orient == VERT){
 800d04c:	7b5b      	ldrb	r3, [r3, #13]
 800d04e:	4a37      	ldr	r2, [pc, #220]	; (800d12c <Get_Key+0xe4>)
 800d050:	2b01      	cmp	r3, #1
		if (!(GPIOD_IDR & KEY_M)) key = KEYCODE_M;
 800d052:	680b      	ldr	r3, [r1, #0]
	static s16 key_down_ctr;
	keycodes key;
	register configurations *cp = &configuration;

	//key = __Get_Key();
	if(cp->orient == VERT){
 800d054:	d11c      	bne.n	800d090 <Get_Key+0x48>
		if (!(GPIOD_IDR & KEY_M)) key = KEYCODE_M;
 800d056:	f413 6f00 	tst.w	r3, #2048	; 0x800
 800d05a:	d038      	beq.n	800d0ce <Get_Key+0x86>
		else if (!(GPIOA_IDR & KEY_B)) key = KEYCODE_B;
 800d05c:	4b34      	ldr	r3, [pc, #208]	; (800d130 <Get_Key+0xe8>)
 800d05e:	6818      	ldr	r0, [r3, #0]
 800d060:	f010 0f08 	tst.w	r0, #8
 800d064:	d031      	beq.n	800d0ca <Get_Key+0x82>
		else if (!(GPIOA_IDR & KEY_PLAY)) key = KEYCODE_PLAY;
 800d066:	6818      	ldr	r0, [r3, #0]
 800d068:	f010 0f10 	tst.w	r0, #16
 800d06c:	d031      	beq.n	800d0d2 <Get_Key+0x8a>
		else if (!(GPIOA_IDR & KEY_UP)) key = KEYCODE_RIGHT;
 800d06e:	6818      	ldr	r0, [r3, #0]
 800d070:	f010 0f40 	tst.w	r0, #64	; 0x40
 800d074:	d035      	beq.n	800d0e2 <Get_Key+0x9a>
		else if (!(GPIOD_IDR & KEY_DOWN)) key = KEYCODE_LEFT;
 800d076:	6809      	ldr	r1, [r1, #0]
 800d078:	f411 7f00 	tst.w	r1, #512	; 0x200
 800d07c:	d02f      	beq.n	800d0de <Get_Key+0x96>
		else if (!(GPIOA_IDR & KEY_LEFT)) key = KEYCODE_UP;
 800d07e:	6819      	ldr	r1, [r3, #0]
 800d080:	f011 0f20 	tst.w	r1, #32
 800d084:	d027      	beq.n	800d0d6 <Get_Key+0x8e>
		else if (!(GPIOA_IDR & KEY_RIGHT)) key = KEYCODE_DOWN;
 800d086:	681b      	ldr	r3, [r3, #0]
 800d088:	f013 0f80 	tst.w	r3, #128	; 0x80
 800d08c:	d025      	beq.n	800d0da <Get_Key+0x92>
 800d08e:	e045      	b.n	800d11c <Get_Key+0xd4>
		else key = KEYCODE_VOID;
	} else {
		if (!(GPIOD_IDR & KEY_M)) key = KEYCODE_M;
 800d090:	f413 6f00 	tst.w	r3, #2048	; 0x800
 800d094:	d01b      	beq.n	800d0ce <Get_Key+0x86>
		else if (!(GPIOA_IDR & KEY_B)) key = KEYCODE_B;
 800d096:	4b26      	ldr	r3, [pc, #152]	; (800d130 <Get_Key+0xe8>)
 800d098:	6818      	ldr	r0, [r3, #0]
 800d09a:	f010 0f08 	tst.w	r0, #8
 800d09e:	d014      	beq.n	800d0ca <Get_Key+0x82>
		else if (!(GPIOA_IDR & KEY_PLAY)) key = KEYCODE_PLAY;
 800d0a0:	6818      	ldr	r0, [r3, #0]
 800d0a2:	f010 0f10 	tst.w	r0, #16
 800d0a6:	d014      	beq.n	800d0d2 <Get_Key+0x8a>
		else if (!(GPIOA_IDR & KEY_UP)) key = KEYCODE_UP;
 800d0a8:	6818      	ldr	r0, [r3, #0]
 800d0aa:	f010 0f40 	tst.w	r0, #64	; 0x40
 800d0ae:	d012      	beq.n	800d0d6 <Get_Key+0x8e>
		else if (!(GPIOD_IDR & KEY_DOWN)) key = KEYCODE_DOWN;
 800d0b0:	6809      	ldr	r1, [r1, #0]
 800d0b2:	f411 7f00 	tst.w	r1, #512	; 0x200
 800d0b6:	d010      	beq.n	800d0da <Get_Key+0x92>
		else if (!(GPIOA_IDR & KEY_LEFT)) key = KEYCODE_LEFT;
 800d0b8:	6819      	ldr	r1, [r3, #0]
 800d0ba:	f011 0f20 	tst.w	r1, #32
 800d0be:	d00e      	beq.n	800d0de <Get_Key+0x96>
		else if (!(GPIOA_IDR & KEY_RIGHT)) key = KEYCODE_RIGHT;
 800d0c0:	681b      	ldr	r3, [r3, #0]
 800d0c2:	f013 0f80 	tst.w	r3, #128	; 0x80
 800d0c6:	d00c      	beq.n	800d0e2 <Get_Key+0x9a>
 800d0c8:	e028      	b.n	800d11c <Get_Key+0xd4>
 800d0ca:	2004      	movs	r0, #4
 800d0cc:	e00a      	b.n	800d0e4 <Get_Key+0x9c>
 800d0ce:	2003      	movs	r0, #3
 800d0d0:	e008      	b.n	800d0e4 <Get_Key+0x9c>
 800d0d2:	2002      	movs	r0, #2
 800d0d4:	e006      	b.n	800d0e4 <Get_Key+0x9c>
 800d0d6:	2005      	movs	r0, #5
 800d0d8:	e004      	b.n	800d0e4 <Get_Key+0x9c>
 800d0da:	2006      	movs	r0, #6
 800d0dc:	e002      	b.n	800d0e4 <Get_Key+0x9c>
 800d0de:	2007      	movs	r0, #7
 800d0e0:	e000      	b.n	800d0e4 <Get_Key+0x9c>
 800d0e2:	2008      	movs	r0, #8
	if(key == KEYCODE_VOID){
		key_prev = key;
		return(key);
	}
	// new key pressed
	if(key != key_prev){
 800d0e4:	f812 2ce3 	ldrb.w	r2, [r2, #-227]
 800d0e8:	4b10      	ldr	r3, [pc, #64]	; (800d12c <Get_Key+0xe4>)
 800d0ea:	4282      	cmp	r2, r0
 800d0ec:	d006      	beq.n	800d0fc <Get_Key+0xb4>
		key_down_ctr = KEY_RELEASE / KEY_SAMPLE;
 800d0ee:	f04f 0228 	mov.w	r2, #40	; 0x28
 800d0f2:	f823 2ce2 	strh.w	r2, [r3, #-226]
		key_prev = key;
 800d0f6:	f803 0ce3 	strb.w	r0, [r3, #-227]
		return(key);
 800d0fa:	4770      	bx	lr
	}
	// do auto repeat
	else {
		if( --key_down_ctr > 0){
 800d0fc:	f833 2ce2 	ldrh.w	r2, [r3, #-226]
 800d100:	3a01      	subs	r2, #1
 800d102:	b292      	uxth	r2, r2
 800d104:	f823 2ce2 	strh.w	r2, [r3, #-226]
 800d108:	b212      	sxth	r2, r2
 800d10a:	2a00      	cmp	r2, #0
 800d10c:	dd01      	ble.n	800d112 <Get_Key+0xca>
 800d10e:	2001      	movs	r0, #1
 800d110:	4770      	bx	lr
			return(KEYCODE_VOID);
		}
		else {
			key_down_ctr = KEY_REPEAT / KEY_SAMPLE;
 800d112:	f04f 0214 	mov.w	r2, #20
 800d116:	f823 2ce2 	strh.w	r2, [r3, #-226]
			return(key);
		}
	}
}
 800d11a:	4770      	bx	lr
		else if (!(GPIOA_IDR & KEY_RIGHT)) key = KEYCODE_RIGHT;
		else key = KEYCODE_VOID;
	}
	// no key pressed
	if(key == KEYCODE_VOID){
		key_prev = key;
 800d11c:	2001      	movs	r0, #1
 800d11e:	f802 0ce3 	strb.w	r0, [r2, #-227]
		return(key);
 800d122:	4770      	bx	lr
 800d124:	20003ac8 	.word	0x20003ac8
 800d128:	40011408 	.word	0x40011408
 800d12c:	20004c28 	.word	0x20004c28
 800d130:	40010808 	.word	0x40010808

0800d134 <NVIC_Configuration>:

/*******************************************************************************
Function Name : NVIC_Configuration
Description : Configure DMA inbterrupt channel priority
*******************************************************************************/
void NVIC_Configuration(void){
 800d134:	b507      	push	{r0, r1, r2, lr}
	TRACE("NVIC_Configuration");
	NVIC_InitType NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = DMAChannel1_IRQChannel;
 800d136:	230b      	movs	r3, #11
 800d138:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 800d13c:	a801      	add	r0, sp, #4
*******************************************************************************/
void NVIC_Configuration(void){
	TRACE("NVIC_Configuration");
	NVIC_InitType NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = DMAChannel1_IRQChannel;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
 800d13e:	3b0a      	subs	r3, #10
 800d140:	f88d 3005 	strb.w	r3, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
 800d144:	f88d 3006 	strb.w	r3, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800d148:	f88d 3007 	strb.w	r3, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 800d14c:	f002 fa80 	bl	800f650 <NVIC_Init>
}
 800d150:	bd0e      	pop	{r1, r2, r3, pc}
 800d152:	bf00      	nop

0800d154 <Set_Orientation>:
Description : Prints text and value
Para :
	orientations orientation
*******************************************************************************/
void Set_Orientation(orientations orient)
{
 800d154:	b510      	push	{r4, lr}
	confp->orient = orient;
 800d156:	4c0d      	ldr	r4, [pc, #52]	; (800d18c <Set_Orientation+0x38>)
 800d158:	6823      	ldr	r3, [r4, #0]
 800d15a:	7358      	strb	r0, [r3, #13]
	__Set_Orientation(confp->orient);
 800d15c:	f7f6 ffef 	bl	800413e <__Set_Orientation>
	if(confp->orient == VERT){
 800d160:	6823      	ldr	r3, [r4, #0]
 800d162:	7b5a      	ldrb	r2, [r3, #13]
 800d164:	2a01      	cmp	r2, #1
 800d166:	d105      	bne.n	800d174 <Set_Orientation+0x20>
		confp->display_width = VERT_WIDTH;
 800d168:	f04f 02f0 	mov.w	r2, #240	; 0xf0
 800d16c:	821a      	strh	r2, [r3, #16]
		confp->display_height = VERT_HEIGHT;
 800d16e:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800d172:	e004      	b.n	800d17e <Set_Orientation+0x2a>
	} else {
		confp->display_width = HORZ_WIDTH;
 800d174:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800d178:	821a      	strh	r2, [r3, #16]
		confp->display_height = HORZ_HEIGHT;
 800d17a:	f04f 02ef 	mov.w	r2, #239	; 0xef
 800d17e:	825a      	strh	r2, [r3, #18]
	}
	confp->graph_width = confp->display_width;
 800d180:	8a1a      	ldrh	r2, [r3, #16]
 800d182:	829a      	strh	r2, [r3, #20]
	confp->graph_height = confp->display_height - (2 * CHAR_HEIGHT);
 800d184:	8a5a      	ldrh	r2, [r3, #18]
 800d186:	3a20      	subs	r2, #32
 800d188:	82da      	strh	r2, [r3, #22]
}
 800d18a:	bd10      	pop	{r4, pc}
 800d18c:	20001800 	.word	0x20001800

0800d190 <Clear_Screen>:
/*******************************************************************************
Function Name : Clear_Screen
Description : clear screen
 *******************************************************************************/
void    Clear_Screen(u16 color)
{
 800d190:	b507      	push	{r0, r1, r2, lr}
	u16 x, y;

	__Fill_Rectangle(0, 0, confp->display_width, confp->display_height, color);
 800d192:	4b05      	ldr	r3, [pc, #20]	; (800d1a8 <Clear_Screen+0x18>)
 800d194:	681b      	ldr	r3, [r3, #0]
 800d196:	8a1a      	ldrh	r2, [r3, #16]
 800d198:	8a5b      	ldrh	r3, [r3, #18]
 800d19a:	9000      	str	r0, [sp, #0]
 800d19c:	2000      	movs	r0, #0
 800d19e:	4601      	mov	r1, r0
 800d1a0:	f7f6 ffc9 	bl	8004136 <__Fill_Rectangle>
}
 800d1a4:	bd0e      	pop	{r1, r2, r3, pc}
 800d1a6:	bf00      	nop
 800d1a8:	20001800 	.word	0x20001800

0800d1ac <Display_Char>:
	x0, y0: lower left corner
	color: color of rectangle
	num: number to be displayed, right justified in fixed field
*******************************************************************************/
void Display_Char(u16 x0, u16 y0, u16 fg, u16 bg, char achar)
{
 800d1ac:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800d1ae:	f89d c018 	ldrb.w	ip, [sp, #24]
	char buf[2];
	buf[0] = achar;
	buf[1] = 0;
	__Display_Str(x0, y0, fg, bg, buf);
 800d1b2:	ac03      	add	r4, sp, #12
	num: number to be displayed, right justified in fixed field
*******************************************************************************/
void Display_Char(u16 x0, u16 y0, u16 fg, u16 bg, char achar)
{
	char buf[2];
	buf[0] = achar;
 800d1b4:	f88d c00c 	strb.w	ip, [sp, #12]
	buf[1] = 0;
 800d1b8:	f04f 0c00 	mov.w	ip, #0
 800d1bc:	f88d c00d 	strb.w	ip, [sp, #13]
	__Display_Str(x0, y0, fg, bg, buf);
 800d1c0:	9400      	str	r4, [sp, #0]
 800d1c2:	f7f6 ffb4 	bl	800412e <__Display_Str>
	return;
}
 800d1c6:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

0800d1c8 <Display_Bool>:
	mode: PRN = replace color, ERASE = remove color but leave other colors,
		 ADD = add color to existing colors
	val: boolean to be displayed as TRUE or FALSE
*******************************************************************************/
void Display_Bool(u16 x0, u16 y0, u16 fg, u16 bg, bool val)
{
 800d1c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d1cc:	b086      	sub	sp, #24
	char buf[10];

	Bool_To_Str(buf, BOOL_CHARS, val);
 800d1ce:	af03      	add	r7, sp, #12
	mode: PRN = replace color, ERASE = remove color but leave other colors,
		 ADD = add color to existing colors
	val: boolean to be displayed as TRUE or FALSE
*******************************************************************************/
void Display_Bool(u16 x0, u16 y0, u16 fg, u16 bg, bool val)
{
 800d1d0:	4606      	mov	r6, r0
 800d1d2:	460d      	mov	r5, r1
 800d1d4:	4614      	mov	r4, r2
 800d1d6:	4698      	mov	r8, r3
	char buf[10];

	Bool_To_Str(buf, BOOL_CHARS, val);
 800d1d8:	4638      	mov	r0, r7
 800d1da:	2105      	movs	r1, #5
 800d1dc:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
 800d1e0:	f001 f906 	bl	800e3f0 <Bool_To_Str>
	__Display_Str(x0, y0, fg, bg, buf);
 800d1e4:	4630      	mov	r0, r6
 800d1e6:	4629      	mov	r1, r5
 800d1e8:	4622      	mov	r2, r4
 800d1ea:	4643      	mov	r3, r8
 800d1ec:	9700      	str	r7, [sp, #0]
 800d1ee:	f7f6 ff9e 	bl	800412e <__Display_Str>
}
 800d1f2:	b006      	add	sp, #24
 800d1f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800d1f8 <Display_Fixed>:
		 ADD = add color to existing colors
	num: number to be displayed, right justified in fixed field
    format fixed at xx,xxx.xxx
*******************************************************************************/
void Display_Fixed(u16 x0, u16 y0, u16 fg, u16 bg, fixed num)
{
 800d1f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d1fc:	b086      	sub	sp, #24

	char  buf[FIXED_DIGITS + 1];

	Fixed_To_Dec_Str(buf, FIXED_DIGITS, num);
 800d1fe:	af03      	add	r7, sp, #12
		 ADD = add color to existing colors
	num: number to be displayed, right justified in fixed field
    format fixed at xx,xxx.xxx
*******************************************************************************/
void Display_Fixed(u16 x0, u16 y0, u16 fg, u16 bg, fixed num)
{
 800d200:	4606      	mov	r6, r0
 800d202:	460d      	mov	r5, r1
 800d204:	4614      	mov	r4, r2
 800d206:	4698      	mov	r8, r3

	char  buf[FIXED_DIGITS + 1];

	Fixed_To_Dec_Str(buf, FIXED_DIGITS, num);
 800d208:	210a      	movs	r1, #10
 800d20a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800d20c:	4638      	mov	r0, r7
 800d20e:	f001 f849 	bl	800e2a4 <Fixed_To_Dec_Str>
	__Display_Str(x0, y0, fg, bg, buf);
 800d212:	4630      	mov	r0, r6
 800d214:	4629      	mov	r1, r5
 800d216:	4622      	mov	r2, r4
 800d218:	4643      	mov	r3, r8
 800d21a:	9700      	str	r7, [sp, #0]
 800d21c:	f7f6 ff87 	bl	800412e <__Display_Str>
}
 800d220:	b006      	add	sp, #24
 800d222:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800d226 <Display_S32>:
	mode: PRN = replace color, ERASE = remove color but leave other colors,
		 ADD = add color to existing colors
	num: number to be displayed, right justified in fixed field
*******************************************************************************/
void Display_S32(u16 x0, u16 y0, u16 fg, u16 bg, int num)
{
 800d226:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d22a:	b086      	sub	sp, #24
	char  buf[S32_DIGITS + 1];

	Signed_To_Dec_Str(buf, S32_DIGITS, num);
 800d22c:	af02      	add	r7, sp, #8
	mode: PRN = replace color, ERASE = remove color but leave other colors,
		 ADD = add color to existing colors
	num: number to be displayed, right justified in fixed field
*******************************************************************************/
void Display_S32(u16 x0, u16 y0, u16 fg, u16 bg, int num)
{
 800d22e:	4606      	mov	r6, r0
 800d230:	460d      	mov	r5, r1
 800d232:	4614      	mov	r4, r2
 800d234:	4698      	mov	r8, r3
	char  buf[S32_DIGITS + 1];

	Signed_To_Dec_Str(buf, S32_DIGITS, num);
 800d236:	210d      	movs	r1, #13
 800d238:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800d23a:	4638      	mov	r0, r7
 800d23c:	f001 f806 	bl	800e24c <Signed_To_Dec_Str>
	__Display_Str(x0, y0, fg, bg, buf);
 800d240:	4630      	mov	r0, r6
 800d242:	4629      	mov	r1, r5
 800d244:	4622      	mov	r2, r4
 800d246:	4643      	mov	r3, r8
 800d248:	9700      	str	r7, [sp, #0]
 800d24a:	f7f6 ff70 	bl	800412e <__Display_Str>
}
 800d24e:	b006      	add	sp, #24
 800d250:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800d254 <Display_S16>:
	mode: PRN = replace color, ERASE = remove color but leave other colors,
		 ADD = add color to existing colors
	num: number to be displayed, right justified in fixed field
*******************************************************************************/
void Display_S16(u16 x0, u16 y0, u16 fg, u16 bg, s16 num)
{
 800d254:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}

	char  buf[S16_DIGITS + 1];

	Signed_To_Dec_Str(buf, S16_DIGITS, num);
 800d258:	af02      	add	r7, sp, #8
	mode: PRN = replace color, ERASE = remove color but leave other colors,
		 ADD = add color to existing colors
	num: number to be displayed, right justified in fixed field
*******************************************************************************/
void Display_S16(u16 x0, u16 y0, u16 fg, u16 bg, s16 num)
{
 800d25a:	4606      	mov	r6, r0
 800d25c:	460d      	mov	r5, r1
 800d25e:	4614      	mov	r4, r2
 800d260:	4698      	mov	r8, r3

	char  buf[S16_DIGITS + 1];

	Signed_To_Dec_Str(buf, S16_DIGITS, num);
 800d262:	2106      	movs	r1, #6
 800d264:	f9bd 2028 	ldrsh.w	r2, [sp, #40]	; 0x28
 800d268:	4638      	mov	r0, r7
 800d26a:	f000 ffef 	bl	800e24c <Signed_To_Dec_Str>
	__Display_Str(x0, y0, fg, bg, buf);
 800d26e:	4630      	mov	r0, r6
 800d270:	4629      	mov	r1, r5
 800d272:	4622      	mov	r2, r4
 800d274:	4643      	mov	r3, r8
 800d276:	9700      	str	r7, [sp, #0]
 800d278:	f7f6 ff59 	bl	800412e <__Display_Str>
}
 800d27c:	e8bd 81ff 	ldmia.w	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, pc}

0800d280 <Display_S8>:
	num: number to be displayed, right justified in fixed field
*******************************************************************************/


void Display_S8(u16 x0, u16 y0, u16 fg, u16 bg, s8 num)
{
 800d280:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	char  buf[S8_DIGITS + 1];

	Signed_To_Dec_Str(buf, S8_DIGITS, num);
 800d284:	af02      	add	r7, sp, #8
	num: number to be displayed, right justified in fixed field
*******************************************************************************/


void Display_S8(u16 x0, u16 y0, u16 fg, u16 bg, s8 num)
{
 800d286:	4606      	mov	r6, r0
 800d288:	460d      	mov	r5, r1
 800d28a:	4614      	mov	r4, r2
 800d28c:	4698      	mov	r8, r3
	char  buf[S8_DIGITS + 1];

	Signed_To_Dec_Str(buf, S8_DIGITS, num);
 800d28e:	2104      	movs	r1, #4
 800d290:	f99d 2028 	ldrsb.w	r2, [sp, #40]	; 0x28
 800d294:	4638      	mov	r0, r7
 800d296:	f000 ffd9 	bl	800e24c <Signed_To_Dec_Str>
	__Display_Str(x0, y0, fg, bg, buf);
 800d29a:	4630      	mov	r0, r6
 800d29c:	4629      	mov	r1, r5
 800d29e:	4622      	mov	r2, r4
 800d2a0:	4643      	mov	r3, r8
 800d2a2:	9700      	str	r7, [sp, #0]
 800d2a4:	f7f6 ff43 	bl	800412e <__Display_Str>
}
 800d2a8:	e8bd 81ff 	ldmia.w	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, pc}

0800d2ac <Display_U32>:
	mode: PRN = replace color, ERASE = remove color but leave other colors,
		 ADD = add color to existing colors
	num: number to be displayed, right justified in fixed field
*******************************************************************************/
void Display_U32(u16 x0, u16 y0, u16 fg, u16 bg, u32 num)
{
 800d2ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d2b0:	b086      	sub	sp, #24
	char  buf[S32_DIGITS + 1];
	char i, n;

	Unsigned_To_Dec_Str(buf, S32_DIGITS, num);
 800d2b2:	af02      	add	r7, sp, #8
	mode: PRN = replace color, ERASE = remove color but leave other colors,
		 ADD = add color to existing colors
	num: number to be displayed, right justified in fixed field
*******************************************************************************/
void Display_U32(u16 x0, u16 y0, u16 fg, u16 bg, u32 num)
{
 800d2b4:	4606      	mov	r6, r0
 800d2b6:	460d      	mov	r5, r1
 800d2b8:	4614      	mov	r4, r2
 800d2ba:	4698      	mov	r8, r3
	char  buf[S32_DIGITS + 1];
	char i, n;

	Unsigned_To_Dec_Str(buf, S32_DIGITS, num);
 800d2bc:	210d      	movs	r1, #13
 800d2be:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800d2c0:	4638      	mov	r0, r7
 800d2c2:	f000 ffa3 	bl	800e20c <Unsigned_To_Dec_Str>
	__Display_Str(x0, y0, fg, bg, buf);
 800d2c6:	4630      	mov	r0, r6
 800d2c8:	4629      	mov	r1, r5
 800d2ca:	4622      	mov	r2, r4
 800d2cc:	4643      	mov	r3, r8
 800d2ce:	9700      	str	r7, [sp, #0]
 800d2d0:	f7f6 ff2d 	bl	800412e <__Display_Str>
}
 800d2d4:	b006      	add	sp, #24
 800d2d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800d2da <Display_U16>:
	x0, y0: lower left corner
	color: color of rectangle
	num: number to be displayed, right justified in fixed field
*******************************************************************************/
void Display_U16(u16 x0, u16 y0, u16 fg, u16 bg, u16 num)
{
 800d2da:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	char  buf[S16_DIGITS + 1];

	Unsigned_To_Dec_Str(buf, S16_DIGITS, num);
 800d2de:	af02      	add	r7, sp, #8
	x0, y0: lower left corner
	color: color of rectangle
	num: number to be displayed, right justified in fixed field
*******************************************************************************/
void Display_U16(u16 x0, u16 y0, u16 fg, u16 bg, u16 num)
{
 800d2e0:	4606      	mov	r6, r0
 800d2e2:	460d      	mov	r5, r1
 800d2e4:	4614      	mov	r4, r2
 800d2e6:	4698      	mov	r8, r3
	char  buf[S16_DIGITS + 1];

	Unsigned_To_Dec_Str(buf, S16_DIGITS, num);
 800d2e8:	2106      	movs	r1, #6
 800d2ea:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
 800d2ee:	4638      	mov	r0, r7
 800d2f0:	f000 ff8c 	bl	800e20c <Unsigned_To_Dec_Str>
	__Display_Str(x0, y0, fg, bg, buf);
 800d2f4:	4630      	mov	r0, r6
 800d2f6:	4629      	mov	r1, r5
 800d2f8:	4622      	mov	r2, r4
 800d2fa:	4643      	mov	r3, r8
 800d2fc:	9700      	str	r7, [sp, #0]
 800d2fe:	f7f6 ff16 	bl	800412e <__Display_Str>
}
 800d302:	e8bd 81ff 	ldmia.w	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, pc}

0800d306 <Display_Info>:
{
	char  buf[HEX_DIGITS + 1], n;
	bool neg = FALSE;
	u16 x0 = 0;

	if(confp->debug_level < 1)
 800d306:	4b28      	ldr	r3, [pc, #160]	; (800d3a8 <Display_Info+0xa2>)
	Num: long number to be printed
*******************************************************************************/
static s16 msgy = 240-16;
static u16 ln = 0;
void Display_Info(char *Pre, u32 Num)
{
 800d308:	b5f0      	push	{r4, r5, r6, r7, lr}
	char  buf[HEX_DIGITS + 1], n;
	bool neg = FALSE;
	u16 x0 = 0;

	if(confp->debug_level < 1)
 800d30a:	681b      	ldr	r3, [r3, #0]
	Num: long number to be printed
*******************************************************************************/
static s16 msgy = 240-16;
static u16 ln = 0;
void Display_Info(char *Pre, u32 Num)
{
 800d30c:	b087      	sub	sp, #28
	char  buf[HEX_DIGITS + 1], n;
	bool neg = FALSE;
	u16 x0 = 0;

	if(confp->debug_level < 1)
 800d30e:	f9b3 2064 	ldrsh.w	r2, [r3, #100]	; 0x64
	Num: long number to be printed
*******************************************************************************/
static s16 msgy = 240-16;
static u16 ln = 0;
void Display_Info(char *Pre, u32 Num)
{
 800d312:	4604      	mov	r4, r0
	char  buf[HEX_DIGITS + 1], n;
	bool neg = FALSE;
	u16 x0 = 0;

	if(confp->debug_level < 1)
 800d314:	2a00      	cmp	r2, #0
	Num: long number to be printed
*******************************************************************************/
static s16 msgy = 240-16;
static u16 ln = 0;
void Display_Info(char *Pre, u32 Num)
{
 800d316:	460e      	mov	r6, r1
	char  buf[HEX_DIGITS + 1], n;
	bool neg = FALSE;
	u16 x0 = 0;

	if(confp->debug_level < 1)
 800d318:	dd43      	ble.n	800d3a2 <Display_Info+0x9c>
		return;
	__Fill_Rectangle(0, msgy, confp->display_width, 16, BKGND_COLOR);
 800d31a:	4f24      	ldr	r7, [pc, #144]	; (800d3ac <Display_Info+0xa6>)
 800d31c:	2500      	movs	r5, #0
 800d31e:	8a1a      	ldrh	r2, [r3, #16]
 800d320:	8839      	ldrh	r1, [r7, #0]
 800d322:	4628      	mov	r0, r5
 800d324:	2310      	movs	r3, #16
 800d326:	9500      	str	r5, [sp, #0]
 800d328:	f7f6 ff05 	bl	8004136 <__Fill_Rectangle>
	Display_U16(x0, msgy, TXT_COLOR, BKGND_COLOR, ln++);
 800d32c:	4a20      	ldr	r2, [pc, #128]	; (800d3b0 <Display_Info+0xaa>)
 800d32e:	8839      	ldrh	r1, [r7, #0]
 800d330:	8813      	ldrh	r3, [r2, #0]
 800d332:	1c58      	adds	r0, r3, #1
 800d334:	8010      	strh	r0, [r2, #0]
 800d336:	9300      	str	r3, [sp, #0]
 800d338:	4628      	mov	r0, r5
 800d33a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800d33e:	462b      	mov	r3, r5
 800d340:	f7ff ffcb 	bl	800d2da <Display_U16>
	if (Pre) {
 800d344:	b19c      	cbz	r4, 800d36e <Display_Info+0x68>
 800d346:	4625      	mov	r5, r4
 800d348:	e000      	b.n	800d34c <Display_Info+0x46>
		char *p = Pre;
		while (*p) p++;
 800d34a:	3501      	adds	r5, #1
 800d34c:	782b      	ldrb	r3, [r5, #0]
 800d34e:	2b00      	cmp	r3, #0
 800d350:	d1fb      	bne.n	800d34a <Display_Info+0x44>
		x0 += 64;
		__Display_Str(x0, msgy, TXT_COLOR, BKGND_COLOR, (unsigned char const *)Pre);
 800d352:	4a16      	ldr	r2, [pc, #88]	; (800d3ac <Display_Info+0xa6>)
 800d354:	2040      	movs	r0, #64	; 0x40
 800d356:	8811      	ldrh	r1, [r2, #0]
 800d358:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800d35c:	9400      	str	r4, [sp, #0]
 800d35e:	f7f6 fee6 	bl	800412e <__Display_Str>
		x0 += (p - Pre) * 8 + 8;
 800d362:	f1c4 0401 	rsb	r4, r4, #1
 800d366:	1964      	adds	r4, r4, r5
 800d368:	00e4      	lsls	r4, r4, #3
 800d36a:	3440      	adds	r4, #64	; 0x40
 800d36c:	b2a4      	uxth	r4, r4
	}
	Unsigned_To_Hex_Str(buf, HEX_DIGITS, Num);
	buf[HEX_DIGITS] = 0;
	__Display_Str(x0, msgy, TXT_COLOR, BKGND_COLOR, buf);
 800d36e:	4d0f      	ldr	r5, [pc, #60]	; (800d3ac <Display_Info+0xa6>)
		while (*p) p++;
		x0 += 64;
		__Display_Str(x0, msgy, TXT_COLOR, BKGND_COLOR, (unsigned char const *)Pre);
		x0 += (p - Pre) * 8 + 8;
	}
	Unsigned_To_Hex_Str(buf, HEX_DIGITS, Num);
 800d370:	af03      	add	r7, sp, #12
 800d372:	2108      	movs	r1, #8
 800d374:	4632      	mov	r2, r6
 800d376:	4638      	mov	r0, r7
 800d378:	f000 ff2c 	bl	800e1d4 <Unsigned_To_Hex_Str>
	buf[HEX_DIGITS] = 0;
 800d37c:	2300      	movs	r3, #0
	__Display_Str(x0, msgy, TXT_COLOR, BKGND_COLOR, buf);
 800d37e:	8829      	ldrh	r1, [r5, #0]
 800d380:	4620      	mov	r0, r4
 800d382:	f64f 72ff 	movw	r2, #65535	; 0xffff
		x0 += 64;
		__Display_Str(x0, msgy, TXT_COLOR, BKGND_COLOR, (unsigned char const *)Pre);
		x0 += (p - Pre) * 8 + 8;
	}
	Unsigned_To_Hex_Str(buf, HEX_DIGITS, Num);
	buf[HEX_DIGITS] = 0;
 800d386:	f88d 3014 	strb.w	r3, [sp, #20]
	__Display_Str(x0, msgy, TXT_COLOR, BKGND_COLOR, buf);
 800d38a:	9700      	str	r7, [sp, #0]
 800d38c:	f7f6 fecf 	bl	800412e <__Display_Str>
	msgy -= 16;
 800d390:	882b      	ldrh	r3, [r5, #0]
 800d392:	3b10      	subs	r3, #16
 800d394:	b29b      	uxth	r3, r3
	if(msgy < 0) msgy = 240 - 16;
 800d396:	f413 4f00 	tst.w	r3, #32768	; 0x8000
		x0 += (p - Pre) * 8 + 8;
	}
	Unsigned_To_Hex_Str(buf, HEX_DIGITS, Num);
	buf[HEX_DIGITS] = 0;
	__Display_Str(x0, msgy, TXT_COLOR, BKGND_COLOR, buf);
	msgy -= 16;
 800d39a:	802b      	strh	r3, [r5, #0]
	if(msgy < 0) msgy = 240 - 16;
 800d39c:	bf1c      	itt	ne
 800d39e:	23e0      	movne	r3, #224	; 0xe0
 800d3a0:	802b      	strhne	r3, [r5, #0]
}
 800d3a2:	b007      	add	sp, #28
 800d3a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d3a6:	bf00      	nop
 800d3a8:	20001800 	.word	0x20001800
 800d3ac:	20001808 	.word	0x20001808
 800d3b0:	20004b50 	.word	0x20004b50

0800d3b4 <Display_U8>:

	num: number to be displayed, right justified in fixed field
*******************************************************************************/

void Display_U8(u16 x0, u16 y0, u16 fg, u16 bg, u8 num)
{
 800d3b4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	char  buf[U8_DIGITS + 1];

	Unsigned_To_Dec_Str(buf, U8_DIGITS, num);
 800d3b8:	af03      	add	r7, sp, #12

	num: number to be displayed, right justified in fixed field
*******************************************************************************/

void Display_U8(u16 x0, u16 y0, u16 fg, u16 bg, u8 num)
{
 800d3ba:	4606      	mov	r6, r0
 800d3bc:	460d      	mov	r5, r1
 800d3be:	4614      	mov	r4, r2
 800d3c0:	4698      	mov	r8, r3
	char  buf[U8_DIGITS + 1];

	Unsigned_To_Dec_Str(buf, U8_DIGITS, num);
 800d3c2:	2103      	movs	r1, #3
 800d3c4:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
 800d3c8:	4638      	mov	r0, r7
 800d3ca:	f000 ff1f 	bl	800e20c <Unsigned_To_Dec_Str>
	__Display_Str(x0, y0, fg, bg, buf);
 800d3ce:	4630      	mov	r0, r6
 800d3d0:	4629      	mov	r1, r5
 800d3d2:	4622      	mov	r2, r4
 800d3d4:	4643      	mov	r3, r8
 800d3d6:	9700      	str	r7, [sp, #0]
 800d3d8:	f7f6 fea9 	bl	800412e <__Display_Str>
}
 800d3dc:	e8bd 81ff 	ldmia.w	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, pc}

0800d3e0 <Draw_Seg>:
*******************************************************************************/
void Draw_Seg(u16 x, u16 y1, u16 y2, u16 Color)
{
	u16  j;

	if (y1 > y2)
 800d3e0:	4291      	cmp	r1, r2
Function Name : Draw_SEG
Description : draw a vertical segment
Para : x is the horizontal coordinate, |y1-y2| is the segment heigth, Color
*******************************************************************************/
void Draw_Seg(u16 x, u16 y1, u16 y2, u16 Color)
{
 800d3e2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d3e4:	4606      	mov	r6, r0
 800d3e6:	460c      	mov	r4, r1
 800d3e8:	4615      	mov	r5, r2
 800d3ea:	461f      	mov	r7, r3
	u16  j;

	if (y1 > y2)
 800d3ec:	d90a      	bls.n	800d404 <Draw_Seg+0x24>
 800d3ee:	e006      	b.n	800d3fe <Draw_Seg+0x1e>
	{
		for (j = y2; j <= y1; j++) {
			__Set_Color (x, j, Color);
 800d3f0:	4629      	mov	r1, r5
 800d3f2:	4630      	mov	r0, r6
 800d3f4:	463a      	mov	r2, r7
 800d3f6:	f7f6 fe96 	bl	8004126 <__Set_Color>
{
	u16  j;

	if (y1 > y2)
	{
		for (j = y2; j <= y1; j++) {
 800d3fa:	3501      	adds	r5, #1
 800d3fc:	b2ad      	uxth	r5, r5
 800d3fe:	42a5      	cmp	r5, r4
 800d400:	d9f6      	bls.n	800d3f0 <Draw_Seg+0x10>
 800d402:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			__Set_Color (x, j, Color);
		}
	}
	else {
		for (j = y1; j <= y2; j++) {
			__Set_Color (x, j, Color);
 800d404:	4621      	mov	r1, r4
		for (j = y2; j <= y1; j++) {
			__Set_Color (x, j, Color);
		}
	}
	else {
		for (j = y1; j <= y2; j++) {
 800d406:	3401      	adds	r4, #1
			__Set_Color (x, j, Color);
 800d408:	4630      	mov	r0, r6
 800d40a:	463a      	mov	r2, r7
		for (j = y2; j <= y1; j++) {
			__Set_Color (x, j, Color);
		}
	}
	else {
		for (j = y1; j <= y2; j++) {
 800d40c:	b2a4      	uxth	r4, r4
			__Set_Color (x, j, Color);
 800d40e:	f7f6 fe8a 	bl	8004126 <__Set_Color>
		for (j = y2; j <= y1; j++) {
			__Set_Color (x, j, Color);
		}
	}
	else {
		for (j = y1; j <= y2; j++) {
 800d412:	42ac      	cmp	r4, r5
 800d414:	d9f6      	bls.n	800d404 <Draw_Seg+0x24>
 800d416:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800d418 <Draw_Dot>:
/***************************************************************************
Function Name : Draw_Dot
Description : draw a dot
 *****************************************************************************/
void Draw_Dot(u16 x, u16 y, u16 color)
{
 800d418:	b570      	push	{r4, r5, r6, lr}
 800d41a:	460d      	mov	r5, r1
 800d41c:	4606      	mov	r6, r0
 800d41e:	4614      	mov	r4, r2
	__Set_Color (x,y,color);
 800d420:	f7f6 fe81 	bl	8004126 <__Set_Color>
	__Set_Color (x,y+1,color);
 800d424:	1c69      	adds	r1, r5, #1
 800d426:	4630      	mov	r0, r6
 800d428:	4622      	mov	r2, r4
 800d42a:	b289      	uxth	r1, r1
 800d42c:	f7f6 fe7b 	bl	8004126 <__Set_Color>
	__Set_Color (x,y-1,color);
 800d430:	1e69      	subs	r1, r5, #1
 800d432:	4630      	mov	r0, r6
 800d434:	4622      	mov	r2, r4
 800d436:	b289      	uxth	r1, r1
 800d438:	f7f6 fe75 	bl	8004126 <__Set_Color>
	__Set_Color (x+1,y,color);
 800d43c:	1c70      	adds	r0, r6, #1
 800d43e:	4629      	mov	r1, r5
 800d440:	4622      	mov	r2, r4
 800d442:	b280      	uxth	r0, r0
 800d444:	f7f6 fe6f 	bl	8004126 <__Set_Color>
	__Set_Color (x-1,y,color);
 800d448:	1e70      	subs	r0, r6, #1
 800d44a:	b280      	uxth	r0, r0
 800d44c:	4629      	mov	r1, r5
 800d44e:	4622      	mov	r2, r4
}
 800d450:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
{
	__Set_Color (x,y,color);
	__Set_Color (x,y+1,color);
	__Set_Color (x,y-1,color);
	__Set_Color (x+1,y,color);
	__Set_Color (x-1,y,color);
 800d454:	f7f6 be67 	b.w	8004126 <__Set_Color>

0800d458 <NextClust>:
/*******************************************************************************
Function Name : NextClust
Description : Point CurFileAddr to next FAT cluster in current file
*******************************************************************************/
u8 NextClust(void)
{
 800d458:	b538      	push	{r3, r4, r5, lr}
	u16 i;	// index in block for current fat entry
	u32 addr;	// address of fat entry in bytes
	u32 tmp;

	Display_Info("NextClust()", 0);
 800d45a:	2100      	movs	r1, #0
 800d45c:	4832      	ldr	r0, [pc, #200]	; (800d528 <NextClust+0xd0>)
 800d45e:	f7ff ff52 	bl	800d306 <Display_Info>
	addr = FAT_Addr;
 800d462:	4b32      	ldr	r3, [pc, #200]	; (800d52c <NextClust+0xd4>)
	if (FAT16) {
 800d464:	7919      	ldrb	r1, [r3, #4]
	u16 i;	// index in block for current fat entry
	u32 addr;	// address of fat entry in bytes
	u32 tmp;

	Display_Info("NextClust()", 0);
	addr = FAT_Addr;
 800d466:	681a      	ldr	r2, [r3, #0]
	if (FAT16) {
 800d468:	b119      	cbz	r1, 800d472 <NextClust+0x1a>
		addr += CurCluster * 2;
 800d46a:	689d      	ldr	r5, [r3, #8]
 800d46c:	eb02 0545 	add.w	r5, r2, r5, lsl #1
 800d470:	e002      	b.n	800d478 <NextClust+0x20>
	} else {
		addr += CurCluster * 4;
 800d472:	689d      	ldr	r5, [r3, #8]
 800d474:	eb02 0585 	add.w	r5, r2, r5, lsl #2
	}
	i = (addr & 0x1FF);
	addr = (addr & ~(0x1FF));
	if (__MSD_ReadBlock(F_Buff, addr, 512))
 800d478:	4c2c      	ldr	r4, [pc, #176]	; (800d52c <NextClust+0xd4>)
 800d47a:	f425 71fe 	bic.w	r1, r5, #508	; 0x1fc
 800d47e:	f104 000c 	add.w	r0, r4, #12
 800d482:	f021 0103 	bic.w	r1, r1, #3
 800d486:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d48a:	f7f6 fe47 	bl	800411c <__MSD_ReadBlock>
 800d48e:	2800      	cmp	r0, #0
 800d490:	d147      	bne.n	800d522 <NextClust+0xca>
	if (FAT16) {
		addr += CurCluster * 2;
	} else {
		addr += CurCluster * 4;
	}
	i = (addr & 0x1FF);
 800d492:	05ed      	lsls	r5, r5, #23
	addr = (addr & ~(0x1FF));
	if (__MSD_ReadBlock(F_Buff, addr, 512))
		return 0xff;
	if (FAT16) {
 800d494:	7923      	ldrb	r3, [r4, #4]
	if (FAT16) {
		addr += CurCluster * 2;
	} else {
		addr += CurCluster * 4;
	}
	i = (addr & 0x1FF);
 800d496:	0ded      	lsrs	r5, r5, #23
 800d498:	192d      	adds	r5, r5, r4
	addr = (addr & ~(0x1FF));
	if (__MSD_ReadBlock(F_Buff, addr, 512))
		return 0xff;
	if (FAT16) {
 800d49a:	b1ab      	cbz	r3, 800d4c8 <NextClust+0x70>
		tmp = (F_Buff[i + 1] << 8) + F_Buff[i];
 800d49c:	7b6a      	ldrb	r2, [r5, #13]
 800d49e:	7b2b      	ldrb	r3, [r5, #12]
 800d4a0:	eb03 2302 	add.w	r3, r3, r2, lsl #8
		if (tmp >= 0xfff0)
 800d4a4:	f64f 72ef 	movw	r2, #65519	; 0xffef
 800d4a8:	4293      	cmp	r3, r2
 800d4aa:	d83a      	bhi.n	800d522 <NextClust+0xca>
			return 0xff;
		CurCluster = tmp;	// do not trash existing values on reaching EOC
		CurFileAddr = Root_Addr + DirBlkNum * 512 + (CurCluster - 2) * SecPerClus * SectorSize;
 800d4ac:	f8b4 1210 	ldrh.w	r1, [r4, #528]	; 0x210
 800d4b0:	f8d4 2214 	ldr.w	r2, [r4, #532]	; 0x214
 800d4b4:	f8b4 021a 	ldrh.w	r0, [r4, #538]	; 0x21a
 800d4b8:	eb02 2241 	add.w	r2, r2, r1, lsl #9
 800d4bc:	f8b4 1218 	ldrh.w	r1, [r4, #536]	; 0x218
		return 0xff;
	if (FAT16) {
		tmp = (F_Buff[i + 1] << 8) + F_Buff[i];
		if (tmp >= 0xfff0)
			return 0xff;
		CurCluster = tmp;	// do not trash existing values on reaching EOC
 800d4c0:	60a3      	str	r3, [r4, #8]
		CurFileAddr = Root_Addr + DirBlkNum * 512 + (CurCluster - 2) * SecPerClus * SectorSize;
 800d4c2:	4341      	muls	r1, r0
 800d4c4:	3b02      	subs	r3, #2
 800d4c6:	e017      	b.n	800d4f8 <NextClust+0xa0>
	} else {
		tmp = ((F_Buff[i + 3] & 0x0f) << 24) +
 800d4c8:	7b6a      	ldrb	r2, [r5, #13]
 800d4ca:	7bab      	ldrb	r3, [r5, #14]
 800d4cc:	0212      	lsls	r2, r2, #8
 800d4ce:	eb02 4203 	add.w	r2, r2, r3, lsl #16
 800d4d2:	7b29      	ldrb	r1, [r5, #12]
 800d4d4:	7beb      	ldrb	r3, [r5, #15]
 800d4d6:	1852      	adds	r2, r2, r1
 800d4d8:	f003 030f 	and.w	r3, r3, #15
 800d4dc:	eb02 6303 	add.w	r3, r2, r3, lsl #24
			(F_Buff[i + 2] << 16) +
			(F_Buff[i + 1] << 8) +
			F_Buff[i];
		if (tmp >= 0x0ffffff0)
 800d4e0:	4a13      	ldr	r2, [pc, #76]	; (800d530 <NextClust+0xd8>)
 800d4e2:	4293      	cmp	r3, r2
 800d4e4:	d81d      	bhi.n	800d522 <NextClust+0xca>
			return 0xff;
		CurCluster = tmp;	// do not trash existing values on reaching EOC
		CurFileAddr = Root_Addr + (CurCluster - 2) * SecPerClus * SectorSize;
 800d4e6:	f8b4 2218 	ldrh.w	r2, [r4, #536]	; 0x218
 800d4ea:	f8b4 121a 	ldrh.w	r1, [r4, #538]	; 0x21a
			(F_Buff[i + 2] << 16) +
			(F_Buff[i + 1] << 8) +
			F_Buff[i];
		if (tmp >= 0x0ffffff0)
			return 0xff;
		CurCluster = tmp;	// do not trash existing values on reaching EOC
 800d4ee:	60a3      	str	r3, [r4, #8]
		CurFileAddr = Root_Addr + (CurCluster - 2) * SecPerClus * SectorSize;
 800d4f0:	4351      	muls	r1, r2
 800d4f2:	f8d4 2214 	ldr.w	r2, [r4, #532]	; 0x214
 800d4f6:	3b02      	subs	r3, #2
 800d4f8:	fb03 2301 	mla	r3, r3, r1, r2
 800d4fc:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
	}
 	Display_Info("NextClust() CurFileAddr", CurFileAddr);
 800d500:	4c0a      	ldr	r4, [pc, #40]	; (800d52c <NextClust+0xd4>)
 800d502:	480c      	ldr	r0, [pc, #48]	; (800d534 <NextClust+0xdc>)
 800d504:	f8d4 120c 	ldr.w	r1, [r4, #524]	; 0x20c
 800d508:	f7ff fefd 	bl	800d306 <Display_Info>
	Display_Info("NextClust() Root_Addr", Root_Addr);
 800d50c:	480a      	ldr	r0, [pc, #40]	; (800d538 <NextClust+0xe0>)
 800d50e:	f8d4 1214 	ldr.w	r1, [r4, #532]	; 0x214
 800d512:	f7ff fef8 	bl	800d306 <Display_Info>
	Display_Info("NextClust() CurCluster", CurCluster);
 800d516:	4809      	ldr	r0, [pc, #36]	; (800d53c <NextClust+0xe4>)
 800d518:	68a1      	ldr	r1, [r4, #8]
 800d51a:	f7ff fef4 	bl	800d306 <Display_Info>
 800d51e:	2000      	movs	r0, #0
	return 0;
 800d520:	bd38      	pop	{r3, r4, r5, pc}
 800d522:	20ff      	movs	r0, #255	; 0xff
}
 800d524:	bd38      	pop	{r3, r4, r5, pc}
 800d526:	bf00      	nop
 800d528:	0801074c 	.word	0x0801074c
 800d52c:	20004b54 	.word	0x20004b54
 800d530:	0fffffef 	.word	0x0fffffef
 800d534:	08010758 	.word	0x08010758
 800d538:	08010770 	.word	0x08010770
 800d53c:	08010786 	.word	0x08010786

0800d540 <FAT_Info>:
/*******************************************************************************
Function Name : FAT_Info
Description : read the basic infomation of the SD card
*******************************************************************************/
u8 FAT_Info(void)
{
 800d540:	b570      	push	{r4, r5, r6, lr}
	u16 DIR_Size;		// max number directory entries
	u16 i;

	Display_Info("FAT_Info()", 0);
	// read partition table
	if (__MSD_ReadBlock(F_Buff, 0, 512)){
 800d542:	4c58      	ldr	r4, [pc, #352]	; (800d6a4 <FAT_Info+0x164>)
	u16 RsvdSecCnt;
	u16 FAT_Size;		// FAT size in sectors
	u16 DIR_Size;		// max number directory entries
	u16 i;

	Display_Info("FAT_Info()", 0);
 800d544:	4858      	ldr	r0, [pc, #352]	; (800d6a8 <FAT_Info+0x168>)
 800d546:	2100      	movs	r1, #0
 800d548:	f7ff fedd 	bl	800d306 <Display_Info>
	// read partition table
	if (__MSD_ReadBlock(F_Buff, 0, 512)){
 800d54c:	f104 000c 	add.w	r0, r4, #12
 800d550:	2100      	movs	r1, #0
 800d552:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d556:	f7f6 fde1 	bl	800411c <__MSD_ReadBlock>
 800d55a:	b110      	cbz	r0, 800d562 <FAT_Info+0x22>
		Display_Info("FAT_Info() read partition failed", 0);
 800d55c:	4853      	ldr	r0, [pc, #332]	; (800d6ac <FAT_Info+0x16c>)
 800d55e:	2100      	movs	r1, #0
 800d560:	e018      	b.n	800d594 <FAT_Info+0x54>
		return 0xFF; // Disk error!
	}
	// find first block in first partition
	i = MBR_PART_START + PART_LBA;
	DiskStart = (F_Buff[i + 3] << 24) + (F_Buff[i + 2] << 16)
 800d562:	f894 51d4 	ldrb.w	r5, [r4, #468]	; 0x1d4
 800d566:	f894 31d5 	ldrb.w	r3, [r4, #469]	; 0x1d5
 800d56a:	042d      	lsls	r5, r5, #16
 800d56c:	eb05 6503 	add.w	r5, r5, r3, lsl #24
 800d570:	f894 31d2 	ldrb.w	r3, [r4, #466]	; 0x1d2
		+ (F_Buff[i + 1] << 8) + F_Buff[i];
	DiskStart = DiskStart << 9;	// convert to bytes
	// read the boot sector
	if (__MSD_ReadBlock(F_Buff, DiskStart, 512)){
 800d574:	f104 000c 	add.w	r0, r4, #12
		Display_Info("FAT_Info() read partition failed", 0);
		return 0xFF; // Disk error!
	}
	// find first block in first partition
	i = MBR_PART_START + PART_LBA;
	DiskStart = (F_Buff[i + 3] << 24) + (F_Buff[i + 2] << 16)
 800d578:	18ed      	adds	r5, r5, r3
 800d57a:	f894 31d3 	ldrb.w	r3, [r4, #467]	; 0x1d3
		+ (F_Buff[i + 1] << 8) + F_Buff[i];
	DiskStart = DiskStart << 9;	// convert to bytes
	// read the boot sector
	if (__MSD_ReadBlock(F_Buff, DiskStart, 512)){
 800d57e:	f44f 7200 	mov.w	r2, #512	; 0x200
		Display_Info("FAT_Info() read partition failed", 0);
		return 0xFF; // Disk error!
	}
	// find first block in first partition
	i = MBR_PART_START + PART_LBA;
	DiskStart = (F_Buff[i + 3] << 24) + (F_Buff[i + 2] << 16)
 800d582:	eb05 2503 	add.w	r5, r5, r3, lsl #8
		+ (F_Buff[i + 1] << 8) + F_Buff[i];
	DiskStart = DiskStart << 9;	// convert to bytes
 800d586:	026d      	lsls	r5, r5, #9
	// read the boot sector
	if (__MSD_ReadBlock(F_Buff, DiskStart, 512)){
 800d588:	4629      	mov	r1, r5
 800d58a:	f7f6 fdc7 	bl	800411c <__MSD_ReadBlock>
 800d58e:	b128      	cbz	r0, 800d59c <FAT_Info+0x5c>
		Display_Info("FAT_Info() rd boot sect failed", DiskStart);
 800d590:	4847      	ldr	r0, [pc, #284]	; (800d6b0 <FAT_Info+0x170>)
 800d592:	4629      	mov	r1, r5
 800d594:	f7ff feb7 	bl	800d306 <Display_Info>
 800d598:	20ff      	movs	r0, #255	; 0xff
		return 0xFF; // Disk error!
 800d59a:	bd70      	pop	{r4, r5, r6, pc}
	}
	SectorSize = (F_Buff[BPB_SEC_SZ + 1] << 8) + F_Buff[BPB_SEC_SZ];
 800d59c:	7de3      	ldrb	r3, [r4, #23]
 800d59e:	7e22      	ldrb	r2, [r4, #24]
	SecPerClus = F_Buff[BPB_SEC_CLUST];
	RsvdSecCnt = (F_Buff[BPB_RES_SEC + 1] << 8) + F_Buff[BPB_RES_SEC];
	DIR_Size = (F_Buff[BPB_DIR_ENTS + 1] << 8) + F_Buff[BPB_DIR_ENTS];
 800d5a0:	f894 e01e 	ldrb.w	lr, [r4, #30]
 800d5a4:	7f60      	ldrb	r0, [r4, #29]
	// read the boot sector
	if (__MSD_ReadBlock(F_Buff, DiskStart, 512)){
		Display_Info("FAT_Info() rd boot sect failed", DiskStart);
		return 0xFF; // Disk error!
	}
	SectorSize = (F_Buff[BPB_SEC_SZ + 1] << 8) + F_Buff[BPB_SEC_SZ];
 800d5a6:	eb03 2202 	add.w	r2, r3, r2, lsl #8
	SecPerClus = F_Buff[BPB_SEC_CLUST];
 800d5aa:	f894 c019 	ldrb.w	ip, [r4, #25]
	RsvdSecCnt = (F_Buff[BPB_RES_SEC + 1] << 8) + F_Buff[BPB_RES_SEC];
	DIR_Size = (F_Buff[BPB_DIR_ENTS + 1] << 8) + F_Buff[BPB_DIR_ENTS];
 800d5ae:	eb00 200e 	add.w	r0, r0, lr, lsl #8
	// read the boot sector
	if (__MSD_ReadBlock(F_Buff, DiskStart, 512)){
		Display_Info("FAT_Info() rd boot sect failed", DiskStart);
		return 0xFF; // Disk error!
	}
	SectorSize = (F_Buff[BPB_SEC_SZ + 1] << 8) + F_Buff[BPB_SEC_SZ];
 800d5b2:	b292      	uxth	r2, r2
	SecPerClus = F_Buff[BPB_SEC_CLUST];
	RsvdSecCnt = (F_Buff[BPB_RES_SEC + 1] << 8) + F_Buff[BPB_RES_SEC];
	DIR_Size = (F_Buff[BPB_DIR_ENTS + 1] << 8) + F_Buff[BPB_DIR_ENTS];
 800d5b4:	b280      	uxth	r0, r0
	// read the boot sector
	if (__MSD_ReadBlock(F_Buff, DiskStart, 512)){
		Display_Info("FAT_Info() rd boot sect failed", DiskStart);
		return 0xFF; // Disk error!
	}
	SectorSize = (F_Buff[BPB_SEC_SZ + 1] << 8) + F_Buff[BPB_SEC_SZ];
 800d5b6:	f8a4 2218 	strh.w	r2, [r4, #536]	; 0x218
	SecPerClus = F_Buff[BPB_SEC_CLUST];
 800d5ba:	f8a4 c21a 	strh.w	ip, [r4, #538]	; 0x21a
	RsvdSecCnt = (F_Buff[BPB_RES_SEC + 1] << 8) + F_Buff[BPB_RES_SEC];
 800d5be:	7ee1      	ldrb	r1, [r4, #27]
 800d5c0:	7ea3      	ldrb	r3, [r4, #26]
	DIR_Size = (F_Buff[BPB_DIR_ENTS + 1] << 8) + F_Buff[BPB_DIR_ENTS];
	if (DIR_Size) {
 800d5c2:	b140      	cbz	r0, 800d5d6 <FAT_Info+0x96>
		FAT16 = 1;  // FAT16
 800d5c4:	f04f 0e01 	mov.w	lr, #1
 800d5c8:	f884 e004 	strb.w	lr, [r4, #4]
		FAT_Size = (F_Buff[BPB_SEC_FAT_16+ 1] << 8) + F_Buff[BPB_SEC_FAT_16];
 800d5cc:	f894 6023 	ldrb.w	r6, [r4, #35]	; 0x23
 800d5d0:	f894 e022 	ldrb.w	lr, [r4, #34]	; 0x22
 800d5d4:	e004      	b.n	800d5e0 <FAT_Info+0xa0>
	} else {
		FAT16 = 0;  // FAT32
		FAT_Size = (F_Buff[BPB32_SEC_FAT + 3] << 24) +
 800d5d6:	f894 6031 	ldrb.w	r6, [r4, #49]	; 0x31
 800d5da:	f894 e030 	ldrb.w	lr, [r4, #48]	; 0x30
	DIR_Size = (F_Buff[BPB_DIR_ENTS + 1] << 8) + F_Buff[BPB_DIR_ENTS];
	if (DIR_Size) {
		FAT16 = 1;  // FAT16
		FAT_Size = (F_Buff[BPB_SEC_FAT_16+ 1] << 8) + F_Buff[BPB_SEC_FAT_16];
	} else {
		FAT16 = 0;  // FAT32
 800d5de:	7120      	strb	r0, [r4, #4]
		FAT_Size = (F_Buff[BPB32_SEC_FAT + 3] << 24) +
			(F_Buff[BPB32_SEC_FAT + 2] << 16) +
			(F_Buff[BPB32_SEC_FAT + 1] << 8) +
			F_Buff[BPB32_SEC_FAT];
	}
	FAT_Addr = DiskStart + RsvdSecCnt * SectorSize;	// start of FAT table
 800d5e0:	eb03 2101 	add.w	r1, r3, r1, lsl #8
 800d5e4:	4b2f      	ldr	r3, [pc, #188]	; (800d6a4 <FAT_Info+0x164>)
 800d5e6:	b289      	uxth	r1, r1
 800d5e8:	fb01 5102 	mla	r1, r1, r2, r5
	Root_Addr = FAT_Addr + F_Buff[BPB_FATS] * FAT_Size * SectorSize;	// start of data
 800d5ec:	7f1d      	ldrb	r5, [r3, #28]
	if (DIR_Size) {
		FAT16 = 1;  // FAT16
		FAT_Size = (F_Buff[BPB_SEC_FAT_16+ 1] << 8) + F_Buff[BPB_SEC_FAT_16];
	} else {
		FAT16 = 0;  // FAT32
		FAT_Size = (F_Buff[BPB32_SEC_FAT + 3] << 24) +
 800d5ee:	eb0e 2e06 	add.w	lr, lr, r6, lsl #8
			(F_Buff[BPB32_SEC_FAT + 2] << 16) +
			(F_Buff[BPB32_SEC_FAT + 1] << 8) +
			F_Buff[BPB32_SEC_FAT];
	}
	FAT_Addr = DiskStart + RsvdSecCnt * SectorSize;	// start of FAT table
	Root_Addr = FAT_Addr + F_Buff[BPB_FATS] * FAT_Size * SectorSize;	// start of data
 800d5f2:	4355      	muls	r5, r2
	if (DIR_Size) {
		FAT16 = 1;  // FAT16
		FAT_Size = (F_Buff[BPB_SEC_FAT_16+ 1] << 8) + F_Buff[BPB_SEC_FAT_16];
	} else {
		FAT16 = 0;  // FAT32
		FAT_Size = (F_Buff[BPB32_SEC_FAT + 3] << 24) +
 800d5f4:	fa1f fe8e 	uxth.w	lr, lr
			(F_Buff[BPB32_SEC_FAT + 2] << 16) +
			(F_Buff[BPB32_SEC_FAT + 1] << 8) +
			F_Buff[BPB32_SEC_FAT];
	}
	FAT_Addr = DiskStart + RsvdSecCnt * SectorSize;	// start of FAT table
	Root_Addr = FAT_Addr + F_Buff[BPB_FATS] * FAT_Size * SectorSize;	// start of data
 800d5f8:	fb0e 1505 	mla	r5, lr, r5, r1
		FAT_Size = (F_Buff[BPB32_SEC_FAT + 3] << 24) +
			(F_Buff[BPB32_SEC_FAT + 2] << 16) +
			(F_Buff[BPB32_SEC_FAT + 1] << 8) +
			F_Buff[BPB32_SEC_FAT];
	}
	FAT_Addr = DiskStart + RsvdSecCnt * SectorSize;	// start of FAT table
 800d5fc:	6019      	str	r1, [r3, #0]
	Root_Addr = FAT_Addr + F_Buff[BPB_FATS] * FAT_Size * SectorSize;	// start of data
	if (FAT16) {
 800d5fe:	7919      	ldrb	r1, [r3, #4]
			(F_Buff[BPB32_SEC_FAT + 2] << 16) +
			(F_Buff[BPB32_SEC_FAT + 1] << 8) +
			F_Buff[BPB32_SEC_FAT];
	}
	FAT_Addr = DiskStart + RsvdSecCnt * SectorSize;	// start of FAT table
	Root_Addr = FAT_Addr + F_Buff[BPB_FATS] * FAT_Size * SectorSize;	// start of data
 800d600:	f8c3 5214 	str.w	r5, [r3, #532]	; 0x214
	if (FAT16) {
 800d604:	b119      	cbz	r1, 800d60e <FAT_Info+0xce>
		DirBlkNum = DIR_Size / (512 / 32); // 32 bytes per dir entry
 800d606:	0900      	lsrs	r0, r0, #4
 800d608:	f8a3 0210 	strh.w	r0, [r3, #528]	; 0x210
 800d60c:	e016      	b.n	800d63c <FAT_Info+0xfc>
		CurDir = Root_Addr;
	} else {
		FDT_Cluster = (F_Buff[BPB_ROOT + 3] << 24) + (F_Buff[BPB_ROOT + 2] << 16)
 800d60e:	f893 003a 	ldrb.w	r0, [r3, #58]	; 0x3a
 800d612:	f893 e03b 	ldrb.w	lr, [r3, #59]	; 0x3b
 800d616:	0400      	lsls	r0, r0, #16
 800d618:	eb00 600e 	add.w	r0, r0, lr, lsl #24
 800d61c:	f893 e038 	ldrb.w	lr, [r3, #56]	; 0x38
			+ (F_Buff[BPB_ROOT + 1] << 8) + F_Buff[BPB_ROOT];
		FDT_Start = Root_Addr + (FDT_Cluster - 2) * SecPerClus * SectorSize;
 800d620:	fb0c f202 	mul.w	r2, ip, r2
	Root_Addr = FAT_Addr + F_Buff[BPB_FATS] * FAT_Size * SectorSize;	// start of data
	if (FAT16) {
		DirBlkNum = DIR_Size / (512 / 32); // 32 bytes per dir entry
		CurDir = Root_Addr;
	} else {
		FDT_Cluster = (F_Buff[BPB_ROOT + 3] << 24) + (F_Buff[BPB_ROOT + 2] << 16)
 800d624:	4470      	add	r0, lr
 800d626:	f893 e039 	ldrb.w	lr, [r3, #57]	; 0x39
 800d62a:	eb00 200e 	add.w	r0, r0, lr, lsl #8
 800d62e:	f8c3 0220 	str.w	r0, [r3, #544]	; 0x220
			+ (F_Buff[BPB_ROOT + 1] << 8) + F_Buff[BPB_ROOT];
		FDT_Start = Root_Addr + (FDT_Cluster - 2) * SecPerClus * SectorSize;
 800d632:	3802      	subs	r0, #2
 800d634:	fb00 5502 	mla	r5, r0, r2, r5
 800d638:	f8c3 5224 	str.w	r5, [r3, #548]	; 0x224
		CurDir = FDT_Start;
	}
	// initialized in this method
	Display_Info("FAT_Info() FAT16", FAT16);			// set if FAT16, cleared if FAT32
	Display_Info("FAT_Info() SectorSize", SectorSize);	// sector size in bytes
 800d63c:	4c19      	ldr	r4, [pc, #100]	; (800d6a4 <FAT_Info+0x164>)
		CurDir = Root_Addr;
	} else {
		FDT_Cluster = (F_Buff[BPB_ROOT + 3] << 24) + (F_Buff[BPB_ROOT + 2] << 16)
			+ (F_Buff[BPB_ROOT + 1] << 8) + F_Buff[BPB_ROOT];
		FDT_Start = Root_Addr + (FDT_Cluster - 2) * SecPerClus * SectorSize;
		CurDir = FDT_Start;
 800d63e:	f8c3 521c 	str.w	r5, [r3, #540]	; 0x21c
	}
	// initialized in this method
	Display_Info("FAT_Info() FAT16", FAT16);			// set if FAT16, cleared if FAT32
 800d642:	481c      	ldr	r0, [pc, #112]	; (800d6b4 <FAT_Info+0x174>)
 800d644:	f7ff fe5f 	bl	800d306 <Display_Info>
	Display_Info("FAT_Info() SectorSize", SectorSize);	// sector size in bytes
 800d648:	481b      	ldr	r0, [pc, #108]	; (800d6b8 <FAT_Info+0x178>)
 800d64a:	f8b4 1218 	ldrh.w	r1, [r4, #536]	; 0x218
 800d64e:	f7ff fe5a 	bl	800d306 <Display_Info>
	Display_Info("FAT_Info() SecPerClus", SecPerClus);	// sectors per cluster
 800d652:	481a      	ldr	r0, [pc, #104]	; (800d6bc <FAT_Info+0x17c>)
 800d654:	f8b4 121a 	ldrh.w	r1, [r4, #538]	; 0x21a
 800d658:	f7ff fe55 	bl	800d306 <Display_Info>
	Display_Info("FAT_Info() FAT_Addr", FAT_Addr);		// Address of first fat block relative to start of disk in bytes
 800d65c:	4818      	ldr	r0, [pc, #96]	; (800d6c0 <FAT_Info+0x180>)
 800d65e:	6821      	ldr	r1, [r4, #0]
 800d660:	f7ff fe51 	bl	800d306 <Display_Info>
	Display_Info("FAT_Info() Root_Addr", Root_Addr);		// address of root in bytes (FAT16)
 800d664:	4817      	ldr	r0, [pc, #92]	; (800d6c4 <FAT_Info+0x184>)
 800d666:	f8d4 1214 	ldr.w	r1, [r4, #532]	; 0x214
 800d66a:	f7ff fe4c 	bl	800d306 <Display_Info>
	Display_Info("FAT_Info() DirBlkNum", DirBlkNum);		// used to find byte index into file for 1st cluster
 800d66e:	4816      	ldr	r0, [pc, #88]	; (800d6c8 <FAT_Info+0x188>)
 800d670:	f8b4 1210 	ldrh.w	r1, [r4, #528]	; 0x210
 800d674:	f7ff fe47 	bl	800d306 <Display_Info>
	Display_Info("FAT_Info() FDT_Start", FDT_Start);		// address of first FAT32 directory block in bytes
 800d678:	4814      	ldr	r0, [pc, #80]	; (800d6cc <FAT_Info+0x18c>)
 800d67a:	f8d4 1224 	ldr.w	r1, [r4, #548]	; 0x224
 800d67e:	f7ff fe42 	bl	800d306 <Display_Info>
	Display_Info("FAT_Info() FDT_Cluster", FDT_Cluster);  // cluster number of first directory (root)
 800d682:	4813      	ldr	r0, [pc, #76]	; (800d6d0 <FAT_Info+0x190>)
 800d684:	f8d4 1220 	ldr.w	r1, [r4, #544]	; 0x220
 800d688:	f7ff fe3d 	bl	800d306 <Display_Info>
	// not set right now
	//Display_Info("FAT_Info() CurDir", CurDir);		// disk address of current directory entry in bytes
	//Display_Info("FAT_Info() CurFileAddr", CurFileAddr);		// index into current cluster of file in bytes
	//Display_Info("FAT_Info() CurFileSz", CurFileSz);		// size of file in bytes
	//Display_Info("FAT_Info() CurCluster", CurCluster);	// current cluster
	if(confp->debug_level > 3)
 800d68c:	4b11      	ldr	r3, [pc, #68]	; (800d6d4 <FAT_Info+0x194>)
 800d68e:	681b      	ldr	r3, [r3, #0]
 800d690:	f9b3 3064 	ldrsh.w	r3, [r3, #100]	; 0x64
 800d694:	2b03      	cmp	r3, #3
 800d696:	dd00      	ble.n	800d69a <FAT_Info+0x15a>
 800d698:	e7fe      	b.n	800d698 <FAT_Info+0x158>
		while(1){}
	SD_Card = TRUE;
 800d69a:	2301      	movs	r3, #1
 800d69c:	f884 3228 	strb.w	r3, [r4, #552]	; 0x228
 800d6a0:	2000      	movs	r0, #0
	return 0; // Disk ok!
}
 800d6a2:	bd70      	pop	{r4, r5, r6, pc}
 800d6a4:	20004b54 	.word	0x20004b54
 800d6a8:	0801079d 	.word	0x0801079d
 800d6ac:	080107a8 	.word	0x080107a8
 800d6b0:	080107c9 	.word	0x080107c9
 800d6b4:	080107e8 	.word	0x080107e8
 800d6b8:	080107f9 	.word	0x080107f9
 800d6bc:	0801080f 	.word	0x0801080f
 800d6c0:	08010825 	.word	0x08010825
 800d6c4:	08010839 	.word	0x08010839
 800d6c8:	0801084e 	.word	0x0801084e
 800d6cc:	08010863 	.word	0x08010863
 800d6d0:	08010878 	.word	0x08010878
 800d6d4:	20001800 	.word	0x20001800

0800d6d8 <Close>:
Function Name : Close
Description : close the active file file
Para :
*******************************************************************************/
char Close()
{
 800d6d8:	b538      	push	{r3, r4, r5, lr}
	u16  i, j;
	u32 Disk_Index;
	Display_Info( "Close() CurDir", CurDir);
 800d6da:	4c29      	ldr	r4, [pc, #164]	; (800d780 <Close+0xa8>)
 800d6dc:	4829      	ldr	r0, [pc, #164]	; (800d784 <Close+0xac>)
 800d6de:	f8d4 121c 	ldr.w	r1, [r4, #540]	; 0x21c
 800d6e2:	f7ff fe10 	bl	800d306 <Display_Info>
	// flush out the last block of data
	Disk_Index = CurFileAddr & ~(0x1FF);	// must use block aligned address
	if (__MSD_WriteBlock(F_Buff, Disk_Index, 512)){
 800d6e6:	f8d4 120c 	ldr.w	r1, [r4, #524]	; 0x20c
 800d6ea:	f104 000c 	add.w	r0, r4, #12
 800d6ee:	f421 71fe 	bic.w	r1, r1, #508	; 0x1fc
 800d6f2:	f021 0103 	bic.w	r1, r1, #3
 800d6f6:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d6fa:	f7f6 fd0d 	bl	8004118 <__MSD_WriteBlock>
 800d6fe:	b118      	cbz	r0, 800d708 <Close+0x30>
		Display_Info( "Close() Error on writing file)", CurFileAddr);
 800d700:	4821      	ldr	r0, [pc, #132]	; (800d788 <Close+0xb0>)
 800d702:	f8d4 120c 	ldr.w	r1, [r4, #524]	; 0x20c
 800d706:	e02d      	b.n	800d764 <Close+0x8c>
		return 0xFF; // File Write Error
	}
	// update file size in directory entry
	// read block with directory entry
	Disk_Index = CurDir & ~(0x1FF);	// must use block aligned address
 800d708:	f8d4 521c 	ldr.w	r5, [r4, #540]	; 0x21c
	if (__MSD_ReadBlock(F_Buff, Disk_Index, 512)){
 800d70c:	f104 000c 	add.w	r0, r4, #12
		Display_Info( "Close() Error on writing file)", CurFileAddr);
		return 0xFF; // File Write Error
	}
	// update file size in directory entry
	// read block with directory entry
	Disk_Index = CurDir & ~(0x1FF);	// must use block aligned address
 800d710:	f425 75fe 	bic.w	r5, r5, #508	; 0x1fc
 800d714:	f025 0503 	bic.w	r5, r5, #3
	if (__MSD_ReadBlock(F_Buff, Disk_Index, 512)){
 800d718:	4629      	mov	r1, r5
 800d71a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d71e:	f7f6 fcfd 	bl	800411c <__MSD_ReadBlock>
 800d722:	b108      	cbz	r0, 800d728 <Close+0x50>
		Display_Info( "Close() Err on directory read)", CurDir);
 800d724:	4819      	ldr	r0, [pc, #100]	; (800d78c <Close+0xb4>)
 800d726:	e01b      	b.n	800d760 <Close+0x88>
		return 0xFF; // File Write Error
	}
	i = CurDir & 0x1FF;	// index into block for directory entry
	F_Buff[i + DIR_FILE_SZ + 3] = (CurFileSz >> 24) & 0xFF;
 800d728:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
 800d72c:	f8d4 222c 	ldr.w	r2, [r4, #556]	; 0x22c
 800d730:	05db      	lsls	r3, r3, #23
 800d732:	0ddb      	lsrs	r3, r3, #23
 800d734:	191b      	adds	r3, r3, r4
 800d736:	0e11      	lsrs	r1, r2, #24
 800d738:	f883 102b 	strb.w	r1, [r3, #43]	; 0x2b
	F_Buff[i + DIR_FILE_SZ + 2] = (CurFileSz >> 16) & 0xFF;
 800d73c:	0c11      	lsrs	r1, r2, #16
 800d73e:	f883 102a 	strb.w	r1, [r3, #42]	; 0x2a
	F_Buff[i + DIR_FILE_SZ + 1] = (CurFileSz >> 8) & 0xFF;
 800d742:	0a11      	lsrs	r1, r2, #8
 800d744:	f883 1029 	strb.w	r1, [r3, #41]	; 0x29
	F_Buff[i + DIR_FILE_SZ] = CurFileSz & 0xFF;
 800d748:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	if (__MSD_WriteBlock(F_Buff, Disk_Index, 512)){
 800d74c:	4629      	mov	r1, r5
 800d74e:	f104 000c 	add.w	r0, r4, #12
 800d752:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d756:	f7f6 fcdf 	bl	8004118 <__MSD_WriteBlock>
 800d75a:	4605      	mov	r5, r0
 800d75c:	b130      	cbz	r0, 800d76c <Close+0x94>
		Display_Info( "Close() Err on directory write", CurDir);
 800d75e:	480c      	ldr	r0, [pc, #48]	; (800d790 <Close+0xb8>)
 800d760:	f8d4 121c 	ldr.w	r1, [r4, #540]	; 0x21c
 800d764:	f7ff fdcf 	bl	800d306 <Display_Info>
 800d768:	20ff      	movs	r0, #255	; 0xff
		return 0xFF;
 800d76a:	bd38      	pop	{r3, r4, r5, pc}
	}
	Display_Info( "Close() file size", CurFileSz);
 800d76c:	4809      	ldr	r0, [pc, #36]	; (800d794 <Close+0xbc>)
 800d76e:	f8d4 122c 	ldr.w	r1, [r4, #556]	; 0x22c
 800d772:	f7ff fdc8 	bl	800d306 <Display_Info>
	CurFileSz = 0;
 800d776:	f8c4 522c 	str.w	r5, [r4, #556]	; 0x22c
 800d77a:	4628      	mov	r0, r5
	return 0;
}
 800d77c:	bd38      	pop	{r3, r4, r5, pc}
 800d77e:	bf00      	nop
 800d780:	20004b54 	.word	0x20004b54
 800d784:	0801088f 	.word	0x0801088f
 800d788:	0801089e 	.word	0x0801089e
 800d78c:	080108bd 	.word	0x080108bd
 800d790:	080108dc 	.word	0x080108dc
 800d794:	080108fb 	.word	0x080108fb

0800d798 <DirTouch>:
/*******************************************************************************
Function Name : DirTouch
Description : Update directory timestamp
*******************************************************************************/
u8 DirTouch(void)
{
 800d798:	b510      	push	{r4, lr}
	Display_Info("DirTouch", 0);
	if (__MSD_ReadBlock(F_Buff, CurDir & ~(0x1FF), 512))
 800d79a:	4c13      	ldr	r4, [pc, #76]	; (800d7e8 <DirTouch+0x50>)
Function Name : DirTouch
Description : Update directory timestamp
*******************************************************************************/
u8 DirTouch(void)
{
	Display_Info("DirTouch", 0);
 800d79c:	4813      	ldr	r0, [pc, #76]	; (800d7ec <DirTouch+0x54>)
 800d79e:	2100      	movs	r1, #0
 800d7a0:	f7ff fdb1 	bl	800d306 <Display_Info>
	if (__MSD_ReadBlock(F_Buff, CurDir & ~(0x1FF), 512))
 800d7a4:	f8d4 121c 	ldr.w	r1, [r4, #540]	; 0x21c
 800d7a8:	f104 000c 	add.w	r0, r4, #12
 800d7ac:	f421 71fe 	bic.w	r1, r1, #508	; 0x1fc
 800d7b0:	f021 0103 	bic.w	r1, r1, #3
 800d7b4:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d7b8:	f7f6 fcb0 	bl	800411c <__MSD_ReadBlock>
 800d7bc:	b108      	cbz	r0, 800d7c2 <DirTouch+0x2a>
		return 0xff;
	F_Buff[(CurDir & 0x1FF) + DIR_MOD_TIME] += 1;
	return __MSD_WriteBlock(F_Buff, CurDir >> 9, 512);
}
 800d7be:	20ff      	movs	r0, #255	; 0xff
 800d7c0:	bd10      	pop	{r4, pc}
u8 DirTouch(void)
{
	Display_Info("DirTouch", 0);
	if (__MSD_ReadBlock(F_Buff, CurDir & ~(0x1FF), 512))
		return 0xff;
	F_Buff[(CurDir & 0x1FF) + DIR_MOD_TIME] += 1;
 800d7c2:	f8d4 121c 	ldr.w	r1, [r4, #540]	; 0x21c
	return __MSD_WriteBlock(F_Buff, CurDir >> 9, 512);
 800d7c6:	f104 000c 	add.w	r0, r4, #12
u8 DirTouch(void)
{
	Display_Info("DirTouch", 0);
	if (__MSD_ReadBlock(F_Buff, CurDir & ~(0x1FF), 512))
		return 0xff;
	F_Buff[(CurDir & 0x1FF) + DIR_MOD_TIME] += 1;
 800d7ca:	05cb      	lsls	r3, r1, #23
 800d7cc:	0ddb      	lsrs	r3, r3, #23
 800d7ce:	3316      	adds	r3, #22
 800d7d0:	191b      	adds	r3, r3, r4
 800d7d2:	7b1a      	ldrb	r2, [r3, #12]
	return __MSD_WriteBlock(F_Buff, CurDir >> 9, 512);
 800d7d4:	0a49      	lsrs	r1, r1, #9
u8 DirTouch(void)
{
	Display_Info("DirTouch", 0);
	if (__MSD_ReadBlock(F_Buff, CurDir & ~(0x1FF), 512))
		return 0xff;
	F_Buff[(CurDir & 0x1FF) + DIR_MOD_TIME] += 1;
 800d7d6:	3201      	adds	r2, #1
 800d7d8:	731a      	strb	r2, [r3, #12]
	return __MSD_WriteBlock(F_Buff, CurDir >> 9, 512);
 800d7da:	f44f 7200 	mov.w	r2, #512	; 0x200
}
 800d7de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
	Display_Info("DirTouch", 0);
	if (__MSD_ReadBlock(F_Buff, CurDir & ~(0x1FF), 512))
		return 0xff;
	F_Buff[(CurDir & 0x1FF) + DIR_MOD_TIME] += 1;
	return __MSD_WriteBlock(F_Buff, CurDir >> 9, 512);
 800d7e2:	f7f6 bc99 	b.w	8004118 <__MSD_WriteBlock>
 800d7e6:	bf00      	nop
 800d7e8:	20004b54 	.word	0x20004b54
 800d7ec:	0801090d 	.word	0x0801090d

0800d7f0 <GetClust>:
/*******************************************************************************
Function Name : GetClust
Description : Find unused cluster in FAT
*******************************************************************************/
u8 GetClust(void)
{
 800d7f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	u16 i;	// index in block for current fat entry
	u32 addr;	// address of fat entry in bytes
	u32 clust;	// temporary cluster number
	u32 tmp;

	Display_Info("GetClust()", 0);
 800d7f4:	4859      	ldr	r0, [pc, #356]	; (800d95c <GetClust+0x16c>)
 800d7f6:	2100      	movs	r1, #0
 800d7f8:	f7ff fd85 	bl	800d306 <Display_Info>
	clust = 2;		// skip first 2 reserved fat entries
	if (FAT16) {
 800d7fc:	4b58      	ldr	r3, [pc, #352]	; (800d960 <GetClust+0x170>)
 800d7fe:	791a      	ldrb	r2, [r3, #4]
 800d800:	b112      	cbz	r2, 800d808 <GetClust+0x18>
		addr = FAT_Addr + clust * 2;
 800d802:	681f      	ldr	r7, [r3, #0]
 800d804:	3704      	adds	r7, #4
 800d806:	e001      	b.n	800d80c <GetClust+0x1c>
	} else {
		addr = FAT_Addr + clust * 4;
 800d808:	681f      	ldr	r7, [r3, #0]
 800d80a:	3708      	adds	r7, #8
	}
	Display_Info("GetClust() FAT_Addr", FAT_Addr);
 800d80c:	4c54      	ldr	r4, [pc, #336]	; (800d960 <GetClust+0x170>)
	Display_Info("GetClust() CurCluster", clust);
	i = (addr & 0x1FF);
	addr = addr & 0xFFFFe00;
 800d80e:	4e55      	ldr	r6, [pc, #340]	; (800d964 <GetClust+0x174>)
	if (FAT16) {
		addr = FAT_Addr + clust * 2;
	} else {
		addr = FAT_Addr + clust * 4;
	}
	Display_Info("GetClust() FAT_Addr", FAT_Addr);
 800d810:	4855      	ldr	r0, [pc, #340]	; (800d968 <GetClust+0x178>)
 800d812:	6821      	ldr	r1, [r4, #0]
 800d814:	f7ff fd77 	bl	800d306 <Display_Info>
	Display_Info("GetClust() CurCluster", clust);
	i = (addr & 0x1FF);
	addr = addr & 0xFFFFe00;
 800d818:	ea07 0606 	and.w	r6, r7, r6
		addr = FAT_Addr + clust * 2;
	} else {
		addr = FAT_Addr + clust * 4;
	}
	Display_Info("GetClust() FAT_Addr", FAT_Addr);
	Display_Info("GetClust() CurCluster", clust);
 800d81c:	4853      	ldr	r0, [pc, #332]	; (800d96c <GetClust+0x17c>)
 800d81e:	2102      	movs	r1, #2
	i = (addr & 0x1FF);
 800d820:	05fd      	lsls	r5, r7, #23
		addr = FAT_Addr + clust * 2;
	} else {
		addr = FAT_Addr + clust * 4;
	}
	Display_Info("GetClust() FAT_Addr", FAT_Addr);
	Display_Info("GetClust() CurCluster", clust);
 800d822:	f7ff fd70 	bl	800d306 <Display_Info>
	i = (addr & 0x1FF);
 800d826:	0ded      	lsrs	r5, r5, #23
	addr = addr & 0xFFFFe00;
	Display_Info("GetClust() addr", addr);
 800d828:	4851      	ldr	r0, [pc, #324]	; (800d970 <GetClust+0x180>)
 800d82a:	4631      	mov	r1, r6
 800d82c:	f7ff fd6b 	bl	800d306 <Display_Info>
	Display_Info("GetClust() i", i);
 800d830:	4850      	ldr	r0, [pc, #320]	; (800d974 <GetClust+0x184>)
 800d832:	4629      	mov	r1, r5
 800d834:	f7ff fd67 	bl	800d306 <Display_Info>
	if (__MSD_ReadBlock(F_Buff, addr, 512))
 800d838:	f104 000c 	add.w	r0, r4, #12
 800d83c:	4631      	mov	r1, r6
 800d83e:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d842:	f7f6 fc6b 	bl	800411c <__MSD_ReadBlock>
 800d846:	2800      	cmp	r0, #0
 800d848:	f040 8084 	bne.w	800d954 <GetClust+0x164>
		return 0xff;
	// search in block of fat entries
	while(i < 512)
	{
		if (FAT16) {
 800d84c:	f894 c004 	ldrb.w	ip, [r4, #4]
 800d850:	2703      	movs	r7, #3
 800d852:	f107 38ff 	add.w	r8, r7, #4294967295
 800d856:	4c42      	ldr	r4, [pc, #264]	; (800d960 <GetClust+0x170>)
 800d858:	1c6a      	adds	r2, r5, #1
 800d85a:	f1bc 0f00 	cmp.w	ip, #0
 800d85e:	d025      	beq.n	800d8ac <GetClust+0xbc>
			tmp = (F_Buff[i + 1] << 8) + F_Buff[i];
 800d860:	1912      	adds	r2, r2, r4
 800d862:	192b      	adds	r3, r5, r4
 800d864:	7b10      	ldrb	r0, [r2, #12]
 800d866:	7b19      	ldrb	r1, [r3, #12]
 800d868:	eb01 2100 	add.w	r1, r1, r0, lsl #8
 800d86c:	b9e1      	cbnz	r1, 800d8a8 <GetClust+0xb8>
			if (tmp == FAT_FREE) {
				// mark as End Of Chain
				F_Buff[i + 1] = 0xFF;
 800d86e:	3901      	subs	r1, #1
 800d870:	7311      	strb	r1, [r2, #12]
				F_Buff[i] = 0xF8;
 800d872:	f06f 0207 	mvn.w	r2, #7
 800d876:	731a      	strb	r2, [r3, #12]
				if (__MSD_WriteBlock(F_Buff, addr, 512))
 800d878:	f104 000c 	add.w	r0, r4, #12
 800d87c:	4631      	mov	r1, r6
 800d87e:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d882:	f7f6 fc49 	bl	8004118 <__MSD_WriteBlock>
 800d886:	2800      	cmp	r0, #0
 800d888:	d164      	bne.n	800d954 <GetClust+0x164>
					return 0xff;
				CurCluster = clust;
				CurFileAddr = Root_Addr + DirBlkNum * 512 + (clust - 2) * SecPerClus * SectorSize;
 800d88a:	f8b4 2210 	ldrh.w	r2, [r4, #528]	; 0x210
 800d88e:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 800d892:	f8b4 121a 	ldrh.w	r1, [r4, #538]	; 0x21a
 800d896:	eb03 2342 	add.w	r3, r3, r2, lsl #9
 800d89a:	f8b4 2218 	ldrh.w	r2, [r4, #536]	; 0x218
				// mark as End Of Chain
				F_Buff[i + 1] = 0xFF;
				F_Buff[i] = 0xF8;
				if (__MSD_WriteBlock(F_Buff, addr, 512))
					return 0xff;
				CurCluster = clust;
 800d89e:	f8c4 8008 	str.w	r8, [r4, #8]
				CurFileAddr = Root_Addr + DirBlkNum * 512 + (clust - 2) * SecPerClus * SectorSize;
 800d8a2:	434a      	muls	r2, r1
 800d8a4:	3f03      	subs	r7, #3
 800d8a6:	e038      	b.n	800d91a <GetClust+0x12a>
				break;
			}
			i  += 2;
 800d8a8:	3502      	adds	r5, #2
 800d8aa:	e04d      	b.n	800d948 <GetClust+0x158>
			clust++;
		} else {   // FAT32
			tmp = ((F_Buff[i + 3] & 0x0f) << 24) +
				(F_Buff[i + 2] << 16) +
 800d8ac:	1ca9      	adds	r1, r5, #2
				(F_Buff[i + 1] << 8) +
 800d8ae:	1912      	adds	r2, r2, r4
			}
			i  += 2;
			clust++;
		} else {   // FAT32
			tmp = ((F_Buff[i + 3] & 0x0f) << 24) +
				(F_Buff[i + 2] << 16) +
 800d8b0:	1909      	adds	r1, r1, r4
				(F_Buff[i + 1] << 8) +
 800d8b2:	f892 900c 	ldrb.w	r9, [r2, #12]
			}
			i  += 2;
			clust++;
		} else {   // FAT32
			tmp = ((F_Buff[i + 3] & 0x0f) << 24) +
				(F_Buff[i + 2] << 16) +
 800d8b6:	f891 a00c 	ldrb.w	sl, [r1, #12]
				(F_Buff[i + 1] << 8) +
 800d8ba:	ea4f 2909 	mov.w	r9, r9, lsl #8
				F_Buff[i];
 800d8be:	192b      	adds	r3, r5, r4
			i  += 2;
			clust++;
		} else {   // FAT32
			tmp = ((F_Buff[i + 3] & 0x0f) << 24) +
				(F_Buff[i + 2] << 16) +
				(F_Buff[i + 1] << 8) +
 800d8c0:	eb09 490a 	add.w	r9, r9, sl, lsl #16
				break;
			}
			i  += 2;
			clust++;
		} else {   // FAT32
			tmp = ((F_Buff[i + 3] & 0x0f) << 24) +
 800d8c4:	1ce8      	adds	r0, r5, #3
				(F_Buff[i + 2] << 16) +
				(F_Buff[i + 1] << 8) +
				F_Buff[i];
 800d8c6:	f893 a00c 	ldrb.w	sl, [r3, #12]
				break;
			}
			i  += 2;
			clust++;
		} else {   // FAT32
			tmp = ((F_Buff[i + 3] & 0x0f) << 24) +
 800d8ca:	1900      	adds	r0, r0, r4
				(F_Buff[i + 2] << 16) +
				(F_Buff[i + 1] << 8) +
				F_Buff[i];
 800d8cc:	44d1      	add	r9, sl
				break;
			}
			i  += 2;
			clust++;
		} else {   // FAT32
			tmp = ((F_Buff[i + 3] & 0x0f) << 24) +
 800d8ce:	f890 a00c 	ldrb.w	sl, [r0, #12]
 800d8d2:	f00a 0a0f 	and.w	sl, sl, #15
 800d8d6:	eb09 6a0a 	add.w	sl, r9, sl, lsl #24
 800d8da:	f1ba 0f00 	cmp.w	sl, #0
 800d8de:	d132      	bne.n	800d946 <GetClust+0x156>
				(F_Buff[i + 2] << 16) +
				(F_Buff[i + 1] << 8) +
				F_Buff[i];
			if (tmp == FAT_FREE) {
				// mark as End Of Chain
				F_Buff[i + 3] = 0xFF;
 800d8e0:	f04f 3cff 	mov.w	ip, #4294967295
 800d8e4:	f880 c00c 	strb.w	ip, [r0, #12]
				F_Buff[i + 2]  = 0xFF;
 800d8e8:	f881 c00c 	strb.w	ip, [r1, #12]
				F_Buff[i + 1]  = 0xFF;
 800d8ec:	f882 c00c 	strb.w	ip, [r2, #12]
				F_Buff[i] = 0xF8;
 800d8f0:	f06f 0207 	mvn.w	r2, #7
 800d8f4:	731a      	strb	r2, [r3, #12]
				if (__MSD_WriteBlock(F_Buff, addr, 512))
 800d8f6:	f104 000c 	add.w	r0, r4, #12
 800d8fa:	4631      	mov	r1, r6
 800d8fc:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d900:	f7f6 fc0a 	bl	8004118 <__MSD_WriteBlock>
 800d904:	bb30      	cbnz	r0, 800d954 <GetClust+0x164>
					return 0xff;
				CurCluster = clust;
				CurFileAddr = Root_Addr + (clust - 2) * SecPerClus * SectorSize;
 800d906:	f8b4 3218 	ldrh.w	r3, [r4, #536]	; 0x218
 800d90a:	f8b4 221a 	ldrh.w	r2, [r4, #538]	; 0x21a
				F_Buff[i + 2]  = 0xFF;
				F_Buff[i + 1]  = 0xFF;
				F_Buff[i] = 0xF8;
				if (__MSD_WriteBlock(F_Buff, addr, 512))
					return 0xff;
				CurCluster = clust;
 800d90e:	f8c4 8008 	str.w	r8, [r4, #8]
				CurFileAddr = Root_Addr + (clust - 2) * SecPerClus * SectorSize;
 800d912:	435a      	muls	r2, r3
 800d914:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 800d918:	3f03      	subs	r7, #3
 800d91a:	fb07 3702 	mla	r7, r7, r2, r3
 800d91e:	f8c4 720c 	str.w	r7, [r4, #524]	; 0x20c
			clust++;
		}
	}
	if(i >= 512)
		return 0xff;
	Display_Info("GetClust() CurFileAddr", CurFileAddr);
 800d922:	4c0f      	ldr	r4, [pc, #60]	; (800d960 <GetClust+0x170>)
 800d924:	4814      	ldr	r0, [pc, #80]	; (800d978 <GetClust+0x188>)
 800d926:	f8d4 120c 	ldr.w	r1, [r4, #524]	; 0x20c
 800d92a:	f7ff fcec 	bl	800d306 <Display_Info>
	Display_Info("GetClust() Root_Addr", Root_Addr);
 800d92e:	4813      	ldr	r0, [pc, #76]	; (800d97c <GetClust+0x18c>)
 800d930:	f8d4 1214 	ldr.w	r1, [r4, #532]	; 0x214
 800d934:	f7ff fce7 	bl	800d306 <Display_Info>
	Display_Info("GetClust() CurCluster", CurCluster);
 800d938:	480c      	ldr	r0, [pc, #48]	; (800d96c <GetClust+0x17c>)
 800d93a:	68a1      	ldr	r1, [r4, #8]
 800d93c:	f7ff fce3 	bl	800d306 <Display_Info>
 800d940:	2000      	movs	r0, #0
	return 0;
 800d942:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					return 0xff;
				CurCluster = clust;
				CurFileAddr = Root_Addr + (clust - 2) * SecPerClus * SectorSize;
				break;
			}
			i  += 4;
 800d946:	3504      	adds	r5, #4
 800d948:	b2ad      	uxth	r5, r5
 800d94a:	3701      	adds	r7, #1
	Display_Info("GetClust() addr", addr);
	Display_Info("GetClust() i", i);
	if (__MSD_ReadBlock(F_Buff, addr, 512))
		return 0xff;
	// search in block of fat entries
	while(i < 512)
 800d94c:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 800d950:	f4ff af7f 	bcc.w	800d852 <GetClust+0x62>
	if(i >= 512)
		return 0xff;
	Display_Info("GetClust() CurFileAddr", CurFileAddr);
	Display_Info("GetClust() Root_Addr", Root_Addr);
	Display_Info("GetClust() CurCluster", CurCluster);
	return 0;
 800d954:	20ff      	movs	r0, #255	; 0xff
}
 800d956:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800d95a:	bf00      	nop
 800d95c:	08010916 	.word	0x08010916
 800d960:	20004b54 	.word	0x20004b54
 800d964:	0ffffe00 	.word	0x0ffffe00
 800d968:	08010921 	.word	0x08010921
 800d96c:	08010935 	.word	0x08010935
 800d970:	0801094b 	.word	0x0801094b
 800d974:	0801095b 	.word	0x0801095b
 800d978:	08010968 	.word	0x08010968
 800d97c:	0801097f 	.word	0x0801097f

0800d980 <AddClust>:
/*******************************************************************************
Function Name : AddClust
Description : Add another cluster to current file
*******************************************************************************/
unsigned char AddClust()
{
 800d980:	b570      	push	{r4, r5, r6, lr}
	u32 i;	// index in block for fat entry
	u32 addr;	// byte address of sector from FAT table
	u32 tmp;

	// get address of current FAT entry
	Display_Info("AddClust() FAT_Addr", FAT_Addr);
 800d982:	4c23      	ldr	r4, [pc, #140]	; (800da10 <AddClust+0x90>)
 800d984:	4823      	ldr	r0, [pc, #140]	; (800da14 <AddClust+0x94>)
 800d986:	6821      	ldr	r1, [r4, #0]
 800d988:	f7ff fcbd 	bl	800d306 <Display_Info>
	if (FAT16) {
 800d98c:	7923      	ldrb	r3, [r4, #4]
 800d98e:	b123      	cbz	r3, 800d99a <AddClust+0x1a>
		addr = FAT_Addr + CurCluster * 2;
 800d990:	68a2      	ldr	r2, [r4, #8]
 800d992:	6823      	ldr	r3, [r4, #0]
 800d994:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800d998:	e003      	b.n	800d9a2 <AddClust+0x22>
	} else {
		addr = FAT_Addr + CurCluster * 4;
 800d99a:	68a2      	ldr	r2, [r4, #8]
 800d99c:	6823      	ldr	r3, [r4, #0]
 800d99e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
	}
	i = (addr & 0x1FF);
	addr = addr & 0xFFFFe00;
 800d9a2:	4c1d      	ldr	r4, [pc, #116]	; (800da18 <AddClust+0x98>)
	if (FAT16) {
		addr = FAT_Addr + CurCluster * 2;
	} else {
		addr = FAT_Addr + CurCluster * 4;
	}
	i = (addr & 0x1FF);
 800d9a4:	05de      	lsls	r6, r3, #23
	addr = addr & 0xFFFFe00;
 800d9a6:	ea03 0404 	and.w	r4, r3, r4
	Display_Info("AddClust() addr", addr);
 800d9aa:	481c      	ldr	r0, [pc, #112]	; (800da1c <AddClust+0x9c>)
 800d9ac:	4621      	mov	r1, r4
	if (FAT16) {
		addr = FAT_Addr + CurCluster * 2;
	} else {
		addr = FAT_Addr + CurCluster * 4;
	}
	i = (addr & 0x1FF);
 800d9ae:	0df6      	lsrs	r6, r6, #23
	addr = addr & 0xFFFFe00;
	Display_Info("AddClust() addr", addr);
 800d9b0:	f7ff fca9 	bl	800d306 <Display_Info>
	Display_Info("AddClust() i", i);
 800d9b4:	481a      	ldr	r0, [pc, #104]	; (800da20 <AddClust+0xa0>)
 800d9b6:	4631      	mov	r1, r6
 800d9b8:	f7ff fca5 	bl	800d306 <Display_Info>
	if(GetClust()) {	// this sets CurCluster and CurFileAddr reflect new cluster
 800d9bc:	f7ff ff18 	bl	800d7f0 <GetClust>
 800d9c0:	b128      	cbz	r0, 800d9ce <AddClust+0x4e>
		Display_Info("AddClust() GetClust failed", 0);
 800d9c2:	4818      	ldr	r0, [pc, #96]	; (800da24 <AddClust+0xa4>)
 800d9c4:	2100      	movs	r1, #0
 800d9c6:	f7ff fc9e 	bl	800d306 <Display_Info>
 800d9ca:	20ff      	movs	r0, #255	; 0xff
		return 0xFF;
 800d9cc:	bd70      	pop	{r4, r5, r6, pc}
	}
	// update old FAT entry to point to new cluster
	if (__MSD_ReadBlock(F_Buff, addr, 512))
 800d9ce:	4d10      	ldr	r5, [pc, #64]	; (800da10 <AddClust+0x90>)
 800d9d0:	4621      	mov	r1, r4
 800d9d2:	f105 000c 	add.w	r0, r5, #12
 800d9d6:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d9da:	f7f6 fb9f 	bl	800411c <__MSD_ReadBlock>
 800d9de:	b9a0      	cbnz	r0, 800da0a <AddClust+0x8a>
			return 0xff;
	if(FAT16){
 800d9e0:	792b      	ldrb	r3, [r5, #4]
 800d9e2:	1976      	adds	r6, r6, r5
 800d9e4:	b10b      	cbz	r3, 800d9ea <AddClust+0x6a>
		F_Buff[i + 1] = (CurCluster >> 8) & 0xff;
 800d9e6:	68ab      	ldr	r3, [r5, #8]
 800d9e8:	e004      	b.n	800d9f4 <AddClust+0x74>
		F_Buff[i] = CurCluster & 0xff;
	}
	else
	{
		F_Buff[i+3] = (CurCluster >> 24) & 0xff;
 800d9ea:	68ab      	ldr	r3, [r5, #8]
 800d9ec:	0e1a      	lsrs	r2, r3, #24
 800d9ee:	73f2      	strb	r2, [r6, #15]
		F_Buff[i+2] = (CurCluster >> 16) & 0xff;
 800d9f0:	0c1a      	lsrs	r2, r3, #16
 800d9f2:	73b2      	strb	r2, [r6, #14]
		F_Buff[i+1] = (CurCluster >> 8) & 0xff;
 800d9f4:	0a1a      	lsrs	r2, r3, #8
 800d9f6:	7372      	strb	r2, [r6, #13]
		F_Buff[i] = CurCluster & 0xff;
 800d9f8:	7333      	strb	r3, [r6, #12]
	}
	if(__MSD_WriteBlock(F_Buff, addr, 512))
 800d9fa:	480b      	ldr	r0, [pc, #44]	; (800da28 <AddClust+0xa8>)
 800d9fc:	4621      	mov	r1, r4
 800d9fe:	f44f 7200 	mov.w	r2, #512	; 0x200
 800da02:	f7f6 fb89 	bl	8004118 <__MSD_WriteBlock>
 800da06:	b900      	cbnz	r0, 800da0a <AddClust+0x8a>
 800da08:	bd70      	pop	{r4, r5, r6, pc}
 800da0a:	20ff      	movs	r0, #255	; 0xff
		return 0xff;
	// Note that GetClust() marked EOC
	return 0;
}
 800da0c:	bd70      	pop	{r4, r5, r6, pc}
 800da0e:	bf00      	nop
 800da10:	20004b54 	.word	0x20004b54
 800da14:	08010994 	.word	0x08010994
 800da18:	0ffffe00 	.word	0x0ffffe00
 800da1c:	080109a8 	.word	0x080109a8
 800da20:	080109b8 	.word	0x080109b8
 800da24:	080109c5 	.word	0x080109c5
 800da28:	20004b60 	.word	0x20004b60

0800da2c <W_Data>:
{
	u8 rval;
	u16 i;
	u32 blk;

	if(confp->debug_level > 1)
 800da2c:	4b42      	ldr	r3, [pc, #264]	; (800db38 <W_Data+0x10c>)
/*******************************************************************************
 Function Name : W_Strng
 Description : appends a string to file
 *******************************************************************************/
u8 W_Data(char *datap, u16 len)
{
 800da2e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	u8 rval;
	u16 i;
	u32 blk;

	if(confp->debug_level > 1)
 800da32:	681b      	ldr	r3, [r3, #0]
/*******************************************************************************
 Function Name : W_Strng
 Description : appends a string to file
 *******************************************************************************/
u8 W_Data(char *datap, u16 len)
{
 800da34:	4681      	mov	r9, r0
	u8 rval;
	u16 i;
	u32 blk;

	if(confp->debug_level > 1)
 800da36:	f9b3 3064 	ldrsh.w	r3, [r3, #100]	; 0x64
/*******************************************************************************
 Function Name : W_Strng
 Description : appends a string to file
 *******************************************************************************/
u8 W_Data(char *datap, u16 len)
{
 800da3a:	460f      	mov	r7, r1
	u8 rval;
	u16 i;
	u32 blk;

	if(confp->debug_level > 1)
 800da3c:	2b01      	cmp	r3, #1
 800da3e:	dd00      	ble.n	800da42 <W_Data+0x16>
 800da40:	e7fe      	b.n	800da40 <W_Data+0x14>
		while(1){}
	i = CurFileAddr & 0x1FF;	// get index within block
 800da42:	4d3e      	ldr	r5, [pc, #248]	; (800db3c <W_Data+0x110>)
 800da44:	f8d5 620c 	ldr.w	r6, [r5, #524]	; 0x20c
	blk = CurFileAddr & ~(0x1FF);
	if(blk != CurBlk){
 800da48:	f8d5 3230 	ldr.w	r3, [r5, #560]	; 0x230
	u32 blk;

	if(confp->debug_level > 1)
		while(1){}
	i = CurFileAddr & 0x1FF;	// get index within block
	blk = CurFileAddr & ~(0x1FF);
 800da4c:	f426 74fe 	bic.w	r4, r6, #508	; 0x1fc
 800da50:	f024 0403 	bic.w	r4, r4, #3
	if(blk != CurBlk){
 800da54:	429c      	cmp	r4, r3
 800da56:	d00b      	beq.n	800da70 <W_Data+0x44>
		if (__MSD_ReadBlock(F_Buff, blk, 512)){
 800da58:	f105 000c 	add.w	r0, r5, #12
 800da5c:	4621      	mov	r1, r4
 800da5e:	f44f 7200 	mov.w	r2, #512	; 0x200
 800da62:	f7f6 fb5b 	bl	800411c <__MSD_ReadBlock>
 800da66:	b108      	cbz	r0, 800da6c <W_Data+0x40>
			Display_Info( "W_Data() Error on reading file)", CurFileAddr);
 800da68:	4835      	ldr	r0, [pc, #212]	; (800db40 <W_Data+0x114>)
 800da6a:	e02a      	b.n	800dac2 <W_Data+0x96>
			return 0xFF; // File Write Error
		}
		CurBlk = blk;
 800da6c:	f8c5 4230 	str.w	r4, [r5, #560]	; 0x230
	u16 i;
	u32 blk;

	if(confp->debug_level > 1)
		while(1){}
	i = CurFileAddr & 0x1FF;	// get index within block
 800da70:	05f6      	lsls	r6, r6, #23
			Display_Info( "W_Data() Error on reading file)", CurFileAddr);
			return 0xFF; // File Write Error
		}
		CurBlk = blk;
	}
	Display_Info( "W_Data() len ", len);
 800da72:	4834      	ldr	r0, [pc, #208]	; (800db44 <W_Data+0x118>)
 800da74:	4639      	mov	r1, r7
	u16 i;
	u32 blk;

	if(confp->debug_level > 1)
		while(1){}
	i = CurFileAddr & 0x1FF;	// get index within block
 800da76:	0df6      	lsrs	r6, r6, #23
			Display_Info( "W_Data() Error on reading file)", CurFileAddr);
			return 0xFF; // File Write Error
		}
		CurBlk = blk;
	}
	Display_Info( "W_Data() len ", len);
 800da78:	f7ff fc45 	bl	800d306 <Display_Info>
 800da7c:	f04f 0800 	mov.w	r8, #0
	while(len-- > 0){
 800da80:	e055      	b.n	800db2e <W_Data+0x102>
		F_Buff[i++] = *datap++;
 800da82:	4d2e      	ldr	r5, [pc, #184]	; (800db3c <W_Data+0x110>)
 800da84:	f819 2008 	ldrb.w	r2, [r9, r8]
 800da88:	1973      	adds	r3, r6, r5
		CurFileSz++;
 800da8a:	f8d5 122c 	ldr.w	r1, [r5, #556]	; 0x22c
		}
		CurBlk = blk;
	}
	Display_Info( "W_Data() len ", len);
	while(len-- > 0){
		F_Buff[i++] = *datap++;
 800da8e:	3601      	adds	r6, #1
 800da90:	731a      	strb	r2, [r3, #12]
		CurFileSz++;
		CurFileAddr++;
 800da92:	f8d5 320c 	ldr.w	r3, [r5, #524]	; 0x20c
		}
		CurBlk = blk;
	}
	Display_Info( "W_Data() len ", len);
	while(len-- > 0){
		F_Buff[i++] = *datap++;
 800da96:	b2b6      	uxth	r6, r6
		CurFileSz++;
 800da98:	3101      	adds	r1, #1
		CurFileAddr++;
 800da9a:	3301      	adds	r3, #1
		if (i >= 512){ // Buffer full
 800da9c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
		CurBlk = blk;
	}
	Display_Info( "W_Data() len ", len);
	while(len-- > 0){
		F_Buff[i++] = *datap++;
		CurFileSz++;
 800daa0:	f8c5 122c 	str.w	r1, [r5, #556]	; 0x22c
		CurFileAddr++;
 800daa4:	f8c5 320c 	str.w	r3, [r5, #524]	; 0x20c
		if (i >= 512){ // Buffer full
 800daa8:	d13d      	bne.n	800db26 <W_Data+0xfa>
			Display_Info( "W_Data() block filled", CurFileSz);
 800daaa:	4827      	ldr	r0, [pc, #156]	; (800db48 <W_Data+0x11c>)
 800daac:	f7ff fc2b 	bl	800d306 <Display_Info>
			if (__MSD_WriteBlock(F_Buff, blk, 512)){
 800dab0:	f105 000c 	add.w	r0, r5, #12
 800dab4:	4621      	mov	r1, r4
 800dab6:	4632      	mov	r2, r6
 800dab8:	f7f6 fb2e 	bl	8004118 <__MSD_WriteBlock>
 800dabc:	4682      	mov	sl, r0
 800dabe:	b128      	cbz	r0, 800dacc <W_Data+0xa0>
				Display_Info( "W_Data() Error on writing file)", CurFileAddr);
 800dac0:	4822      	ldr	r0, [pc, #136]	; (800db4c <W_Data+0x120>)
 800dac2:	f8d5 120c 	ldr.w	r1, [r5, #524]	; 0x20c
 800dac6:	f7ff fc1e 	bl	800d306 <Display_Info>
 800daca:	e015      	b.n	800daf8 <W_Data+0xcc>
				return 0xFF; // File Write Error
			}
			bzero(F_Buff, 512);
 800dacc:	4632      	mov	r2, r6
 800dace:	f105 000c 	add.w	r0, r5, #12
 800dad2:	4651      	mov	r1, sl
 800dad4:	f002 f9f4 	bl	800fec0 <memset>
			i = 0;
			Cluster_Cnt++;
 800dad8:	f8b5 3234 	ldrh.w	r3, [r5, #564]	; 0x234
			if (Cluster_Cnt >= SecPerClus) {
 800dadc:	f8b5 221a 	ldrh.w	r2, [r5, #538]	; 0x21a
				Display_Info( "W_Data() Error on writing file)", CurFileAddr);
				return 0xFF; // File Write Error
			}
			bzero(F_Buff, 512);
			i = 0;
			Cluster_Cnt++;
 800dae0:	3301      	adds	r3, #1
 800dae2:	b29b      	uxth	r3, r3
			if (Cluster_Cnt >= SecPerClus) {
 800dae4:	429a      	cmp	r2, r3
				Display_Info( "W_Data() Error on writing file)", CurFileAddr);
				return 0xFF; // File Write Error
			}
			bzero(F_Buff, 512);
			i = 0;
			Cluster_Cnt++;
 800dae6:	f8a5 3234 	strh.w	r3, [r5, #564]	; 0x234
			if (Cluster_Cnt >= SecPerClus) {
 800daea:	d817      	bhi.n	800db1c <W_Data+0xf0>
				if (NextClust()){		// if not enough room
 800daec:	f7ff fcb4 	bl	800d458 <NextClust>
 800daf0:	b128      	cbz	r0, 800dafe <W_Data+0xd2>
					if(AddClust()) 		// extend the file
 800daf2:	f7ff ff45 	bl	800d980 <AddClust>
 800daf6:	b110      	cbz	r0, 800dafe <W_Data+0xd2>
 800daf8:	20ff      	movs	r0, #255	; 0xff
 800dafa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						return 0xff;
				}
				Cluster_Cnt = 0;
 800dafe:	4b0f      	ldr	r3, [pc, #60]	; (800db3c <W_Data+0x110>)
 800db00:	f04f 0200 	mov.w	r2, #0
				blk = CurBlk = CurFileAddr & ~(0x1FF);	// CurFileAddr updated by cluster code
 800db04:	f8d3 420c 	ldr.w	r4, [r3, #524]	; 0x20c
			if (Cluster_Cnt >= SecPerClus) {
				if (NextClust()){		// if not enough room
					if(AddClust()) 		// extend the file
						return 0xff;
				}
				Cluster_Cnt = 0;
 800db08:	f8a3 2234 	strh.w	r2, [r3, #564]	; 0x234
				blk = CurBlk = CurFileAddr & ~(0x1FF);	// CurFileAddr updated by cluster code
 800db0c:	f424 74fe 	bic.w	r4, r4, #508	; 0x1fc
 800db10:	f024 0403 	bic.w	r4, r4, #3
 800db14:	f8c3 4230 	str.w	r4, [r3, #560]	; 0x230
 800db18:	2600      	movs	r6, #0
 800db1a:	e004      	b.n	800db26 <W_Data+0xfa>
			} else {
				blk += 512;
 800db1c:	f504 7400 	add.w	r4, r4, #512	; 0x200
				CurBlk = blk;
 800db20:	f8c5 4230 	str.w	r4, [r5, #560]	; 0x230
 800db24:	4656      	mov	r6, sl
 800db26:	3f01      	subs	r7, #1
 800db28:	f108 0801 	add.w	r8, r8, #1
 800db2c:	b2bf      	uxth	r7, r7
			return 0xFF; // File Write Error
		}
		CurBlk = blk;
	}
	Display_Info( "W_Data() len ", len);
	while(len-- > 0){
 800db2e:	2f00      	cmp	r7, #0
 800db30:	d1a7      	bne.n	800da82 <W_Data+0x56>
 800db32:	4638      	mov	r0, r7
				CurBlk = blk;
			}
		}
	}
	return 0;
}
 800db34:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800db38:	20001800 	.word	0x20001800
 800db3c:	20004b54 	.word	0x20004b54
 800db40:	080109e0 	.word	0x080109e0
 800db44:	08010a00 	.word	0x08010a00
 800db48:	08010a0e 	.word	0x08010a0e
 800db4c:	08010a24 	.word	0x08010a24

0800db50 <W_Strng>:
/*******************************************************************************
 Function Name : W_Strng
 Description : appends a string to file
 *******************************************************************************/
u8 W_Strng(char *str)
{
 800db50:	b510      	push	{r4, lr}
 800db52:	4604      	mov	r4, r0
	return (W_Data(str, strlen(str)));
 800db54:	f002 fa7c 	bl	8010050 <strlen>
 800db58:	b281      	uxth	r1, r0
 800db5a:	4620      	mov	r0, r4
}
 800db5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 Function Name : W_Strng
 Description : appends a string to file
 *******************************************************************************/
u8 W_Strng(char *str)
{
	return (W_Data(str, strlen(str)));
 800db60:	e764      	b.n	800da2c <W_Data>

0800db62 <New>:
 Description : create a file next in sequence
 Para :  name is file name
 ext is extension part of name
 *******************************************************************************/
u8 New(uc8 *name, uc8 *ext)
{
 800db62:	e92d 45f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, sl, lr}
	u16  i, j;
	u32 dirindex;	// index on device for a directory structure
	u16  blkcnt;	// count of blocks read to fine end of a cluster

	Display_Info("New()", 0);
	if (SD_Card == FALSE){
 800db66:	4c5d      	ldr	r4, [pc, #372]	; (800dcdc <New+0x17a>)
 Description : create a file next in sequence
 Para :  name is file name
 ext is extension part of name
 *******************************************************************************/
u8 New(uc8 *name, uc8 *ext)
{
 800db68:	4680      	mov	r8, r0
 800db6a:	460e      	mov	r6, r1

	u16  i, j;
	u32 dirindex;	// index on device for a directory structure
	u16  blkcnt;	// count of blocks read to fine end of a cluster

	Display_Info("New()", 0);
 800db6c:	485c      	ldr	r0, [pc, #368]	; (800dce0 <New+0x17e>)
 800db6e:	2100      	movs	r1, #0
 800db70:	f7ff fbc9 	bl	800d306 <Display_Info>
	if (SD_Card == FALSE){
 800db74:	f894 0228 	ldrb.w	r0, [r4, #552]	; 0x228
 800db78:	b918      	cbnz	r0, 800db82 <New+0x20>
		__Display_Str(0, 0, RED, BKGND_COLOR, SD_Msgs[NoCard]);
 800db7a:	4b5a      	ldr	r3, [pc, #360]	; (800dce4 <New+0x182>)
 800db7c:	68db      	ldr	r3, [r3, #12]
 800db7e:	9300      	str	r3, [sp, #0]
 800db80:	e006      	b.n	800db90 <New+0x2e>
		return (0xFF);
	}
	// get free cluster
	if(GetClust()){
 800db82:	f7ff fe35 	bl	800d7f0 <GetClust>
 800db86:	b148      	cbz	r0, 800db9c <New+0x3a>
		__Display_Str(0, 0, RED, BKGND_COLOR, SD_Msgs[SDErr]);
 800db88:	4b56      	ldr	r3, [pc, #344]	; (800dce4 <New+0x182>)
 800db8a:	2000      	movs	r0, #0
 800db8c:	689b      	ldr	r3, [r3, #8]
 800db8e:	9300      	str	r3, [sp, #0]
 800db90:	4601      	mov	r1, r0
 800db92:	221f      	movs	r2, #31
 800db94:	4603      	mov	r3, r0
 800db96:	f7f6 faca 	bl	800412e <__Display_Str>
 800db9a:	e09c      	b.n	800dcd6 <New+0x174>
		return (0xFF);
	}
	// FAT info is read when card inserted
	if (FAT16){
 800db9c:	7923      	ldrb	r3, [r4, #4]
 800db9e:	b113      	cbz	r3, 800dba6 <New+0x44>
		dirindex = Root_Addr;
 800dba0:	f8d4 4214 	ldr.w	r4, [r4, #532]	; 0x214
 800dba4:	e001      	b.n	800dbaa <New+0x48>
	} else { // FAT32
		dirindex = FDT_Start;
 800dba6:	f8d4 4224 	ldr.w	r4, [r4, #548]	; 0x224
 800dbaa:	2700      	movs	r7, #0
 800dbac:	e089      	b.n	800dcc2 <New+0x160>
	}
	for(blkcnt = 0; blkcnt < SecPerClus; blkcnt++){
		Display_Info("New() dirindex", dirindex);
 800dbae:	484e      	ldr	r0, [pc, #312]	; (800dce8 <New+0x186>)
 800dbb0:	4621      	mov	r1, r4
 800dbb2:	f7ff fba8 	bl	800d306 <Display_Info>
		if (__MSD_ReadBlock(F_Buff, dirindex & ~(0x1FF), 512)){
 800dbb6:	f424 71fe 	bic.w	r1, r4, #508	; 0x1fc
 800dbba:	f105 000c 	add.w	r0, r5, #12
 800dbbe:	f021 0103 	bic.w	r1, r1, #3
 800dbc2:	f44f 7200 	mov.w	r2, #512	; 0x200
 800dbc6:	f7f6 faa9 	bl	800411c <__MSD_ReadBlock>
 800dbca:	4682      	mov	sl, r0
 800dbcc:	b110      	cbz	r0, 800dbd4 <New+0x72>
			Display_Info("New() MSD_ReadBlock failed", dirindex);
 800dbce:	4847      	ldr	r0, [pc, #284]	; (800dcec <New+0x18a>)
 800dbd0:	4621      	mov	r1, r4
 800dbd2:	e07e      	b.n	800dcd2 <New+0x170>
			return 0xff; // Read Sector fail
 800dbd4:	4621      	mov	r1, r4
		}
		for (i = 0; i < 512; i += 32, dirindex += 32){ // within current block
			if(F_Buff[i + DIR_FILE_NM] != DIR_FILE_NM_AVAIL && F_Buff[i + DIR_FILE_NM] != DIR_FILE_NM_ERASED)
 800dbd6:	4b46      	ldr	r3, [pc, #280]	; (800dcf0 <New+0x18e>)
	}
	for(blkcnt = 0; blkcnt < SecPerClus; blkcnt++){
		Display_Info("New() dirindex", dirindex);
		if (__MSD_ReadBlock(F_Buff, dirindex & ~(0x1FF), 512)){
			Display_Info("New() MSD_ReadBlock failed", dirindex);
			return 0xff; // Read Sector fail
 800dbd8:	1b0d      	subs	r5, r1, r4
		}
		for (i = 0; i < 512; i += 32, dirindex += 32){ // within current block
			if(F_Buff[i + DIR_FILE_NM] != DIR_FILE_NM_AVAIL && F_Buff[i + DIR_FILE_NM] != DIR_FILE_NM_ERASED)
 800dbda:	1b1b      	subs	r3, r3, r4
 800dbdc:	5c5b      	ldrb	r3, [r3, r1]
 800dbde:	b153      	cbz	r3, 800dbf6 <New+0x94>
 800dbe0:	2be5      	cmp	r3, #229	; 0xe5
 800dbe2:	d008      	beq.n	800dbf6 <New+0x94>
		Display_Info("New() dirindex", dirindex);
		if (__MSD_ReadBlock(F_Buff, dirindex & ~(0x1FF), 512)){
			Display_Info("New() MSD_ReadBlock failed", dirindex);
			return 0xff; // Read Sector fail
		}
		for (i = 0; i < 512; i += 32, dirindex += 32){ // within current block
 800dbe4:	f10a 0a20 	add.w	sl, sl, #32
 800dbe8:	fa1f fa8a 	uxth.w	sl, sl
 800dbec:	3120      	adds	r1, #32
 800dbee:	f5ba 7f00 	cmp.w	sl, #512	; 0x200
 800dbf2:	d1f0      	bne.n	800dbd6 <New+0x74>
 800dbf4:	e062      	b.n	800dcbc <New+0x15a>
			if(F_Buff[i + DIR_FILE_NM] != DIR_FILE_NM_AVAIL && F_Buff[i + DIR_FILE_NM] != DIR_FILE_NM_ERASED)
				continue;	// try next directory entry
			// found an unused directory entry
			CurFileSz = 0;
 800dbf6:	4f39      	ldr	r7, [pc, #228]	; (800dcdc <New+0x17a>)
 800dbf8:	2400      	movs	r4, #0
			CurDir = dirindex;
 800dbfa:	f8c7 121c 	str.w	r1, [r7, #540]	; 0x21c
		}
		for (i = 0; i < 512; i += 32, dirindex += 32){ // within current block
			if(F_Buff[i + DIR_FILE_NM] != DIR_FILE_NM_AVAIL && F_Buff[i + DIR_FILE_NM] != DIR_FILE_NM_ERASED)
				continue;	// try next directory entry
			// found an unused directory entry
			CurFileSz = 0;
 800dbfe:	f8c7 422c 	str.w	r4, [r7, #556]	; 0x22c
			CurDir = dirindex;
			Display_Info("New() found empty entry", CurDir);
 800dc02:	483c      	ldr	r0, [pc, #240]	; (800dcf4 <New+0x192>)
			bzero(&F_Buff[i], DIR_LEN);
 800dc04:	370c      	adds	r7, #12
			if(F_Buff[i + DIR_FILE_NM] != DIR_FILE_NM_AVAIL && F_Buff[i + DIR_FILE_NM] != DIR_FILE_NM_ERASED)
				continue;	// try next directory entry
			// found an unused directory entry
			CurFileSz = 0;
			CurDir = dirindex;
			Display_Info("New() found empty entry", CurDir);
 800dc06:	f7ff fb7e 	bl	800d306 <Display_Info>
			bzero(&F_Buff[i], DIR_LEN);
 800dc0a:	eb07 000a 	add.w	r0, r7, sl
 800dc0e:	4621      	mov	r1, r4
 800dc10:	2220      	movs	r2, #32
 800dc12:	f002 f955 	bl	800fec0 <memset>
 800dc16:	197f      	adds	r7, r7, r5
			for(j = 0; j < 8; j++)
			{
				F_Buff[i + DIR_FILE_NM + j] = name[j];
 800dc18:	f818 3004 	ldrb.w	r3, [r8, r4]
 800dc1c:	3401      	adds	r4, #1
			// found an unused directory entry
			CurFileSz = 0;
			CurDir = dirindex;
			Display_Info("New() found empty entry", CurDir);
			bzero(&F_Buff[i], DIR_LEN);
			for(j = 0; j < 8; j++)
 800dc1e:	2c08      	cmp	r4, #8
			{
				F_Buff[i + DIR_FILE_NM + j] = name[j];
 800dc20:	f807 3b01 	strb.w	r3, [r7], #1
			// found an unused directory entry
			CurFileSz = 0;
			CurDir = dirindex;
			Display_Info("New() found empty entry", CurDir);
			bzero(&F_Buff[i], DIR_LEN);
			for(j = 0; j < 8; j++)
 800dc24:	d1f8      	bne.n	800dc18 <New+0xb6>
			{
				F_Buff[i + DIR_FILE_NM + j] = name[j];
			}
			for(j = 0; j < 3; j++)
			{
				F_Buff[i + DIR_EXT + j] = ext[j];
 800dc26:	4b2d      	ldr	r3, [pc, #180]	; (800dcdc <New+0x17a>)
 800dc28:	7831      	ldrb	r1, [r6, #0]
 800dc2a:	f105 0208 	add.w	r2, r5, #8
 800dc2e:	18d2      	adds	r2, r2, r3
 800dc30:	7311      	strb	r1, [r2, #12]
 800dc32:	7871      	ldrb	r1, [r6, #1]
			}
			F_Buff[i + DIR_ATTR] = DIR_ATTR_MSK_ARCH;
 800dc34:	18ed      	adds	r5, r5, r3
			{
				F_Buff[i + DIR_FILE_NM + j] = name[j];
			}
			for(j = 0; j < 3; j++)
			{
				F_Buff[i + DIR_EXT + j] = ext[j];
 800dc36:	7351      	strb	r1, [r2, #13]
 800dc38:	78b1      	ldrb	r1, [r6, #2]
 800dc3a:	7391      	strb	r1, [r2, #14]
			}
			F_Buff[i + DIR_ATTR] = DIR_ATTR_MSK_ARCH;
 800dc3c:	2220      	movs	r2, #32
 800dc3e:	75ea      	strb	r2, [r5, #23]
			F_Buff[i + DIR_OWNER] = 0x2a;	// this works
 800dc40:	320a      	adds	r2, #10
 800dc42:	77aa      	strb	r2, [r5, #30]
			F_Buff[i + DIR_OWNER + 1] = 0x41;
 800dc44:	3217      	adds	r2, #23
 800dc46:	77ea      	strb	r2, [r5, #31]
			if(FAT16){
 800dc48:	791a      	ldrb	r2, [r3, #4]
 800dc4a:	b132      	cbz	r2, 800dc5a <New+0xf8>
				F_Buff[i + DIR16_PERM] = 0;
 800dc4c:	2200      	movs	r2, #0
 800dc4e:	f885 2020 	strb.w	r2, [r5, #32]
				F_Buff[i + DIR16_PERM + 1] = 0;
 800dc52:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21
			} else {
				F_Buff[i + DIR32_START_HI + 1] = (CurCluster >> 24) & 0xff;
				F_Buff[i + DIR32_START_HI] = (CurCluster >> 16) & 0xff;
			}
			if(FAT16){
				F_Buff[i + DIR16_STRT + 1] = (CurCluster >> 8) & 0xff;
 800dc56:	689b      	ldr	r3, [r3, #8]
 800dc58:	e006      	b.n	800dc68 <New+0x106>
			F_Buff[i + DIR_OWNER + 1] = 0x41;
			if(FAT16){
				F_Buff[i + DIR16_PERM] = 0;
				F_Buff[i + DIR16_PERM + 1] = 0;
			} else {
				F_Buff[i + DIR32_START_HI + 1] = (CurCluster >> 24) & 0xff;
 800dc5a:	689b      	ldr	r3, [r3, #8]
 800dc5c:	0e1a      	lsrs	r2, r3, #24
 800dc5e:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21
				F_Buff[i + DIR32_START_HI] = (CurCluster >> 16) & 0xff;
 800dc62:	0c1a      	lsrs	r2, r3, #16
 800dc64:	f885 2020 	strb.w	r2, [r5, #32]
				F_Buff[i + DIR16_STRT] = CurCluster & 0xff;
			} else {
				F_Buff[i + DIR32_STRT_LO + 1] = (CurCluster >> 8) & 0xff;
				F_Buff[i + DIR32_STRT_LO] = CurCluster & 0xff;
			}
			if (__MSD_WriteBlock(F_Buff, CurDir & ~(0x1FF), 512)){
 800dc68:	4c1c      	ldr	r4, [pc, #112]	; (800dcdc <New+0x17a>)
			}
			if(FAT16){
				F_Buff[i + DIR16_STRT + 1] = (CurCluster >> 8) & 0xff;
				F_Buff[i + DIR16_STRT] = CurCluster & 0xff;
			} else {
				F_Buff[i + DIR32_STRT_LO + 1] = (CurCluster >> 8) & 0xff;
 800dc6a:	0a1a      	lsrs	r2, r3, #8
				F_Buff[i + DIR32_STRT_LO] = CurCluster & 0xff;
			}
			if (__MSD_WriteBlock(F_Buff, CurDir & ~(0x1FF), 512)){
 800dc6c:	f8d4 121c 	ldr.w	r1, [r4, #540]	; 0x21c
			}
			if(FAT16){
				F_Buff[i + DIR16_STRT + 1] = (CurCluster >> 8) & 0xff;
				F_Buff[i + DIR16_STRT] = CurCluster & 0xff;
			} else {
				F_Buff[i + DIR32_STRT_LO + 1] = (CurCluster >> 8) & 0xff;
 800dc70:	f885 2027 	strb.w	r2, [r5, #39]	; 0x27
				F_Buff[i + DIR32_STRT_LO] = CurCluster & 0xff;
			}
			if (__MSD_WriteBlock(F_Buff, CurDir & ~(0x1FF), 512)){
 800dc74:	f421 71fe 	bic.w	r1, r1, #508	; 0x1fc
			if(FAT16){
				F_Buff[i + DIR16_STRT + 1] = (CurCluster >> 8) & 0xff;
				F_Buff[i + DIR16_STRT] = CurCluster & 0xff;
			} else {
				F_Buff[i + DIR32_STRT_LO + 1] = (CurCluster >> 8) & 0xff;
				F_Buff[i + DIR32_STRT_LO] = CurCluster & 0xff;
 800dc78:	f885 3026 	strb.w	r3, [r5, #38]	; 0x26
			}
			if (__MSD_WriteBlock(F_Buff, CurDir & ~(0x1FF), 512)){
 800dc7c:	f104 000c 	add.w	r0, r4, #12
 800dc80:	f021 0103 	bic.w	r1, r1, #3
 800dc84:	f44f 7200 	mov.w	r2, #512	; 0x200
 800dc88:	f7f6 fa46 	bl	8004118 <__MSD_WriteBlock>
 800dc8c:	4605      	mov	r5, r0
 800dc8e:	b118      	cbz	r0, 800dc98 <New+0x136>
				Display_Info("New() MSD_WriteBlock failed", CurDir);
 800dc90:	4819      	ldr	r0, [pc, #100]	; (800dcf8 <New+0x196>)
 800dc92:	f8d4 121c 	ldr.w	r1, [r4, #540]	; 0x21c
 800dc96:	e01c      	b.n	800dcd2 <New+0x170>
				return 0xff;
			}
			Display_Info("New() CurDir", CurDir);
 800dc98:	4818      	ldr	r0, [pc, #96]	; (800dcfc <New+0x19a>)
 800dc9a:	f8d4 121c 	ldr.w	r1, [r4, #540]	; 0x21c
 800dc9e:	f7ff fb32 	bl	800d306 <Display_Info>
			Display_Info("New() CurFileAddr", CurFileAddr);
 800dca2:	4817      	ldr	r0, [pc, #92]	; (800dd00 <New+0x19e>)
 800dca4:	f8d4 120c 	ldr.w	r1, [r4, #524]	; 0x20c
 800dca8:	f7ff fb2d 	bl	800d306 <Display_Info>
			Display_Info("New() CurCluster", CurCluster);
 800dcac:	4815      	ldr	r0, [pc, #84]	; (800dd04 <New+0x1a2>)
 800dcae:	68a1      	ldr	r1, [r4, #8]
 800dcb0:	f7ff fb29 	bl	800d306 <Display_Info>
			Cluster_Cnt = 0;
 800dcb4:	f8a4 5234 	strh.w	r5, [r4, #564]	; 0x234
 800dcb8:	4628      	mov	r0, r5
			return 0;
 800dcba:	e00d      	b.n	800dcd8 <New+0x176>
	if (FAT16){
		dirindex = Root_Addr;
	} else { // FAT32
		dirindex = FDT_Start;
	}
	for(blkcnt = 0; blkcnt < SecPerClus; blkcnt++){
 800dcbc:	3701      	adds	r7, #1
 800dcbe:	b2bf      	uxth	r7, r7
 800dcc0:	460c      	mov	r4, r1
 800dcc2:	4d06      	ldr	r5, [pc, #24]	; (800dcdc <New+0x17a>)
 800dcc4:	f8b5 321a 	ldrh.w	r3, [r5, #538]	; 0x21a
 800dcc8:	42bb      	cmp	r3, r7
 800dcca:	f63f af70 	bhi.w	800dbae <New+0x4c>
			Display_Info("New() CurCluster", CurCluster);
			Cluster_Cnt = 0;
			return 0;
		}	// for (i = 0; i < 512; i += 32)
	} 	// for(blkcnt = 0; blkcnt < SecPerClus; blkcnt++)
	Display_Info("Open() no file found", 0);
 800dcce:	480e      	ldr	r0, [pc, #56]	; (800dd08 <New+0x1a6>)
 800dcd0:	2100      	movs	r1, #0
 800dcd2:	f7ff fb18 	bl	800d306 <Display_Info>
 800dcd6:	20ff      	movs	r0, #255	; 0xff
	return 0xff;
}
 800dcd8:	e8bd 85fe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, sl, pc}
 800dcdc:	20004b54 	.word	0x20004b54
 800dce0:	08010a44 	.word	0x08010a44
 800dce4:	2000180c 	.word	0x2000180c
 800dce8:	08010a4a 	.word	0x08010a4a
 800dcec:	08010a59 	.word	0x08010a59
 800dcf0:	20004b60 	.word	0x20004b60
 800dcf4:	08010a74 	.word	0x08010a74
 800dcf8:	08010a8c 	.word	0x08010a8c
 800dcfc:	08010aa8 	.word	0x08010aa8
 800dd00:	08010ab5 	.word	0x08010ab5
 800dd04:	08010ac7 	.word	0x08010ac7
 800dd08:	08010ad8 	.word	0x08010ad8

0800dd0c <Open>:
Function Name : Open
Description : find and open file
Para :  name is filename, ext is extension part of name
*******************************************************************************/
u8 Open(uc8 *name, uc8 *ext)
{
 800dd0c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 800dd10:	4680      	mov	r8, r0
 800dd12:	468a      	mov	sl, r1
	u16  i, j;
	u32 dirindex;	// index on device for a directory structure
	u16  blkcnt;	// count of blocks read to fine end of a cluster

	Display_Info("Open()", 0);
 800dd14:	484e      	ldr	r0, [pc, #312]	; (800de50 <Open+0x144>)
 800dd16:	2100      	movs	r1, #0
 800dd18:	f7ff faf5 	bl	800d306 <Display_Info>
	if (SD_Card == FALSE){
 800dd1c:	4b4d      	ldr	r3, [pc, #308]	; (800de54 <Open+0x148>)
 800dd1e:	f893 0228 	ldrb.w	r0, [r3, #552]	; 0x228
 800dd22:	b940      	cbnz	r0, 800dd36 <Open+0x2a>
		__Display_Str(0, 0, RED, BKGND_COLOR, SD_Msgs[NoCard]);
 800dd24:	4b4c      	ldr	r3, [pc, #304]	; (800de58 <Open+0x14c>)
 800dd26:	4601      	mov	r1, r0
 800dd28:	68db      	ldr	r3, [r3, #12]
 800dd2a:	221f      	movs	r2, #31
 800dd2c:	9300      	str	r3, [sp, #0]
 800dd2e:	4603      	mov	r3, r0
 800dd30:	f7f6 f9fd 	bl	800412e <__Display_Str>
 800dd34:	e088      	b.n	800de48 <Open+0x13c>
		return (0xFF);
	}
	// FAT info is read when card inserted
	if (FAT16){
 800dd36:	791a      	ldrb	r2, [r3, #4]
 800dd38:	b112      	cbz	r2, 800dd40 <Open+0x34>
		dirindex = Root_Addr;
 800dd3a:	f8d3 4214 	ldr.w	r4, [r3, #532]	; 0x214
 800dd3e:	e001      	b.n	800dd44 <Open+0x38>
	} else { // FAT32
		dirindex = FDT_Start;
 800dd40:	f8d3 4224 	ldr.w	r4, [r3, #548]	; 0x224
 800dd44:	2700      	movs	r7, #0
 800dd46:	e076      	b.n	800de36 <Open+0x12a>
	}
	for(blkcnt = 0; blkcnt < SecPerClus; blkcnt++){
		Display_Info("Open() dirindex", dirindex);
 800dd48:	4844      	ldr	r0, [pc, #272]	; (800de5c <Open+0x150>)
 800dd4a:	4621      	mov	r1, r4
 800dd4c:	f7ff fadb 	bl	800d306 <Display_Info>
		if (__MSD_ReadBlock(F_Buff, dirindex & ~(0x1FF), 512)){
 800dd50:	f424 71fe 	bic.w	r1, r4, #508	; 0x1fc
 800dd54:	f105 000c 	add.w	r0, r5, #12
 800dd58:	f021 0103 	bic.w	r1, r1, #3
 800dd5c:	f44f 7200 	mov.w	r2, #512	; 0x200
 800dd60:	f7f6 f9dc 	bl	800411c <__MSD_ReadBlock>
 800dd64:	4606      	mov	r6, r0
 800dd66:	b110      	cbz	r0, 800dd6e <Open+0x62>
			Display_Info("Open() MSD_ReadBlock failed", dirindex);
 800dd68:	483d      	ldr	r0, [pc, #244]	; (800de60 <Open+0x154>)
 800dd6a:	4621      	mov	r1, r4
 800dd6c:	e06a      	b.n	800de44 <Open+0x138>
			return 0xff; // Read Sector fail
 800dd6e:	350c      	adds	r5, #12
		}
		for (i = 0; i < 512; i += 32, dirindex += 32){ // within current block
			if(F_Buff[i + DIR_ATTR] & 0x4E)
 800dd70:	7aeb      	ldrb	r3, [r5, #11]
	}
	for(blkcnt = 0; blkcnt < SecPerClus; blkcnt++){
		Display_Info("Open() dirindex", dirindex);
		if (__MSD_ReadBlock(F_Buff, dirindex & ~(0x1FF), 512)){
			Display_Info("Open() MSD_ReadBlock failed", dirindex);
			return 0xff; // Read Sector fail
 800dd72:	ea4f 1946 	mov.w	r9, r6, lsl #5
		}
		for (i = 0; i < 512; i += 32, dirindex += 32){ // within current block
			if(F_Buff[i + DIR_ATTR] & 0x4E)
 800dd76:	f013 0f4e 	tst.w	r3, #78	; 0x4e
 800dd7a:	d155      	bne.n	800de28 <Open+0x11c>
				continue; // skip directory, volume label, system,  hidden, read only
			if(strncmp(F_Buff + i, name, 8) == 0 && strncmp(F_Buff + i + 8, ext, 3) == 0)
 800dd7c:	4628      	mov	r0, r5
 800dd7e:	4641      	mov	r1, r8
 800dd80:	2208      	movs	r2, #8
 800dd82:	f002 f995 	bl	80100b0 <strncmp>
 800dd86:	2800      	cmp	r0, #0
 800dd88:	d14e      	bne.n	800de28 <Open+0x11c>
 800dd8a:	f105 0008 	add.w	r0, r5, #8
 800dd8e:	4651      	mov	r1, sl
 800dd90:	2203      	movs	r2, #3
 800dd92:	f002 f98d 	bl	80100b0 <strncmp>
 800dd96:	2800      	cmp	r0, #0
 800dd98:	d146      	bne.n	800de28 <Open+0x11c>
			{
				CurDir = dirindex;
 800dd9a:	4a2e      	ldr	r2, [pc, #184]	; (800de54 <Open+0x148>)
				CurFileSz = 0;	// reset file size to write from beginning
				//CurFileSz = (F_Buff[i + DIR_FILE_SZ + 3] << 24) +
				//	(F_Buff[i + DIR_FILE_SZ + 2] << 16) +
				//	(F_Buff[i + DIR_FILE_SZ + 1] << 8) +
				//	(F_Buff[i + DIR_FILE_SZ]);
				if (FAT16)
 800dd9c:	7915      	ldrb	r5, [r2, #4]
			if(F_Buff[i + DIR_ATTR] & 0x4E)
				continue; // skip directory, volume label, system,  hidden, read only
			if(strncmp(F_Buff + i, name, 8) == 0 && strncmp(F_Buff + i + 8, ext, 3) == 0)
			{
				CurDir = dirindex;
				CurFileSz = 0;	// reset file size to write from beginning
 800dd9e:	f8c2 022c 	str.w	r0, [r2, #556]	; 0x22c
		for (i = 0; i < 512; i += 32, dirindex += 32){ // within current block
			if(F_Buff[i + DIR_ATTR] & 0x4E)
				continue; // skip directory, volume label, system,  hidden, read only
			if(strncmp(F_Buff + i, name, 8) == 0 && strncmp(F_Buff + i + 8, ext, 3) == 0)
			{
				CurDir = dirindex;
 800dda2:	f8c2 421c 	str.w	r4, [r2, #540]	; 0x21c
 800dda6:	eb09 0302 	add.w	r3, r9, r2
 800ddaa:	f8b2 1218 	ldrh.w	r1, [r2, #536]	; 0x218
 800ddae:	f8b2 021a 	ldrh.w	r0, [r2, #538]	; 0x21a
				CurFileSz = 0;	// reset file size to write from beginning
				//CurFileSz = (F_Buff[i + DIR_FILE_SZ + 3] << 24) +
				//	(F_Buff[i + DIR_FILE_SZ + 2] << 16) +
				//	(F_Buff[i + DIR_FILE_SZ + 1] << 8) +
				//	(F_Buff[i + DIR_FILE_SZ]);
				if (FAT16)
 800ddb2:	b18d      	cbz	r5, 800ddd8 <Open+0xcc>
				{
					CurCluster = (F_Buff[i + DIR16_STRT + 1] << 8) + F_Buff[i + DIR16_STRT];
 800ddb4:	f893 c027 	ldrb.w	ip, [r3, #39]	; 0x27
 800ddb8:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
					CurFileAddr = Root_Addr + DirBlkNum * 512 + (CurCluster - 2) * SecPerClus * SectorSize;
 800ddbc:	4341      	muls	r1, r0
				//	(F_Buff[i + DIR_FILE_SZ + 2] << 16) +
				//	(F_Buff[i + DIR_FILE_SZ + 1] << 8) +
				//	(F_Buff[i + DIR_FILE_SZ]);
				if (FAT16)
				{
					CurCluster = (F_Buff[i + DIR16_STRT + 1] << 8) + F_Buff[i + DIR16_STRT];
 800ddbe:	eb03 230c 	add.w	r3, r3, ip, lsl #8
					CurFileAddr = Root_Addr + DirBlkNum * 512 + (CurCluster - 2) * SecPerClus * SectorSize;
 800ddc2:	f8d2 5214 	ldr.w	r5, [r2, #532]	; 0x214
 800ddc6:	f8b2 c210 	ldrh.w	ip, [r2, #528]	; 0x210
				//	(F_Buff[i + DIR_FILE_SZ + 2] << 16) +
				//	(F_Buff[i + DIR_FILE_SZ + 1] << 8) +
				//	(F_Buff[i + DIR_FILE_SZ]);
				if (FAT16)
				{
					CurCluster = (F_Buff[i + DIR16_STRT + 1] << 8) + F_Buff[i + DIR16_STRT];
 800ddca:	6093      	str	r3, [r2, #8]
					CurFileAddr = Root_Addr + DirBlkNum * 512 + (CurCluster - 2) * SecPerClus * SectorSize;
 800ddcc:	eb05 2c4c 	add.w	ip, r5, ip, lsl #9
 800ddd0:	3b02      	subs	r3, #2
 800ddd2:	fb03 c301 	mla	r3, r3, r1, ip
 800ddd6:	e015      	b.n	800de04 <Open+0xf8>
				}
				else
				{
					CurCluster = (F_Buff[i + DIR32_START_HI + 1] << 24) + (F_Buff[i + DIR32_START_HI] << 16)
 800ddd8:	f893 c020 	ldrb.w	ip, [r3, #32]
 800dddc:	f893 e021 	ldrb.w	lr, [r3, #33]	; 0x21
 800dde0:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 800dde4:	eb0c 6c0e 	add.w	ip, ip, lr, lsl #24
 800dde8:	f893 e026 	ldrb.w	lr, [r3, #38]	; 0x26
						+ (F_Buff[i + DIR32_STRT_LO + 1] << 8) + F_Buff[i + DIR32_STRT_LO];
					CurFileAddr = Root_Addr + (CurCluster - 2) * SecPerClus * SectorSize;
 800ddec:	4341      	muls	r1, r0
					CurCluster = (F_Buff[i + DIR16_STRT + 1] << 8) + F_Buff[i + DIR16_STRT];
					CurFileAddr = Root_Addr + DirBlkNum * 512 + (CurCluster - 2) * SecPerClus * SectorSize;
				}
				else
				{
					CurCluster = (F_Buff[i + DIR32_START_HI + 1] << 24) + (F_Buff[i + DIR32_START_HI] << 16)
 800ddee:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 800ddf2:	44f4      	add	ip, lr
 800ddf4:	eb0c 2303 	add.w	r3, ip, r3, lsl #8
						+ (F_Buff[i + DIR32_STRT_LO + 1] << 8) + F_Buff[i + DIR32_STRT_LO];
					CurFileAddr = Root_Addr + (CurCluster - 2) * SecPerClus * SectorSize;
 800ddf8:	f8d2 5214 	ldr.w	r5, [r2, #532]	; 0x214
					CurCluster = (F_Buff[i + DIR16_STRT + 1] << 8) + F_Buff[i + DIR16_STRT];
					CurFileAddr = Root_Addr + DirBlkNum * 512 + (CurCluster - 2) * SecPerClus * SectorSize;
				}
				else
				{
					CurCluster = (F_Buff[i + DIR32_START_HI + 1] << 24) + (F_Buff[i + DIR32_START_HI] << 16)
 800ddfc:	6093      	str	r3, [r2, #8]
						+ (F_Buff[i + DIR32_STRT_LO + 1] << 8) + F_Buff[i + DIR32_STRT_LO];
					CurFileAddr = Root_Addr + (CurCluster - 2) * SecPerClus * SectorSize;
 800ddfe:	3b02      	subs	r3, #2
 800de00:	fb03 5301 	mla	r3, r3, r1, r5
				}
				Display_Info("Open() CurDir", CurDir);
 800de04:	4621      	mov	r1, r4
				Display_Info("Open() CurFileAddr", CurFileAddr);
 800de06:	4c13      	ldr	r4, [pc, #76]	; (800de54 <Open+0x148>)
				}
				else
				{
					CurCluster = (F_Buff[i + DIR32_START_HI + 1] << 24) + (F_Buff[i + DIR32_START_HI] << 16)
						+ (F_Buff[i + DIR32_STRT_LO + 1] << 8) + F_Buff[i + DIR32_STRT_LO];
					CurFileAddr = Root_Addr + (CurCluster - 2) * SecPerClus * SectorSize;
 800de08:	f8c2 320c 	str.w	r3, [r2, #524]	; 0x20c
				}
				Display_Info("Open() CurDir", CurDir);
 800de0c:	4815      	ldr	r0, [pc, #84]	; (800de64 <Open+0x158>)
 800de0e:	f7ff fa7a 	bl	800d306 <Display_Info>
				Display_Info("Open() CurFileAddr", CurFileAddr);
 800de12:	4815      	ldr	r0, [pc, #84]	; (800de68 <Open+0x15c>)
 800de14:	f8d4 120c 	ldr.w	r1, [r4, #524]	; 0x20c
 800de18:	f7ff fa75 	bl	800d306 <Display_Info>
				Display_Info("Open() CurCluster", CurCluster);
 800de1c:	4813      	ldr	r0, [pc, #76]	; (800de6c <Open+0x160>)
 800de1e:	68a1      	ldr	r1, [r4, #8]
 800de20:	f7ff fa71 	bl	800d306 <Display_Info>
 800de24:	2000      	movs	r0, #0
				return 0;
 800de26:	e010      	b.n	800de4a <Open+0x13e>
		Display_Info("Open() dirindex", dirindex);
		if (__MSD_ReadBlock(F_Buff, dirindex & ~(0x1FF), 512)){
			Display_Info("Open() MSD_ReadBlock failed", dirindex);
			return 0xff; // Read Sector fail
		}
		for (i = 0; i < 512; i += 32, dirindex += 32){ // within current block
 800de28:	3601      	adds	r6, #1
 800de2a:	3420      	adds	r4, #32
 800de2c:	3520      	adds	r5, #32
 800de2e:	2e10      	cmp	r6, #16
 800de30:	d19e      	bne.n	800dd70 <Open+0x64>
	if (FAT16){
		dirindex = Root_Addr;
	} else { // FAT32
		dirindex = FDT_Start;
	}
	for(blkcnt = 0; blkcnt < SecPerClus; blkcnt++){
 800de32:	3701      	adds	r7, #1
 800de34:	b2bf      	uxth	r7, r7
 800de36:	4d07      	ldr	r5, [pc, #28]	; (800de54 <Open+0x148>)
 800de38:	f8b5 321a 	ldrh.w	r3, [r5, #538]	; 0x21a
 800de3c:	42bb      	cmp	r3, r7
 800de3e:	d883      	bhi.n	800dd48 <Open+0x3c>
				Display_Info("Open() CurCluster", CurCluster);
				return 0;
			}
		} // for (i = 0; i < 512; i += 32)
	}
	Display_Info("Open() no file found", 0);
 800de40:	480b      	ldr	r0, [pc, #44]	; (800de70 <Open+0x164>)
 800de42:	2100      	movs	r1, #0
 800de44:	f7ff fa5f 	bl	800d306 <Display_Info>
 800de48:	20ff      	movs	r0, #255	; 0xff
	return 0xff;
}
 800de4a:	e8bd 87fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, pc}
 800de4e:	bf00      	nop
 800de50:	08010aed 	.word	0x08010aed
 800de54:	20004b54 	.word	0x20004b54
 800de58:	2000180c 	.word	0x2000180c
 800de5c:	08010af4 	.word	0x08010af4
 800de60:	08010b04 	.word	0x08010b04
 800de64:	08010b20 	.word	0x08010b20
 800de68:	08010b2e 	.word	0x08010b2e
 800de6c:	08010b41 	.word	0x08010b41
 800de70:	08010ad8 	.word	0x08010ad8

0800de74 <Save_Spectrum_N42>:
/*******************************************************************************
 Function Name : Save_Spectrum_N42
 Description : stores spectrum on flash card in NIST N42 format
 *******************************************************************************/
void Save_Spectrum_N42(void)
{
 800de74:	b530      	push	{r4, r5, lr}
	int i;
	u32 *php, num;
	char  buf[12], n;
	bool neg = FALSE;

	if (Open("FILE0000","DAT") == 0){
 800de76:	4948      	ldr	r1, [pc, #288]	; (800df98 <Save_Spectrum_N42+0x124>)
/*******************************************************************************
 Function Name : Save_Spectrum_N42
 Description : stores spectrum on flash card in NIST N42 format
 *******************************************************************************/
void Save_Spectrum_N42(void)
{
 800de78:	b087      	sub	sp, #28
	int i;
	u32 *php, num;
	char  buf[12], n;
	bool neg = FALSE;

	if (Open("FILE0000","DAT") == 0){
 800de7a:	4848      	ldr	r0, [pc, #288]	; (800df9c <Save_Spectrum_N42+0x128>)
 800de7c:	f7ff ff46 	bl	800dd0c <Open>
 800de80:	4601      	mov	r1, r0
 800de82:	b940      	cbnz	r0, 800de96 <Save_Spectrum_N42+0x22>
		__Display_Str(22 * CHAR_WIDTH, 0, TXT_COLOR, BKGND_COLOR, SD_Msgs[NoFile]);
 800de84:	4b46      	ldr	r3, [pc, #280]	; (800dfa0 <Save_Spectrum_N42+0x12c>)
 800de86:	30b0      	adds	r0, #176	; 0xb0
 800de88:	685b      	ldr	r3, [r3, #4]
 800de8a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800de8e:	9300      	str	r3, [sp, #0]
 800de90:	460b      	mov	r3, r1
 800de92:	f7f6 f94c 	bl	800412e <__Display_Str>
	}

	W_Strng( "<Measurement>\n");
 800de96:	4843      	ldr	r0, [pc, #268]	; (800dfa4 <Save_Spectrum_N42+0x130>)
 800de98:	f7ff fe5a 	bl	800db50 <W_Strng>
	W_Strng( "    <Remarks>\n");
 800de9c:	4842      	ldr	r0, [pc, #264]	; (800dfa8 <Save_Spectrum_N42+0x134>)
 800de9e:	f7ff fe57 	bl	800db50 <W_Strng>
	W_Strng( "    <Remarks>\n");
 800dea2:	4841      	ldr	r0, [pc, #260]	; (800dfa8 <Save_Spectrum_N42+0x134>)
 800dea4:	f7ff fe54 	bl	800db50 <W_Strng>
	W_Strng( "    \n");
 800dea8:	4840      	ldr	r0, [pc, #256]	; (800dfac <Save_Spectrum_N42+0x138>)
 800deaa:	f7ff fe51 	bl	800db50 <W_Strng>
	W_Strng( "    <InstrumentInformation>\n");
 800deae:	4840      	ldr	r0, [pc, #256]	; (800dfb0 <Save_Spectrum_N42+0x13c>)
 800deb0:	f7ff fe4e 	bl	800db50 <W_Strng>
	W_Strng( "        <InstrumentType>\n");
 800deb4:	483f      	ldr	r0, [pc, #252]	; (800dfb4 <Save_Spectrum_N42+0x140>)
 800deb6:	f7ff fe4b 	bl	800db50 <W_Strng>
	W_Strng( "        </InstrumentType>\n");
 800deba:	483f      	ldr	r0, [pc, #252]	; (800dfb8 <Save_Spectrum_N42+0x144>)
 800debc:	f7ff fe48 	bl	800db50 <W_Strng>
	W_Strng( "        <Manufacturer>\n");
 800dec0:	483e      	ldr	r0, [pc, #248]	; (800dfbc <Save_Spectrum_N42+0x148>)
 800dec2:	f7ff fe45 	bl	800db50 <W_Strng>
	W_Strng( "        </Manufacturer>\n");
 800dec6:	483e      	ldr	r0, [pc, #248]	; (800dfc0 <Save_Spectrum_N42+0x14c>)
 800dec8:	f7ff fe42 	bl	800db50 <W_Strng>
	W_Strng( "        <InstrumentModel>\n");
 800decc:	483d      	ldr	r0, [pc, #244]	; (800dfc4 <Save_Spectrum_N42+0x150>)
 800dece:	f7ff fe3f 	bl	800db50 <W_Strng>
	W_Strng( "        </InstrumentModel>\n");
 800ded2:	483d      	ldr	r0, [pc, #244]	; (800dfc8 <Save_Spectrum_N42+0x154>)
 800ded4:	f7ff fe3c 	bl	800db50 <W_Strng>
	W_Strng(  "        <InstrumentID>\n");
 800ded8:	483c      	ldr	r0, [pc, #240]	; (800dfcc <Save_Spectrum_N42+0x158>)
 800deda:	f7ff fe39 	bl	800db50 <W_Strng>
	W_Strng( "        </InstrumentID>\n");
 800dede:	483c      	ldr	r0, [pc, #240]	; (800dfd0 <Save_Spectrum_N42+0x15c>)
 800dee0:	f7ff fe36 	bl	800db50 <W_Strng>
	W_Strng( "    </InstrumentInformation>\n");
 800dee4:	483b      	ldr	r0, [pc, #236]	; (800dfd4 <Save_Spectrum_N42+0x160>)
 800dee6:	f7ff fe33 	bl	800db50 <W_Strng>
	W_Strng( "    <MeasuredItemInformation>\n");
 800deea:	483b      	ldr	r0, [pc, #236]	; (800dfd8 <Save_Spectrum_N42+0x164>)
 800deec:	f7ff fe30 	bl	800db50 <W_Strng>
	W_Strng( "        <MeasurementLocation>\n");
 800def0:	483a      	ldr	r0, [pc, #232]	; (800dfdc <Save_Spectrum_N42+0x168>)
 800def2:	f7ff fe2d 	bl	800db50 <W_Strng>
	W_Strng( "            <Coordinates>\n");        // The spec calls for coordinates inside the braces
 800def6:	483a      	ldr	r0, [pc, #232]	; (800dfe0 <Save_Spectrum_N42+0x16c>)
 800def8:	f7ff fe2a 	bl	800db50 <W_Strng>
	W_Strng( "            </Coordinates>\n");
 800defc:	4839      	ldr	r0, [pc, #228]	; (800dfe4 <Save_Spectrum_N42+0x170>)
 800defe:	f7ff fe27 	bl	800db50 <W_Strng>
	W_Strng( "        </MeasurementLocation>\n");
 800df02:	4839      	ldr	r0, [pc, #228]	; (800dfe8 <Save_Spectrum_N42+0x174>)
 800df04:	f7ff fe24 	bl	800db50 <W_Strng>
	W_Strng( "    </MeasuredItemInformation>\n");
 800df08:	4838      	ldr	r0, [pc, #224]	; (800dfec <Save_Spectrum_N42+0x178>)
 800df0a:	f7ff fe21 	bl	800db50 <W_Strng>
	W_Strng( "    <Spectrum>\n");
 800df0e:	4838      	ldr	r0, [pc, #224]	; (800dff0 <Save_Spectrum_N42+0x17c>)
 800df10:	f7ff fe1e 	bl	800db50 <W_Strng>
	W_Strng( "        <StartTime>\n");
 800df14:	4837      	ldr	r0, [pc, #220]	; (800dff4 <Save_Spectrum_N42+0x180>)
 800df16:	f7ff fe1b 	bl	800db50 <W_Strng>
	//W_Strng( "        " << samp.sampleDateTime.toString(Qt::ISODate) << endl;
	W_Strng( "        </StartTime>\n");
 800df1a:	4837      	ldr	r0, [pc, #220]	; (800dff8 <Save_Spectrum_N42+0x184>)
 800df1c:	f7ff fe18 	bl	800db50 <W_Strng>
	W_Strng( "        <RealTime>\n");
 800df20:	4836      	ldr	r0, [pc, #216]	; (800dffc <Save_Spectrum_N42+0x188>)
 800df22:	f7ff fe15 	bl	800db50 <W_Strng>
	//W_Strng( "            " << str.setNum(samp.realTime, 'f', 1) << endl;
	W_Strng( "        </RealTime>\n");
 800df26:	4836      	ldr	r0, [pc, #216]	; (800e000 <Save_Spectrum_N42+0x18c>)
 800df28:	f7ff fe12 	bl	800db50 <W_Strng>
	W_Strng( "        <LiveTime>\n");
 800df2c:	4835      	ldr	r0, [pc, #212]	; (800e004 <Save_Spectrum_N42+0x190>)
 800df2e:	f7ff fe0f 	bl	800db50 <W_Strng>
	//W_Strng( "            " << str.setNum(samp.liveTime, 'f', 1) << endl;
	W_Strng( "        </LiveTime>\n");
 800df32:	4835      	ldr	r0, [pc, #212]	; (800e008 <Save_Spectrum_N42+0x194>)
 800df34:	f7ff fe0c 	bl	800db50 <W_Strng>
	W_Strng( "        <Calibration>\n");
 800df38:	4834      	ldr	r0, [pc, #208]	; (800e00c <Save_Spectrum_N42+0x198>)
 800df3a:	f7ff fe09 	bl	800db50 <W_Strng>
	W_Strng( "            <Equation>\n");
 800df3e:	4834      	ldr	r0, [pc, #208]	; (800e010 <Save_Spectrum_N42+0x19c>)
 800df40:	f7ff fe06 	bl	800db50 <W_Strng>
	W_Strng( "            </Equation>\n");
 800df44:	4833      	ldr	r0, [pc, #204]	; (800e014 <Save_Spectrum_N42+0x1a0>)
 800df46:	f7ff fe03 	bl	800db50 <W_Strng>
	W_Strng( "        </Calibration>\n");
 800df4a:	4833      	ldr	r0, [pc, #204]	; (800e018 <Save_Spectrum_N42+0x1a4>)
 800df4c:	f7ff fe00 	bl	800db50 <W_Strng>
	W_Strng( "        <ChannelData>\n");
 800df50:	4832      	ldr	r0, [pc, #200]	; (800e01c <Save_Spectrum_N42+0x1a8>)
 800df52:	f7ff fdfd 	bl	800db50 <W_Strng>
 800df56:	2400      	movs	r4, #0
	for(php = &pulse_height[0], i = MAX_CHANNELS; i > 0; i--){
		num = *php++;
		Unsigned_To_Dec_Str(buf, U32_DIGITS, num);
 800df58:	4b31      	ldr	r3, [pc, #196]	; (800e020 <Save_Spectrum_N42+0x1ac>)
 800df5a:	ad03      	add	r5, sp, #12
 800df5c:	58e2      	ldr	r2, [r4, r3]
 800df5e:	210c      	movs	r1, #12
 800df60:	4628      	mov	r0, r5
 800df62:	f000 f953 	bl	800e20c <Unsigned_To_Dec_Str>
		buf[U32_DIGITS+1] = 0;
 800df66:	2300      	movs	r3, #0
		W_Strng( "            ");
 800df68:	482e      	ldr	r0, [pc, #184]	; (800e024 <Save_Spectrum_N42+0x1b0>)
	W_Strng( "        </Calibration>\n");
	W_Strng( "        <ChannelData>\n");
	for(php = &pulse_height[0], i = MAX_CHANNELS; i > 0; i--){
		num = *php++;
		Unsigned_To_Dec_Str(buf, U32_DIGITS, num);
		buf[U32_DIGITS+1] = 0;
 800df6a:	f88d 3019 	strb.w	r3, [sp, #25]
		W_Strng( "            ");
		W_Strng(buf);
 800df6e:	3404      	adds	r4, #4
	W_Strng( "        <ChannelData>\n");
	for(php = &pulse_height[0], i = MAX_CHANNELS; i > 0; i--){
		num = *php++;
		Unsigned_To_Dec_Str(buf, U32_DIGITS, num);
		buf[U32_DIGITS+1] = 0;
		W_Strng( "            ");
 800df70:	f7ff fdee 	bl	800db50 <W_Strng>
		W_Strng(buf);
 800df74:	4628      	mov	r0, r5
 800df76:	f7ff fdeb 	bl	800db50 <W_Strng>
	W_Strng( "        <Calibration>\n");
	W_Strng( "            <Equation>\n");
	W_Strng( "            </Equation>\n");
	W_Strng( "        </Calibration>\n");
	W_Strng( "        <ChannelData>\n");
	for(php = &pulse_height[0], i = MAX_CHANNELS; i > 0; i--){
 800df7a:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
 800df7e:	d1eb      	bne.n	800df58 <Save_Spectrum_N42+0xe4>
		Unsigned_To_Dec_Str(buf, U32_DIGITS, num);
		buf[U32_DIGITS+1] = 0;
		W_Strng( "            ");
		W_Strng(buf);
	}
	W_Strng( "        </ChannelData>\n");
 800df80:	4829      	ldr	r0, [pc, #164]	; (800e028 <Save_Spectrum_N42+0x1b4>)
 800df82:	f7ff fde5 	bl	800db50 <W_Strng>
	W_Strng( "    </Spectrum>\n");
 800df86:	4829      	ldr	r0, [pc, #164]	; (800e02c <Save_Spectrum_N42+0x1b8>)
 800df88:	f7ff fde2 	bl	800db50 <W_Strng>
	W_Strng( "</Measurement>\n");
 800df8c:	4828      	ldr	r0, [pc, #160]	; (800e030 <Save_Spectrum_N42+0x1bc>)
 800df8e:	f7ff fddf 	bl	800db50 <W_Strng>
}
 800df92:	b007      	add	sp, #28
 800df94:	bd30      	pop	{r4, r5, pc}
 800df96:	bf00      	nop
 800df98:	08010b5c 	.word	0x08010b5c
 800df9c:	08010b53 	.word	0x08010b53
 800dfa0:	2000180c 	.word	0x2000180c
 800dfa4:	08010b60 	.word	0x08010b60
 800dfa8:	08010b6f 	.word	0x08010b6f
 800dfac:	08010b7e 	.word	0x08010b7e
 800dfb0:	08010b84 	.word	0x08010b84
 800dfb4:	08010ba1 	.word	0x08010ba1
 800dfb8:	08010bbb 	.word	0x08010bbb
 800dfbc:	08010bd6 	.word	0x08010bd6
 800dfc0:	08010bee 	.word	0x08010bee
 800dfc4:	08010c07 	.word	0x08010c07
 800dfc8:	08010c22 	.word	0x08010c22
 800dfcc:	08010c3e 	.word	0x08010c3e
 800dfd0:	08010c56 	.word	0x08010c56
 800dfd4:	08010c6f 	.word	0x08010c6f
 800dfd8:	08010c8d 	.word	0x08010c8d
 800dfdc:	08010cac 	.word	0x08010cac
 800dfe0:	08010ccb 	.word	0x08010ccb
 800dfe4:	08010ce6 	.word	0x08010ce6
 800dfe8:	08010d02 	.word	0x08010d02
 800dfec:	08010d22 	.word	0x08010d22
 800dff0:	08010d42 	.word	0x08010d42
 800dff4:	08010d52 	.word	0x08010d52
 800dff8:	08010d67 	.word	0x08010d67
 800dffc:	08010d7d 	.word	0x08010d7d
 800e000:	08010d91 	.word	0x08010d91
 800e004:	08010da6 	.word	0x08010da6
 800e008:	08010dba 	.word	0x08010dba
 800e00c:	08010dcf 	.word	0x08010dcf
 800e010:	08010de6 	.word	0x08010de6
 800e014:	08010dfe 	.word	0x08010dfe
 800e018:	08010e17 	.word	0x08010e17
 800e01c:	08010e2f 	.word	0x08010e2f
 800e020:	20001848 	.word	0x20001848
 800e024:	08011027 	.word	0x08011027
 800e028:	08010e46 	.word	0x08010e46
 800e02c:	08010e5e 	.word	0x08010e5e
 800e030:	08010e6f 	.word	0x08010e6f

0800e034 <Save_Spectrum_CSV>:
 Description : stores spectrum on flash card as comma separated values
 *******************************************************************************/

// note that msd code returns a non-zero value on error
void Save_Spectrum_CSV(void)
{
 800e034:	b530      	push	{r4, r5, lr}
 800e036:	b089      	sub	sp, #36	; 0x24
	u16 i,n;
	u32 *php, num;
	char  buf[17], *charp;
	bool neg = FALSE;

	strcpy(buf, "SPECT000");
 800e038:	ac03      	add	r4, sp, #12
 800e03a:	493b      	ldr	r1, [pc, #236]	; (800e128 <Save_Spectrum_CSV+0xf4>)
 800e03c:	4620      	mov	r0, r4
 800e03e:	f001 ffa9 	bl	800ff94 <strcpy>

	n = confp->pha_file_seq;
 800e042:	4b3a      	ldr	r3, [pc, #232]	; (800e12c <Save_Spectrum_CSV+0xf8>)
	buf[8] = NULL;
	buf[7] = hex_conv[n % 10];
 800e044:	4a3a      	ldr	r2, [pc, #232]	; (800e130 <Save_Spectrum_CSV+0xfc>)
	char  buf[17], *charp;
	bool neg = FALSE;

	strcpy(buf, "SPECT000");

	n = confp->pha_file_seq;
 800e046:	681b      	ldr	r3, [r3, #0]
	buf[8] = NULL;
	buf[7] = hex_conv[n % 10];
 800e048:	6811      	ldr	r1, [r2, #0]
	char  buf[17], *charp;
	bool neg = FALSE;

	strcpy(buf, "SPECT000");

	n = confp->pha_file_seq;
 800e04a:	8f18      	ldrh	r0, [r3, #56]	; 0x38
	buf[8] = NULL;
	buf[7] = hex_conv[n % 10];
 800e04c:	220a      	movs	r2, #10
 800e04e:	fbb0 fcf2 	udiv	ip, r0, r2
 800e052:	fb02 001c 	mls	r0, r2, ip, r0
	bool neg = FALSE;

	strcpy(buf, "SPECT000");

	n = confp->pha_file_seq;
	buf[8] = NULL;
 800e056:	2500      	movs	r5, #0
 800e058:	f88d 5014 	strb.w	r5, [sp, #20]
	buf[7] = hex_conv[n % 10];
 800e05c:	b280      	uxth	r0, r0
 800e05e:	5c08      	ldrb	r0, [r1, r0]
	n /= 10;
 800e060:	fa1f fc8c 	uxth.w	ip, ip

	strcpy(buf, "SPECT000");

	n = confp->pha_file_seq;
	buf[8] = NULL;
	buf[7] = hex_conv[n % 10];
 800e064:	f88d 0013 	strb.w	r0, [sp, #19]
	n /= 10;
	buf[6] = hex_conv[n % 10];
 800e068:	fbbc f0f2 	udiv	r0, ip, r2
 800e06c:	fb02 cc10 	mls	ip, r2, r0, ip
 800e070:	fa1f fc8c 	uxth.w	ip, ip
 800e074:	f811 c00c 	ldrb.w	ip, [r1, ip]
 800e078:	f88d c012 	strb.w	ip, [sp, #18]
	n /= 10;
	buf[5] = hex_conv[n % 10];
 800e07c:	fbb0 fcf2 	udiv	ip, r0, r2
 800e080:	fb0c 0212 	mls	r2, ip, r2, r0
 800e084:	b292      	uxth	r2, r2
 800e086:	5c8a      	ldrb	r2, [r1, r2]
	Display_Info( buf, confp->pha_file_seq);
 800e088:	4620      	mov	r0, r4
	buf[8] = NULL;
	buf[7] = hex_conv[n % 10];
	n /= 10;
	buf[6] = hex_conv[n % 10];
	n /= 10;
	buf[5] = hex_conv[n % 10];
 800e08a:	f88d 2011 	strb.w	r2, [sp, #17]
	Display_Info( buf, confp->pha_file_seq);
 800e08e:	8f19      	ldrh	r1, [r3, #56]	; 0x38
 800e090:	f7ff f939 	bl	800d306 <Display_Info>
	if (Open(buf,"CSV")){
 800e094:	4620      	mov	r0, r4
 800e096:	4927      	ldr	r1, [pc, #156]	; (800e134 <Save_Spectrum_CSV+0x100>)
 800e098:	f7ff fe38 	bl	800dd0c <Open>
 800e09c:	b170      	cbz	r0, 800e0bc <Save_Spectrum_CSV+0x88>
		if (New(buf,"CSV")){
 800e09e:	4620      	mov	r0, r4
 800e0a0:	4924      	ldr	r1, [pc, #144]	; (800e134 <Save_Spectrum_CSV+0x100>)
 800e0a2:	f7ff fd5e 	bl	800db62 <New>
 800e0a6:	b148      	cbz	r0, 800e0bc <Save_Spectrum_CSV+0x88>
			__Display_Str(0, 0, RED, BKGND_COLOR, SD_Msgs[NoFile]);
 800e0a8:	4b23      	ldr	r3, [pc, #140]	; (800e138 <Save_Spectrum_CSV+0x104>)
 800e0aa:	4628      	mov	r0, r5
 800e0ac:	685b      	ldr	r3, [r3, #4]
 800e0ae:	4629      	mov	r1, r5
 800e0b0:	9300      	str	r3, [sp, #0]
 800e0b2:	221f      	movs	r2, #31
 800e0b4:	462b      	mov	r3, r5
 800e0b6:	f7f6 f83a 	bl	800412e <__Display_Str>
			return;
 800e0ba:	e033      	b.n	800e124 <Save_Spectrum_CSV+0xf0>
		}
	}
	W_Strng("Gamma Grapher Version 2,\n");
 800e0bc:	481f      	ldr	r0, [pc, #124]	; (800e13c <Save_Spectrum_CSV+0x108>)
 800e0be:	f7ff fd47 	bl	800db50 <W_Strng>
	W_Strng("Comma Separated Values,\n");
 800e0c2:	481f      	ldr	r0, [pc, #124]	; (800e140 <Save_Spectrum_CSV+0x10c>)
 800e0c4:	f7ff fd44 	bl	800db50 <W_Strng>
 800e0c8:	2400      	movs	r4, #0
	for(php = &pulse_height[0], i = 0; i < MAX_CHANNELS; i++){
		memset(buf, ' ', 16);
 800e0ca:	ad03      	add	r5, sp, #12
 800e0cc:	2120      	movs	r1, #32
 800e0ce:	2210      	movs	r2, #16
 800e0d0:	4628      	mov	r0, r5
 800e0d2:	f001 fef5 	bl	800fec0 <memset>
		charp = buf;
		num = *php++;
		//Unsigned_To_Dec_Str(charp, U32_DIGITS, (u32) i);
		//charp += U32_DIGITS;
		//charp++ = ',';
		Unsigned_To_Dec_Str(charp, U32_DIGITS, num);
 800e0d6:	4b1b      	ldr	r3, [pc, #108]	; (800e144 <Save_Spectrum_CSV+0x110>)
 800e0d8:	210c      	movs	r1, #12
 800e0da:	58e2      	ldr	r2, [r4, r3]
 800e0dc:	4628      	mov	r0, r5
 800e0de:	f000 f895 	bl	800e20c <Unsigned_To_Dec_Str>
		charp += U32_DIGITS;
		*charp++ = ',';
 800e0e2:	232c      	movs	r3, #44	; 0x2c
 800e0e4:	f88d 3018 	strb.w	r3, [sp, #24]
		*charp++ = '\n';
 800e0e8:	3b22      	subs	r3, #34	; 0x22
 800e0ea:	f88d 3019 	strb.w	r3, [sp, #25]
		*charp++ = NULL;
		W_Strng(buf);
 800e0ee:	4628      	mov	r0, r5
		//charp++ = ',';
		Unsigned_To_Dec_Str(charp, U32_DIGITS, num);
		charp += U32_DIGITS;
		*charp++ = ',';
		*charp++ = '\n';
		*charp++ = NULL;
 800e0f0:	3b0a      	subs	r3, #10
		W_Strng(buf);
 800e0f2:	3404      	adds	r4, #4
		//charp++ = ',';
		Unsigned_To_Dec_Str(charp, U32_DIGITS, num);
		charp += U32_DIGITS;
		*charp++ = ',';
		*charp++ = '\n';
		*charp++ = NULL;
 800e0f4:	f88d 301a 	strb.w	r3, [sp, #26]
		W_Strng(buf);
 800e0f8:	f7ff fd2a 	bl	800db50 <W_Strng>
			return;
		}
	}
	W_Strng("Gamma Grapher Version 2,\n");
	W_Strng("Comma Separated Values,\n");
	for(php = &pulse_height[0], i = 0; i < MAX_CHANNELS; i++){
 800e0fc:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
 800e100:	d1e3      	bne.n	800e0ca <Save_Spectrum_CSV+0x96>
		*charp++ = '\n';
		*charp++ = NULL;
		W_Strng(buf);
	}
	Close();
	confp->pha_file_seq++;
 800e102:	4c0a      	ldr	r4, [pc, #40]	; (800e12c <Save_Spectrum_CSV+0xf8>)
		*charp++ = ',';
		*charp++ = '\n';
		*charp++ = NULL;
		W_Strng(buf);
	}
	Close();
 800e104:	f7ff fae8 	bl	800d6d8 <Close>
	confp->pha_file_seq++;
 800e108:	6823      	ldr	r3, [r4, #0]
 800e10a:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 800e10c:	3201      	adds	r2, #1
 800e10e:	871a      	strh	r2, [r3, #56]	; 0x38
	Write_Config();
 800e110:	f000 f9e8 	bl	800e4e4 <Write_Config>
	if(confp->debug_level < 1)
 800e114:	6823      	ldr	r3, [r4, #0]
 800e116:	f9b3 2064 	ldrsh.w	r2, [r3, #100]	; 0x64
 800e11a:	2a00      	cmp	r2, #0
 800e11c:	dc02      	bgt.n	800e124 <Save_Spectrum_CSV+0xf0>
		Display_Menu(confp->menu_index);
 800e11e:	8898      	ldrh	r0, [r3, #4]
 800e120:	f000 fa5e 	bl	800e5e0 <Display_Menu>
}
 800e124:	b009      	add	sp, #36	; 0x24
 800e126:	bd30      	pop	{r4, r5, pc}
 800e128:	08010e7f 	.word	0x08010e7f
 800e12c:	20001800 	.word	0x20001800
 800e130:	20001828 	.word	0x20001828
 800e134:	08010e88 	.word	0x08010e88
 800e138:	2000180c 	.word	0x2000180c
 800e13c:	08010e8c 	.word	0x08010e8c
 800e140:	08010ea6 	.word	0x08010ea6
 800e144:	20001848 	.word	0x20001848

0800e148 <Ring_Buf_Empty>:
/*******************************************************************************
 Function Name : Ring_Buf_Empty
 Description : Returns TRUE if buffer is empty
*******************************************************************************/
bool Ring_Buf_Empty(RingBuf *rbp)
{
 800e148:	f8b0 2400 	ldrh.w	r2, [r0, #1024]	; 0x400
 800e14c:	f8b0 3402 	ldrh.w	r3, [r0, #1026]	; 0x402
	// empty when out points to empty in position
	return (rbp->In == rbp->Out);
}
 800e150:	429a      	cmp	r2, r3
 800e152:	bf14      	ite	ne
 800e154:	2000      	movne	r0, #0
 800e156:	2001      	moveq	r0, #1
 800e158:	4770      	bx	lr

0800e15a <Ring_Buf_Get>:
 Function Name : Ring_Buf_Get
 Description : Get int from ring buffer, return FALSE if buffer is empty
*******************************************************************************/
bool Ring_Buf_Get(RingBuf *rbp, s16 *valp)
{
	if (rbp->In == rbp->Out) return FALSE;
 800e15a:	f8b0 3402 	ldrh.w	r3, [r0, #1026]	; 0x402
 800e15e:	f8b0 2400 	ldrh.w	r2, [r0, #1024]	; 0x400
 800e162:	429a      	cmp	r2, r3
 800e164:	d101      	bne.n	800e16a <Ring_Buf_Get+0x10>
 800e166:	2000      	movs	r0, #0
 800e168:	4770      	bx	lr
	else {
		*valp = rbp->Buffer[rbp->Out++];
 800e16a:	f830 2013 	ldrh.w	r2, [r0, r3, lsl #1]
 800e16e:	3301      	adds	r3, #1
 800e170:	b29b      	uxth	r3, r3
		if(rbp->Out >= BUFFER_SIZE) rbp->Out = 0;
 800e172:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
*******************************************************************************/
bool Ring_Buf_Get(RingBuf *rbp, s16 *valp)
{
	if (rbp->In == rbp->Out) return FALSE;
	else {
		*valp = rbp->Buffer[rbp->Out++];
 800e176:	800a      	strh	r2, [r1, #0]
 800e178:	f8a0 3402 	strh.w	r3, [r0, #1026]	; 0x402
		if(rbp->Out >= BUFFER_SIZE) rbp->Out = 0;
 800e17c:	d201      	bcs.n	800e182 <Ring_Buf_Get+0x28>
 800e17e:	2001      	movs	r0, #1
 800e180:	4770      	bx	lr
 800e182:	f04f 0300 	mov.w	r3, #0
 800e186:	f8a0 3402 	strh.w	r3, [r0, #1026]	; 0x402
 800e18a:	2001      	movs	r0, #1
		return TRUE;
	}
}
 800e18c:	4770      	bx	lr

0800e18e <Ring_Buf_Full>:
 Description : Returns TRUE if buffer is full
*******************************************************************************/
bool Ring_Buf_Full(RingBuf *rbp)
{
	u16 index;
	index = rbp->In;
 800e18e:	f8b0 3400 	ldrh.w	r3, [r0, #1024]	; 0x400
	index++;
	if(index >= BUFFER_SIZE) index = 0;
 800e192:	f8b0 0402 	ldrh.w	r0, [r0, #1026]	; 0x402
*******************************************************************************/
bool Ring_Buf_Full(RingBuf *rbp)
{
	u16 index;
	index = rbp->In;
	index++;
 800e196:	3301      	adds	r3, #1
 800e198:	b29b      	uxth	r3, r3
	if(index >= BUFFER_SIZE) index = 0;
 800e19a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800e19e:	bf28      	it	cs
 800e1a0:	2300      	movcs	r3, #0
	// return TRUE if another puting another value would overflow
	return(index == rbp->Out);
}
 800e1a2:	4298      	cmp	r0, r3
 800e1a4:	bf14      	ite	ne
 800e1a6:	2000      	movne	r0, #0
 800e1a8:	2001      	moveq	r0, #1
 800e1aa:	4770      	bx	lr

0800e1ac <Ring_Buf_Put>:
*******************************************************************************/
bool Ring_Buf_Put(RingBuf *rbp, s16 val)
{
	u16 index;
	// in points to next empty location
	index = rbp->In;
 800e1ac:	f8b0 2400 	ldrh.w	r2, [r0, #1024]	; 0x400
	index++;
	if(index >= BUFFER_SIZE) index = 0;
	// return FALSE if another putting another value would overflow
	if(index == rbp->Out)
 800e1b0:	f8b0 c402 	ldrh.w	ip, [r0, #1026]	; 0x402
bool Ring_Buf_Put(RingBuf *rbp, s16 val)
{
	u16 index;
	// in points to next empty location
	index = rbp->In;
	index++;
 800e1b4:	1c53      	adds	r3, r2, #1
 800e1b6:	b29b      	uxth	r3, r3
	if(index >= BUFFER_SIZE) index = 0;
 800e1b8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800e1bc:	bf28      	it	cs
 800e1be:	2300      	movcs	r3, #0
	// return FALSE if another putting another value would overflow
	if(index == rbp->Out)
 800e1c0:	459c      	cmp	ip, r3
 800e1c2:	d101      	bne.n	800e1c8 <Ring_Buf_Put+0x1c>
 800e1c4:	2000      	movs	r0, #0
 800e1c6:	4770      	bx	lr
		return FALSE;
	else {
		rbp->Buffer[rbp->In] = val;
 800e1c8:	f820 1012 	strh.w	r1, [r0, r2, lsl #1]
		rbp->In = index;
 800e1cc:	f8a0 3400 	strh.w	r3, [r0, #1024]	; 0x400
 800e1d0:	2001      	movs	r0, #1
		return TRUE;
	}
}
 800e1d2:	4770      	bx	lr

0800e1d4 <Unsigned_To_Hex_Str>:
	buf: pointer to string buffer
	width:  number of characters to be displayed, not including null terminator
	num: number to be displayed, cast to u32 or s32
*******************************************************************************/

void Unsigned_To_Hex_Str(char *buf, u8 width, u32 num){
 800e1d4:	b510      	push	{r4, lr}
 800e1d6:	2300      	movs	r3, #0
	char i, n;

	for(n = 0; n < width; n++)
 800e1d8:	e004      	b.n	800e1e4 <Unsigned_To_Hex_Str+0x10>
		buf[n] = ' ';
 800e1da:	f04f 0c20 	mov.w	ip, #32
 800e1de:	f800 c003 	strb.w	ip, [r0, r3]
 800e1e2:	3301      	adds	r3, #1
*******************************************************************************/

void Unsigned_To_Hex_Str(char *buf, u8 width, u32 num){
	char i, n;

	for(n = 0; n < width; n++)
 800e1e4:	fa5f fc83 	uxtb.w	ip, r3
 800e1e8:	458c      	cmp	ip, r1
 800e1ea:	d3f6      	bcc.n	800e1da <Unsigned_To_Hex_Str+0x6>
		buf[n] = ' ';
	n = width - 1;  // start index at far right of field
 800e1ec:	3901      	subs	r1, #1
 800e1ee:	b2c9      	uxtb	r1, r1
	i = 0;
	do {  // isolate each decimal digit
		buf[n--] = hex_conv[(num & 0xF)];  // convert to text
 800e1f0:	4c05      	ldr	r4, [pc, #20]	; (800e208 <Unsigned_To_Hex_Str+0x34>)
 800e1f2:	f002 030f 	and.w	r3, r2, #15
 800e1f6:	6824      	ldr	r4, [r4, #0]
 800e1f8:	5ce3      	ldrb	r3, [r4, r3]
 800e1fa:	5443      	strb	r3, [r0, r1]
 800e1fc:	3901      	subs	r1, #1
		num >>= 4;
	} while (num > 0  && n >= 0);
 800e1fe:	0912      	lsrs	r2, r2, #4
	for(n = 0; n < width; n++)
		buf[n] = ' ';
	n = width - 1;  // start index at far right of field
	i = 0;
	do {  // isolate each decimal digit
		buf[n--] = hex_conv[(num & 0xF)];  // convert to text
 800e200:	b2c9      	uxtb	r1, r1
		num >>= 4;
	} while (num > 0  && n >= 0);
 800e202:	d1f5      	bne.n	800e1f0 <Unsigned_To_Hex_Str+0x1c>
}
 800e204:	bd10      	pop	{r4, pc}
 800e206:	bf00      	nop
 800e208:	20001828 	.word	0x20001828

0800e20c <Unsigned_To_Dec_Str>:

void Unsigned_To_Dec_Str(char *buf, u8 width, u32 num){
 800e20c:	b510      	push	{r4, lr}
 800e20e:	2300      	movs	r3, #0
	char i, n;

	for(n = 0; n < width; n++)
 800e210:	e004      	b.n	800e21c <Unsigned_To_Dec_Str+0x10>
		buf[n] = ' ';
 800e212:	f04f 0c20 	mov.w	ip, #32
 800e216:	f800 c003 	strb.w	ip, [r0, r3]
 800e21a:	3301      	adds	r3, #1
}

void Unsigned_To_Dec_Str(char *buf, u8 width, u32 num){
	char i, n;

	for(n = 0; n < width; n++)
 800e21c:	fa5f fc83 	uxtb.w	ip, r3
 800e220:	458c      	cmp	ip, r1
 800e222:	d3f6      	bcc.n	800e212 <Unsigned_To_Dec_Str+0x6>
		buf[n] = ' ';
	n = width - 1;  // start index at far right of field
 800e224:	3901      	subs	r1, #1
 800e226:	b2c9      	uxtb	r1, r1
	i = 0;
	do {  // isolate each decimal digit
		buf[n--] = hex_conv[(num % 10)];  // convert to text
 800e228:	f04f 0c0a 	mov.w	ip, #10
 800e22c:	fbb2 f3fc 	udiv	r3, r2, ip
 800e230:	fb0c 2213 	mls	r2, ip, r3, r2
 800e234:	4c04      	ldr	r4, [pc, #16]	; (800e248 <Unsigned_To_Dec_Str+0x3c>)
 800e236:	6824      	ldr	r4, [r4, #0]
 800e238:	5ca2      	ldrb	r2, [r4, r2]
 800e23a:	5442      	strb	r2, [r0, r1]
 800e23c:	3901      	subs	r1, #1
 800e23e:	b2c9      	uxtb	r1, r1
		num /= 10;
	} while (num > 0  && n >= 0);
 800e240:	461a      	mov	r2, r3
 800e242:	2b00      	cmp	r3, #0
 800e244:	d1f0      	bne.n	800e228 <Unsigned_To_Dec_Str+0x1c>
}
 800e246:	bd10      	pop	{r4, pc}
 800e248:	20001828 	.word	0x20001828

0800e24c <Signed_To_Dec_Str>:

void Signed_To_Dec_Str(char *buf, u8 width, s32 num){
 800e24c:	b530      	push	{r4, r5, lr}
 800e24e:	2300      	movs	r3, #0
	char i, n;
	bool neg_flg;

	for(n = 0; n < width; n++)
 800e250:	e004      	b.n	800e25c <Signed_To_Dec_Str+0x10>
		buf[n] = ' ';
 800e252:	f04f 0c20 	mov.w	ip, #32
 800e256:	f800 c003 	strb.w	ip, [r0, r3]
 800e25a:	3301      	adds	r3, #1

void Signed_To_Dec_Str(char *buf, u8 width, s32 num){
	char i, n;
	bool neg_flg;

	for(n = 0; n < width; n++)
 800e25c:	fa5f fc83 	uxtb.w	ip, r3
 800e260:	458c      	cmp	ip, r1
 800e262:	d3f6      	bcc.n	800e252 <Signed_To_Dec_Str+0x6>
		buf[n] = ' ';
	if(num < 0){
 800e264:	2a00      	cmp	r2, #0
 800e266:	db01      	blt.n	800e26c <Signed_To_Dec_Str+0x20>
 800e268:	2400      	movs	r4, #0
 800e26a:	e001      	b.n	800e270 <Signed_To_Dec_Str+0x24>
		neg_flg = TRUE;
		num = -num;
 800e26c:	4252      	negs	r2, r2
 800e26e:	2401      	movs	r4, #1
	} else
		neg_flg = FALSE;
	buf[n] = 0;
 800e270:	2300      	movs	r3, #0
 800e272:	5443      	strb	r3, [r0, r1]
	n = width - 1;  // start index at far right of field
 800e274:	3901      	subs	r1, #1
 800e276:	b2c9      	uxtb	r1, r1
	i = 0;
	do {  // isolate each decimal digit
		buf[n--] = hex_conv[(num % 10)];  // convert to text
 800e278:	f04f 0c0a 	mov.w	ip, #10
 800e27c:	fb92 f3fc 	sdiv	r3, r2, ip
 800e280:	fb0c 2213 	mls	r2, ip, r3, r2
 800e284:	4d06      	ldr	r5, [pc, #24]	; (800e2a0 <Signed_To_Dec_Str+0x54>)
 800e286:	682d      	ldr	r5, [r5, #0]
 800e288:	5caa      	ldrb	r2, [r5, r2]
 800e28a:	5442      	strb	r2, [r0, r1]
 800e28c:	3901      	subs	r1, #1
		num /= 10;
	} while (num > 0  && n >= 1);
 800e28e:	1e1a      	subs	r2, r3, #0
		neg_flg = FALSE;
	buf[n] = 0;
	n = width - 1;  // start index at far right of field
	i = 0;
	do {  // isolate each decimal digit
		buf[n--] = hex_conv[(num % 10)];  // convert to text
 800e290:	b2c9      	uxtb	r1, r1
		num /= 10;
	} while (num > 0  && n >= 1);
 800e292:	dd01      	ble.n	800e298 <Signed_To_Dec_Str+0x4c>
 800e294:	2900      	cmp	r1, #0
 800e296:	d1ef      	bne.n	800e278 <Signed_To_Dec_Str+0x2c>
	if(neg_flg)
 800e298:	b10c      	cbz	r4, 800e29e <Signed_To_Dec_Str+0x52>
		buf[n] = '-';
 800e29a:	232d      	movs	r3, #45	; 0x2d
 800e29c:	5443      	strb	r3, [r0, r1]
 800e29e:	bd30      	pop	{r4, r5, pc}
 800e2a0:	20001828 	.word	0x20001828

0800e2a4 <Fixed_To_Dec_Str>:
}

void Fixed_To_Dec_Str(char *buf, u8 width, fixed num){
 800e2a4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	bool isneg = FALSE;
	s16 tmp;
	u32 unum;

	// take care of a negative number
	if(num < 0){
 800e2a6:	2a00      	cmp	r2, #0
 800e2a8:	da02      	bge.n	800e2b0 <Fixed_To_Dec_Str+0xc>
		isneg = TRUE;
		unum = 0 - num;
 800e2aa:	4252      	negs	r2, r2
 800e2ac:	2101      	movs	r1, #1
 800e2ae:	e000      	b.n	800e2b2 <Fixed_To_Dec_Str+0xe>
	} else {
		unum = num;
 800e2b0:	2100      	movs	r1, #0
 800e2b2:	f10d 0306 	add.w	r3, sp, #6
	} while (num > 0  && n >= 1);
	if(neg_flg)
		buf[n] = '-';
}

void Fixed_To_Dec_Str(char *buf, u8 width, fixed num){
 800e2b6:	f1ad 0502 	sub.w	r5, sp, #2
		unum = num;
	}
	// convert to bcd
	bcdp = &bcd[FIXED_BCD - 1];
	for(i = 0; i < FIXED_BCD; i++){  // isolate each decimal digit
		*bcdp-- = (unum % 10);  // convert to bcd
 800e2ba:	240a      	movs	r4, #10
 800e2bc:	fbb2 fcf4 	udiv	ip, r2, r4
 800e2c0:	fb04 221c 	mls	r2, r4, ip, r2
 800e2c4:	705a      	strb	r2, [r3, #1]
		unum /= 10;
 800e2c6:	3b01      	subs	r3, #1
	} else {
		unum = num;
	}
	// convert to bcd
	bcdp = &bcd[FIXED_BCD - 1];
	for(i = 0; i < FIXED_BCD; i++){  // isolate each decimal digit
 800e2c8:	42ab      	cmp	r3, r5
		*bcdp-- = (unum % 10);  // convert to bcd
		unum /= 10;
 800e2ca:	4662      	mov	r2, ip
	} else {
		unum = num;
	}
	// convert to bcd
	bcdp = &bcd[FIXED_BCD - 1];
	for(i = 0; i < FIXED_BCD; i++){  // isolate each decimal digit
 800e2cc:	d1f5      	bne.n	800e2ba <Fixed_To_Dec_Str+0x16>
 800e2ce:	2300      	movs	r3, #0
	}
	// at this point number is in bcd format for editing
	// now display number
	bp = &buf[0];
	for (i = 0; i < FIXED_DIGITS; i++){
		*bp++ = ' ';
 800e2d0:	2220      	movs	r2, #32
 800e2d2:	54c2      	strb	r2, [r0, r3]
 800e2d4:	3301      	adds	r3, #1
		unum /= 10;
	}
	// at this point number is in bcd format for editing
	// now display number
	bp = &buf[0];
	for (i = 0; i < FIXED_DIGITS; i++){
 800e2d6:	2b0a      	cmp	r3, #10
 800e2d8:	d1fa      	bne.n	800e2d0 <Fixed_To_Dec_Str+0x2c>
		*bp++ = ' ';
	}
	*bp = '\0';
 800e2da:	3b0a      	subs	r3, #10
		unum /= 10;
	}
	// at this point number is in bcd format for editing
	// now display number
	bp = &buf[0];
	for (i = 0; i < FIXED_DIGITS; i++){
 800e2dc:	f100 0409 	add.w	r4, r0, #9
		*bp++ = ' ';
	}
	*bp = '\0';
 800e2e0:	7283      	strb	r3, [r0, #10]
	bcdp = &bcd[0];				// eliminate leading zeros
	for(n = 0; *bcdp == 0; n++, bcdp++);
 800e2e2:	f81d 2003 	ldrb.w	r2, [sp, r3]
 800e2e6:	fa1f fc83 	uxth.w	ip, r3
 800e2ea:	3301      	adds	r3, #1
 800e2ec:	2a00      	cmp	r2, #0
 800e2ee:	d0f8      	beq.n	800e2e2 <Fixed_To_Dec_Str+0x3e>
	bcdp = &bcd[FIXED_BCD - 1];	// do 3 digit fraction
	bp--;
	for(i = 0; i < 3; i++){
		*bp-- = *bcdp-- + '0';
 800e2f0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800e2f4:	1e62      	subs	r2, r4, #1
 800e2f6:	3330      	adds	r3, #48	; 0x30
 800e2f8:	7243      	strb	r3, [r0, #9]
 800e2fa:	f89d 3006 	ldrb.w	r3, [sp, #6]
	}
	*bp-- = '.';
 800e2fe:	3005      	adds	r0, #5
	bcdp = &bcd[0];				// eliminate leading zeros
	for(n = 0; *bcdp == 0; n++, bcdp++);
	bcdp = &bcd[FIXED_BCD - 1];	// do 3 digit fraction
	bp--;
	for(i = 0; i < 3; i++){
		*bp-- = *bcdp-- + '0';
 800e300:	3330      	adds	r3, #48	; 0x30
 800e302:	f804 3c01 	strb.w	r3, [r4, #-1]
 800e306:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800e30a:	3330      	adds	r3, #48	; 0x30
 800e30c:	f802 3c01 	strb.w	r3, [r2, #-1]
	}
	*bp-- = '.';
 800e310:	232e      	movs	r3, #46	; 0x2e
 800e312:	f802 3c02 	strb.w	r3, [r2, #-2]
 800e316:	aa01      	add	r2, sp, #4
 800e318:	fa1f f38c 	uxth.w	r3, ip
	// do integer
	for(i = n; i < 5; i++){
 800e31c:	e007      	b.n	800e32e <Fixed_To_Dec_Str+0x8a>
		*bp-- = *bcdp-- + '0';
 800e31e:	f892 c001 	ldrb.w	ip, [r2, #1]
	for(i = 0; i < 3; i++){
		*bp-- = *bcdp-- + '0';
	}
	*bp-- = '.';
	// do integer
	for(i = n; i < 5; i++){
 800e322:	3301      	adds	r3, #1
		*bp-- = *bcdp-- + '0';
 800e324:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
 800e328:	f880 c001 	strb.w	ip, [r0, #1]
	for(i = 0; i < 3; i++){
		*bp-- = *bcdp-- + '0';
	}
	*bp-- = '.';
	// do integer
	for(i = n; i < 5; i++){
 800e32c:	b29b      	uxth	r3, r3
 800e32e:	fa0f fc83 	sxth.w	ip, r3
 800e332:	4604      	mov	r4, r0
 800e334:	3a01      	subs	r2, #1
 800e336:	3801      	subs	r0, #1
 800e338:	f1bc 0f04 	cmp.w	ip, #4
 800e33c:	ddef      	ble.n	800e31e <Fixed_To_Dec_Str+0x7a>
		*bp-- = *bcdp-- + '0';
	}
	if(isneg) *bp = '-';
 800e33e:	b109      	cbz	r1, 800e344 <Fixed_To_Dec_Str+0xa0>
 800e340:	232d      	movs	r3, #45	; 0x2d
 800e342:	7023      	strb	r3, [r4, #0]
}
 800e344:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0800e346 <Time_To_Dec_Str>:

void Time_To_Dec_Str(char *buf, u32 time){
	u16 days, hours, minutes, seconds;

	time /= 1000;	// convert to seconds
	days = time / day_div;
 800e346:	4a29      	ldr	r2, [pc, #164]	; (800e3ec <Time_To_Dec_Str+0xa6>)
#define minute_div	(60)			// minutes

void Time_To_Dec_Str(char *buf, u32 time){
	u16 days, hours, minutes, seconds;

	time /= 1000;	// convert to seconds
 800e348:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800e34c:	fbb1 fcf3 	udiv	ip, r1, r3
*******************************************************************************/
#define day_div 	(24 * 60 * 60)	// days
#define hour_div 	(60 * 60)		// hours
#define minute_div	(60)			// minutes

void Time_To_Dec_Str(char *buf, u32 time){
 800e350:	b5f0      	push	{r4, r5, r6, r7, lr}
	u16 days, hours, minutes, seconds;

	time /= 1000;	// convert to seconds
	days = time / day_div;
 800e352:	fbbc f4f2 	udiv	r4, ip, r2
	time = time % day_div;
 800e356:	fb02 cc14 	mls	ip, r2, r4, ip
	hours = time / hour_div;
 800e35a:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 800e35e:	fbbc f5f2 	udiv	r5, ip, r2
	time = time % hour_div;
 800e362:	fb02 cc15 	mls	ip, r2, r5, ip
	minutes = time / minute_div;
 800e366:	213c      	movs	r1, #60	; 0x3c
	seconds = time % minute_div;
	*buf++ = (days / 10) + '0';
 800e368:	230a      	movs	r3, #10

void Time_To_Dec_Str(char *buf, u32 time){
	u16 days, hours, minutes, seconds;

	time /= 1000;	// convert to seconds
	days = time / day_div;
 800e36a:	b2a6      	uxth	r6, r4
	time = time % day_div;
	hours = time / hour_div;
	time = time % hour_div;
	minutes = time / minute_div;
 800e36c:	fbbc f2f1 	udiv	r2, ip, r1
	seconds = time % minute_div;
 800e370:	fb01 cc12 	mls	ip, r1, r2, ip
	*buf++ = (days / 10) + '0';
 800e374:	fbb6 f1f3 	udiv	r1, r6, r3
 800e378:	f101 0730 	add.w	r7, r1, #48	; 0x30
	*buf++ = (days % 10) + '0';
 800e37c:	fb03 6111 	mls	r1, r3, r1, r6
	u16 days, hours, minutes, seconds;

	time /= 1000;	// convert to seconds
	days = time / day_div;
	time = time % day_div;
	hours = time / hour_div;
 800e380:	b2ac      	uxth	r4, r5
	time = time % hour_div;
	minutes = time / minute_div;
	seconds = time % minute_div;
	*buf++ = (days / 10) + '0';
	*buf++ = (days % 10) + '0';
 800e382:	3130      	adds	r1, #48	; 0x30
	time /= 1000;	// convert to seconds
	days = time / day_div;
	time = time % day_div;
	hours = time / hour_div;
	time = time % hour_div;
	minutes = time / minute_div;
 800e384:	b295      	uxth	r5, r2
	seconds = time % minute_div;
	*buf++ = (days / 10) + '0';
 800e386:	4602      	mov	r2, r0
 800e388:	f802 7b01 	strb.w	r7, [r2], #1
	*buf++ = (days % 10) + '0';
 800e38c:	7041      	strb	r1, [r0, #1]
	*buf++ = ' ';
 800e38e:	2120      	movs	r1, #32
 800e390:	7051      	strb	r1, [r2, #1]
	*buf++ = (hours / 10) + '0';
 800e392:	fbb4 f1f3 	udiv	r1, r4, r3
 800e396:	f101 0630 	add.w	r6, r1, #48	; 0x30
	*buf++ = (hours % 10) + '0';
 800e39a:	fb03 4111 	mls	r1, r3, r1, r4
	hours = time / hour_div;
	time = time % hour_div;
	minutes = time / minute_div;
	seconds = time % minute_div;
	*buf++ = (days / 10) + '0';
	*buf++ = (days % 10) + '0';
 800e39e:	1c50      	adds	r0, r2, #1
	*buf++ = ' ';
	*buf++ = (hours / 10) + '0';
	*buf++ = (hours % 10) + '0';
	*buf++ = ':';
	*buf++ = (minutes / 10) + '0';
 800e3a0:	fbb5 f4f3 	udiv	r4, r5, r3
	minutes = time / minute_div;
	seconds = time % minute_div;
	*buf++ = (days / 10) + '0';
	*buf++ = (days % 10) + '0';
	*buf++ = ' ';
	*buf++ = (hours / 10) + '0';
 800e3a4:	7046      	strb	r6, [r0, #1]
	time = time % hour_div;
	minutes = time / minute_div;
	seconds = time % minute_div;
	*buf++ = (days / 10) + '0';
	*buf++ = (days % 10) + '0';
	*buf++ = ' ';
 800e3a6:	1c42      	adds	r2, r0, #1
	*buf++ = (hours / 10) + '0';
	*buf++ = (hours % 10) + '0';
	*buf++ = ':';
	*buf++ = (minutes / 10) + '0';
 800e3a8:	f104 0630 	add.w	r6, r4, #48	; 0x30
	*buf++ = (minutes % 10) + '0';
 800e3ac:	fb03 5414 	mls	r4, r3, r4, r5
	minutes = time / minute_div;
	seconds = time % minute_div;
	*buf++ = (days / 10) + '0';
	*buf++ = (days % 10) + '0';
	*buf++ = ' ';
	*buf++ = (hours / 10) + '0';
 800e3b0:	1c50      	adds	r0, r2, #1
	*buf++ = (hours % 10) + '0';
 800e3b2:	3130      	adds	r1, #48	; 0x30
 800e3b4:	7051      	strb	r1, [r2, #1]
 800e3b6:	1c42      	adds	r2, r0, #1
	*buf++ = ':';
 800e3b8:	213a      	movs	r1, #58	; 0x3a
 800e3ba:	7041      	strb	r1, [r0, #1]
 800e3bc:	1c50      	adds	r0, r2, #1
	*buf++ = (minutes / 10) + '0';
 800e3be:	7056      	strb	r6, [r2, #1]
	days = time / day_div;
	time = time % day_div;
	hours = time / hour_div;
	time = time % hour_div;
	minutes = time / minute_div;
	seconds = time % minute_div;
 800e3c0:	fa1f fc8c 	uxth.w	ip, ip
	*buf++ = (days % 10) + '0';
	*buf++ = ' ';
	*buf++ = (hours / 10) + '0';
	*buf++ = (hours % 10) + '0';
	*buf++ = ':';
	*buf++ = (minutes / 10) + '0';
 800e3c4:	1c42      	adds	r2, r0, #1
	*buf++ = (minutes % 10) + '0';
 800e3c6:	3430      	adds	r4, #48	; 0x30
 800e3c8:	7044      	strb	r4, [r0, #1]
	*buf++ = ':';
 800e3ca:	7051      	strb	r1, [r2, #1]
	*buf++ = (seconds / 10) + '0';
 800e3cc:	fbbc f1f3 	udiv	r1, ip, r3
	*buf++ = (seconds % 10) + '0';
 800e3d0:	fb03 c311 	mls	r3, r3, r1, ip
	*buf++ = ' ';
	*buf++ = (hours / 10) + '0';
	*buf++ = (hours % 10) + '0';
	*buf++ = ':';
	*buf++ = (minutes / 10) + '0';
	*buf++ = (minutes % 10) + '0';
 800e3d4:	1c50      	adds	r0, r2, #1
	*buf++ = ':';
 800e3d6:	1c42      	adds	r2, r0, #1
	*buf++ = (seconds / 10) + '0';
	*buf++ = (seconds % 10) + '0';
 800e3d8:	3330      	adds	r3, #48	; 0x30
	*buf++ = (hours % 10) + '0';
	*buf++ = ':';
	*buf++ = (minutes / 10) + '0';
	*buf++ = (minutes % 10) + '0';
	*buf++ = ':';
	*buf++ = (seconds / 10) + '0';
 800e3da:	f101 0430 	add.w	r4, r1, #48	; 0x30
 800e3de:	7044      	strb	r4, [r0, #1]
	*buf++ = (seconds % 10) + '0';
 800e3e0:	7053      	strb	r3, [r2, #1]
	*buf++ = (hours % 10) + '0';
	*buf++ = ':';
	*buf++ = (minutes / 10) + '0';
	*buf++ = (minutes % 10) + '0';
	*buf++ = ':';
	*buf++ = (seconds / 10) + '0';
 800e3e2:	1c50      	adds	r0, r2, #1
	*buf++ = (seconds % 10) + '0';
	*buf = NULL;
 800e3e4:	2300      	movs	r3, #0
 800e3e6:	7043      	strb	r3, [r0, #1]
}
 800e3e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e3ea:	bf00      	nop
 800e3ec:	00015180 	.word	0x00015180

0800e3f0 <Bool_To_Str>:
		*bp-- = *bcdp-- + '0';
	}
	if(isneg) *bp = '-';
}

inline void Bool_To_Str(char *buf, u8 width, bool val){
 800e3f0:	4b03      	ldr	r3, [pc, #12]	; (800e400 <Bool_To_Str+0x10>)
	if(val == TRUE){
 800e3f2:	2a01      	cmp	r2, #1
		strcpy(buf, msgt);
 800e3f4:	bf0c      	ite	eq
 800e3f6:	6819      	ldreq	r1, [r3, #0]
	} else {
		strcpy(buf, msgf);
 800e3f8:	6859      	ldrne	r1, [r3, #4]
 800e3fa:	f001 bdcb 	b.w	800ff94 <strcpy>
 800e3fe:	bf00      	nop
 800e400:	08010294 	.word	0x08010294

0800e404 <Reset_Config>:

	TRACE("Reset_Config");

	// Configuration parameters saved in flash
	// general purpose
	cp->initialized = INIT_FLAG;		// set to INIT_FLAG to indicate initialized
 800e404:	4831      	ldr	r0, [pc, #196]	; (800e4cc <Reset_Config+0xc8>)
 Function Name : Reset_Config
 Description : restores config to default and stores configuration in flash memory
*******************************************************************************/

void Reset_Config(void)
{
 800e406:	b510      	push	{r4, lr}
	cp->graph = LINE;
	cp->orient = HORZ;
	cp->rtn_orient = HORZ;
	cp->language = EN;
	cp->display_width = HORZ_WIDTH;
	cp->display_height = HORZ_HEIGHT;
 800e408:	f04f 04ef 	mov.w	r4, #239	; 0xef
 800e40c:	8244      	strh	r4, [r0, #18]
	cp->graph_width = cp->display_width;
	cp->graph_height = cp->display_height - (2 * CHAR_HEIGHT);
	// probe signal processing
	cp->sig_input_range = 5;
 800e40e:	f04f 0405 	mov.w	r4, #5
 800e412:	8304      	strh	r4, [r0, #24]
	cp->sig_type = PULSE_NEG;
	cp->sig_filter = FALSE;
	cp->sig_filter_coef = fixed_from_int(5);
 800e414:	f241 3488 	movw	r4, #5000	; 0x1388
 800e418:	61c4      	str	r4, [r0, #28]
	cp->sig_gaussian = TRUE;
	cp->sig_dvdt_lim = fixed_from_int(-400);
 800e41a:	4c2d      	ldr	r4, [pc, #180]	; (800e4d0 <Reset_Config+0xcc>)
	cp->refresh_time = 3;		// seconds
	cp->graph = LINE;
	cp->orient = HORZ;
	cp->rtn_orient = HORZ;
	cp->language = EN;
	cp->display_width = HORZ_WIDTH;
 800e41c:	f44f 7ca0 	mov.w	ip, #320	; 0x140
	cp->sig_input_range = 5;
	cp->sig_type = PULSE_NEG;
	cp->sig_filter = FALSE;
	cp->sig_filter_coef = fixed_from_int(5);
	cp->sig_gaussian = TRUE;
	cp->sig_dvdt_lim = fixed_from_int(-400);
 800e420:	6244      	str	r4, [r0, #36]	; 0x24
	cp->sig_lo_lim = fixed_from_int(1);
 800e422:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 800e426:	6284      	str	r4, [r0, #40]	; 0x28
	cp->sig_hi_lim = fixed_from_int(2046);
 800e428:	4c2a      	ldr	r4, [pc, #168]	; (800e4d4 <Reset_Config+0xd0>)
	cp->refresh_time = 3;		// seconds
	cp->graph = LINE;
	cp->orient = HORZ;
	cp->rtn_orient = HORZ;
	cp->language = EN;
	cp->display_width = HORZ_WIDTH;
 800e42a:	f8a0 c010 	strh.w	ip, [r0, #16]
	cp->display_height = HORZ_HEIGHT;
	cp->graph_width = cp->display_width;
 800e42e:	f8a0 c014 	strh.w	ip, [r0, #20]
	cp->sig_filter = FALSE;
	cp->sig_filter_coef = fixed_from_int(5);
	cp->sig_gaussian = TRUE;
	cp->sig_dvdt_lim = fixed_from_int(-400);
	cp->sig_lo_lim = fixed_from_int(1);
	cp->sig_hi_lim = fixed_from_int(2046);
 800e432:	62c4      	str	r4, [r0, #44]	; 0x2c
	cp->menu_index = 0;
	cp->mode = PHA;			// current mode
	cp->rtn_mode = PHA;		// mode to return to from menu mode
	cp->alarm_en = FALSE;		// enable alarm
	// display
	cp->refresh_time = 3;		// seconds
 800e434:	f04f 0203 	mov.w	r2, #3
	cp->rtn_orient = HORZ;
	cp->language = EN;
	cp->display_width = HORZ_WIDTH;
	cp->display_height = HORZ_HEIGHT;
	cp->graph_width = cp->display_width;
	cp->graph_height = cp->display_height - (2 * CHAR_HEIGHT);
 800e438:	f04f 0ccf 	mov.w	ip, #207	; 0xcf
	cp->sig_gaussian = TRUE;
	cp->sig_dvdt_lim = fixed_from_int(-400);
	cp->sig_lo_lim = fixed_from_int(1);
	cp->sig_hi_lim = fixed_from_int(2046);
	cp->sig_zero = 900;
	cp->sig_range = FIXED_HALF;
 800e43c:	f44f 74fa 	mov.w	r4, #500	; 0x1f4
	cp->menu_index = 0;
	cp->mode = PHA;			// current mode
	cp->rtn_mode = PHA;		// mode to return to from menu mode
	cp->alarm_en = FALSE;		// enable alarm
	// display
	cp->refresh_time = 3;		// seconds
 800e440:	8142      	strh	r2, [r0, #10]
	cp->rtn_orient = HORZ;
	cp->language = EN;
	cp->display_width = HORZ_WIDTH;
	cp->display_height = HORZ_HEIGHT;
	cp->graph_width = cp->display_width;
	cp->graph_height = cp->display_height - (2 * CHAR_HEIGHT);
 800e442:	f8a0 c016 	strh.w	ip, [r0, #22]
	cp->mode = PHA;			// current mode
	cp->rtn_mode = PHA;		// mode to return to from menu mode
	cp->alarm_en = FALSE;		// enable alarm
	// display
	cp->refresh_time = 3;		// seconds
	cp->graph = LINE;
 800e446:	2201      	movs	r2, #1
	cp->sig_gaussian = TRUE;
	cp->sig_dvdt_lim = fixed_from_int(-400);
	cp->sig_lo_lim = fixed_from_int(1);
	cp->sig_hi_lim = fixed_from_int(2046);
	cp->sig_zero = 900;
	cp->sig_range = FIXED_HALF;
 800e448:	6344      	str	r4, [r0, #52]	; 0x34

	TRACE("Reset_Config");

	// Configuration parameters saved in flash
	// general purpose
	cp->initialized = INIT_FLAG;		// set to INIT_FLAG to indicate initialized
 800e44a:	4b23      	ldr	r3, [pc, #140]	; (800e4d8 <Reset_Config+0xd4>)
	cp->sig_filter_coef = fixed_from_int(5);
	cp->sig_gaussian = TRUE;
	cp->sig_dvdt_lim = fixed_from_int(-400);
	cp->sig_lo_lim = fixed_from_int(1);
	cp->sig_hi_lim = fixed_from_int(2046);
	cp->sig_zero = 900;
 800e44c:	f44f 7c61 	mov.w	ip, #900	; 0x384
	cp->sig_range = FIXED_HALF;
	// pha mode
	cp->pha_file_seq = 0;
	cp->pha_energy_comp = FALSE;
	cp->pha_cursor_width = 1;
	cp->pha_channels = 2048;
 800e450:	f44f 6400 	mov.w	r4, #2048	; 0x800
	TRACE("Reset_Config");

	// Configuration parameters saved in flash
	// general purpose
	cp->initialized = INIT_FLAG;		// set to INIT_FLAG to indicate initialized
	cp->menu_index = 0;
 800e454:	2100      	movs	r1, #0
	cp->mode = PHA;			// current mode
	cp->rtn_mode = PHA;		// mode to return to from menu mode
	cp->alarm_en = FALSE;		// enable alarm
	// display
	cp->refresh_time = 3;		// seconds
	cp->graph = LINE;
 800e456:	7302      	strb	r2, [r0, #12]
	cp->display_height = HORZ_HEIGHT;
	cp->graph_width = cp->display_width;
	cp->graph_height = cp->display_height - (2 * CHAR_HEIGHT);
	// probe signal processing
	cp->sig_input_range = 5;
	cp->sig_type = PULSE_NEG;
 800e458:	7682      	strb	r2, [r0, #26]
	cp->sig_filter = FALSE;
	cp->sig_filter_coef = fixed_from_int(5);
	cp->sig_gaussian = TRUE;
 800e45a:	f880 2020 	strb.w	r2, [r0, #32]
	cp->sig_dvdt_lim = fixed_from_int(-400);
	cp->sig_lo_lim = fixed_from_int(1);
	cp->sig_hi_lim = fixed_from_int(2046);
	cp->sig_zero = 900;
 800e45e:	f8a0 c030 	strh.w	ip, [r0, #48]	; 0x30
	cp->sig_range = FIXED_HALF;
	// pha mode
	cp->pha_file_seq = 0;
	cp->pha_energy_comp = FALSE;
	cp->pha_cursor_width = 1;
 800e462:	8782      	strh	r2, [r0, #60]	; 0x3c
 800e464:	4694      	mov	ip, r2
	cp->pha_channels = 2048;
 800e466:	87c4      	strh	r4, [r0, #62]	; 0x3e
	cp->pha_window_hi = 2047;		// in channels
	cp->pha_window_lo = 1;		// in channels
 800e468:	f8a0 2042 	strh.w	r2, [r0, #66]	; 0x42
	cp->pha_zoom = 1;
 800e46c:	f880 2044 	strb.w	r2, [r0, #68]	; 0x44
	// pha mode
	cp->pha_file_seq = 0;
	cp->pha_energy_comp = FALSE;
	cp->pha_cursor_width = 1;
	cp->pha_channels = 2048;
	cp->pha_window_hi = 2047;		// in channels
 800e470:	f240 74ff 	movw	r4, #2047	; 0x7ff
	cp->pha_window_lo = 1;		// in channels
	cp->pha_zoom = 1;
	cp->pha_cursor_hi = 1024;		// in channels
 800e474:	f44f 6280 	mov.w	r2, #1024	; 0x400

	TRACE("Reset_Config");

	// Configuration parameters saved in flash
	// general purpose
	cp->initialized = INIT_FLAG;		// set to INIT_FLAG to indicate initialized
 800e478:	6003      	str	r3, [r0, #0]
	cp->menu_index = 0;
 800e47a:	8081      	strh	r1, [r0, #4]
	cp->mode = PHA;			// current mode
 800e47c:	7181      	strb	r1, [r0, #6]
	cp->rtn_mode = PHA;		// mode to return to from menu mode
 800e47e:	71c1      	strb	r1, [r0, #7]
	cp->alarm_en = FALSE;		// enable alarm
 800e480:	7201      	strb	r1, [r0, #8]
	// display
	cp->refresh_time = 3;		// seconds
	cp->graph = LINE;
	cp->orient = HORZ;
 800e482:	7341      	strb	r1, [r0, #13]
	cp->rtn_orient = HORZ;
 800e484:	7381      	strb	r1, [r0, #14]
	cp->language = EN;
 800e486:	73c1      	strb	r1, [r0, #15]
	cp->graph_width = cp->display_width;
	cp->graph_height = cp->display_height - (2 * CHAR_HEIGHT);
	// probe signal processing
	cp->sig_input_range = 5;
	cp->sig_type = PULSE_NEG;
	cp->sig_filter = FALSE;
 800e488:	76c1      	strb	r1, [r0, #27]
	cp->sig_lo_lim = fixed_from_int(1);
	cp->sig_hi_lim = fixed_from_int(2046);
	cp->sig_zero = 900;
	cp->sig_range = FIXED_HALF;
	// pha mode
	cp->pha_file_seq = 0;
 800e48a:	8701      	strh	r1, [r0, #56]	; 0x38
	cp->pha_energy_comp = FALSE;
 800e48c:	f880 103a 	strb.w	r1, [r0, #58]	; 0x3a
	cp->pha_cursor_width = 1;
	cp->pha_channels = 2048;
	cp->pha_window_hi = 2047;		// in channels
	cp->pha_window_lo = 1;		// in channels
	cp->pha_zoom = 1;
	cp->pha_cursor_hi = 1024;		// in channels
 800e490:	f8a0 2046 	strh.w	r2, [r0, #70]	; 0x46
	// pha mode
	cp->pha_file_seq = 0;
	cp->pha_energy_comp = FALSE;
	cp->pha_cursor_width = 1;
	cp->pha_channels = 2048;
	cp->pha_window_hi = 2047;		// in channels
 800e494:	f8a0 4040 	strh.w	r4, [r0, #64]	; 0x40
	cp->pha_window_lo = 1;		// in channels
	cp->pha_zoom = 1;
	cp->pha_cursor_hi = 1024;		// in channels
	cp->pha_cursor_lo = 1024;		// in channels
 800e498:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
	cp->pha_cal = FALSE;
	fixed pha_cal_a = fixed_from_int(0);
	fixed pha_cal_b = fixed_from_int(0);
	fixed pha_cal_c = fixed_from_int(0);
	// rate mode
	cp->rate_alarm = 100000;
 800e49c:	4a0f      	ldr	r2, [pc, #60]	; (800e4dc <Reset_Config+0xd8>)
	cp->pha_window_hi = 2047;		// in channels
	cp->pha_window_lo = 1;		// in channels
	cp->pha_zoom = 1;
	cp->pha_cursor_hi = 1024;		// in channels
	cp->pha_cursor_lo = 1024;		// in channels
	cp->pha_cal = FALSE;
 800e49e:	f880 104a 	strb.w	r1, [r0, #74]	; 0x4a
	fixed pha_cal_a = fixed_from_int(0);
	fixed pha_cal_b = fixed_from_int(0);
	fixed pha_cal_c = fixed_from_int(0);
	// rate mode
	cp->rate_alarm = 100000;
 800e4a2:	6582      	str	r2, [r0, #88]	; 0x58
	cp->rate_filter = FALSE;
 800e4a4:	f880 105c 	strb.w	r1, [r0, #92]	; 0x5c
	cp->rate_filter_coef = 15;
 800e4a8:	f04f 020f 	mov.w	r2, #15
	cp->rate_beep = TRUE;
	cp->rate_cursor = 150;
	// Administration
	cp->debug_level = 0;
 800e4ac:	f8a0 1064 	strh.w	r1, [r0, #100]	; 0x64
	// now store the reset configuration
	__Flash_Write((u16 *) cp, (u32) &config_flash[0], sizeof(configurations));
 800e4b0:	490b      	ldr	r1, [pc, #44]	; (800e4e0 <Reset_Config+0xdc>)
	fixed pha_cal_b = fixed_from_int(0);
	fixed pha_cal_c = fixed_from_int(0);
	// rate mode
	cp->rate_alarm = 100000;
	cp->rate_filter = FALSE;
	cp->rate_filter_coef = 15;
 800e4b2:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
	cp->rate_beep = TRUE;
	cp->rate_cursor = 150;
 800e4b6:	f04f 0396 	mov.w	r3, #150	; 0x96
	// Administration
	cp->debug_level = 0;
	// now store the reset configuration
	__Flash_Write((u16 *) cp, (u32) &config_flash[0], sizeof(configurations));
 800e4ba:	2268      	movs	r2, #104	; 0x68
	fixed pha_cal_c = fixed_from_int(0);
	// rate mode
	cp->rate_alarm = 100000;
	cp->rate_filter = FALSE;
	cp->rate_filter_coef = 15;
	cp->rate_beep = TRUE;
 800e4bc:	f880 c060 	strb.w	ip, [r0, #96]	; 0x60
	cp->rate_cursor = 150;
 800e4c0:	f8a0 3062 	strh.w	r3, [r0, #98]	; 0x62
	// Administration
	cp->debug_level = 0;
	// now store the reset configuration
	__Flash_Write((u16 *) cp, (u32) &config_flash[0], sizeof(configurations));
}
 800e4c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	cp->rate_beep = TRUE;
	cp->rate_cursor = 150;
	// Administration
	cp->debug_level = 0;
	// now store the reset configuration
	__Flash_Write((u16 *) cp, (u32) &config_flash[0], sizeof(configurations));
 800e4c8:	f7f5 be3d 	b.w	8004146 <__Flash_Write>
 800e4cc:	20003ac8 	.word	0x20003ac8
 800e4d0:	fff9e580 	.word	0xfff9e580
 800e4d4:	001f3830 	.word	0x001f3830
 800e4d8:	00120915 	.word	0x00120915
 800e4dc:	000186a0 	.word	0x000186a0
 800e4e0:	0800c400 	.word	0x0800c400

0800e4e4 <Write_Config>:
 Description : Writes configuration to flash memory.  Use this to hide flash setup
 *******************************************************************************/
void Write_Config(void){
	TRACE("Write_Config");

	__Flash_Write((u16 *) &configuration, (u32) &config_flash[0], sizeof(configurations));
 800e4e4:	4802      	ldr	r0, [pc, #8]	; (800e4f0 <Write_Config+0xc>)
 800e4e6:	4903      	ldr	r1, [pc, #12]	; (800e4f4 <Write_Config+0x10>)
 800e4e8:	2268      	movs	r2, #104	; 0x68
 800e4ea:	f7f5 be2c 	b.w	8004146 <__Flash_Write>
 800e4ee:	bf00      	nop
 800e4f0:	20003ac8 	.word	0x20003ac8
 800e4f4:	0800c400 	.word	0x0800c400

0800e4f8 <Read_Config>:
 Function Name : void Read_Config(void)
 Description : Read configuration from flash memory.  Use this to hide flash setup
 *******************************************************************************/
void Read_Config(void){
	TRACE("Read_Config");
	__Flash_Read((u16 *) &configuration, (u32) &config_flash[0], sizeof(configurations));
 800e4f8:	4802      	ldr	r0, [pc, #8]	; (800e504 <Read_Config+0xc>)
 800e4fa:	4903      	ldr	r1, [pc, #12]	; (800e508 <Read_Config+0x10>)
 800e4fc:	2268      	movs	r2, #104	; 0x68
 800e4fe:	f7f5 be24 	b.w	800414a <__Flash_Read>
 800e502:	bf00      	nop
 800e504:	20003ac8 	.word	0x20003ac8
 800e508:	0800c400 	.word	0x0800c400

0800e50c <Display_Menu_Line>:
/*******************************************************************************
 Function Name : Display_Menu_Line
 Description : Outputs a single menu line with value
 Note: keep menu narrow enough to be displayed in both portrait and landscape
 *******************************************************************************/
void Display_Menu_Line(u16 y, u16 fg, u16 bg, const menus *msp) {
 800e50c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800e50e:	461c      	mov	r4, r3
	u32 u32b;
	s32 s32b;
	fixed fixb;

	TRACE("Display_Menu");
	__Display_Str(MENU_LABEL_X, y, fg, bg, msp->txt);
 800e510:	681b      	ldr	r3, [r3, #0]
/*******************************************************************************
 Function Name : Display_Menu_Line
 Description : Outputs a single menu line with value
 Note: keep menu narrow enough to be displayed in both portrait and landscape
 *******************************************************************************/
void Display_Menu_Line(u16 y, u16 fg, u16 bg, const menus *msp) {
 800e512:	4607      	mov	r7, r0
 800e514:	460e      	mov	r6, r1
 800e516:	4615      	mov	r5, r2
	u32 u32b;
	s32 s32b;
	fixed fixb;

	TRACE("Display_Menu");
	__Display_Str(MENU_LABEL_X, y, fg, bg, msp->txt);
 800e518:	9300      	str	r3, [sp, #0]
 800e51a:	2004      	movs	r0, #4
 800e51c:	462b      	mov	r3, r5
 800e51e:	4639      	mov	r1, r7
 800e520:	4632      	mov	r2, r6
 800e522:	f7f5 fe04 	bl	800412e <__Display_Str>
	switch(msp->type){
 800e526:	7923      	ldrb	r3, [r4, #4]
 800e528:	3b08      	subs	r3, #8
 800e52a:	2b0b      	cmp	r3, #11
 800e52c:	d857      	bhi.n	800e5de <Display_Menu_Line+0xd2>
 800e52e:	e8df f003 	tbb	[pc, r3]
 800e532:	1a06      	.short	0x1a06
 800e534:	24561a10 	.word	0x24561a10
 800e538:	5639432e 	.word	0x5639432e
 800e53c:	4d56      	.short	0x4d56
		case COMMENT:
			break;
		case BOOL_TYPE:
			Display_Bool(MENU_END_VAR - BOOL_WIDTH, y, fg, bg, *((bool *)msp->valp));
 800e53e:	68a3      	ldr	r3, [r4, #8]
 800e540:	20a0      	movs	r0, #160	; 0xa0
 800e542:	781b      	ldrb	r3, [r3, #0]
 800e544:	4639      	mov	r1, r7
 800e546:	9300      	str	r3, [sp, #0]
 800e548:	4632      	mov	r2, r6
 800e54a:	462b      	mov	r3, r5
 800e54c:	f7fe fe3c 	bl	800d1c8 <Display_Bool>
			break;
 800e550:	e045      	b.n	800e5de <Display_Menu_Line+0xd2>
		case ENUM_TYPE:
			// will never have > 256 values;
			Display_U8(MENU_END_VAR - U8_WIDTH, y, fg, bg, *((u8 *)msp->valp));
			break;
		case CHAR_TYPE:
			Display_Char(MENU_END_VAR - CHAR_WIDTH, y, fg, bg, *((char *)msp->valp));
 800e552:	68a3      	ldr	r3, [r4, #8]
 800e554:	20c0      	movs	r0, #192	; 0xc0
 800e556:	781b      	ldrb	r3, [r3, #0]
 800e558:	4639      	mov	r1, r7
 800e55a:	9300      	str	r3, [sp, #0]
 800e55c:	4632      	mov	r2, r6
 800e55e:	462b      	mov	r3, r5
 800e560:	f7fe fe24 	bl	800d1ac <Display_Char>
			break;
 800e564:	e03b      	b.n	800e5de <Display_Menu_Line+0xd2>
		case U8_TYPE:
			Display_U8(MENU_END_VAR - U8_WIDTH, y, fg, bg, *((u8 *)msp->valp));
 800e566:	68a3      	ldr	r3, [r4, #8]
 800e568:	20b0      	movs	r0, #176	; 0xb0
 800e56a:	781b      	ldrb	r3, [r3, #0]
 800e56c:	4639      	mov	r1, r7
 800e56e:	9300      	str	r3, [sp, #0]
 800e570:	4632      	mov	r2, r6
 800e572:	462b      	mov	r3, r5
 800e574:	f7fe ff1e 	bl	800d3b4 <Display_U8>
			break;
 800e578:	e031      	b.n	800e5de <Display_Menu_Line+0xd2>
		// Signed char does not exist for this compiler
		//case S8_TYPE:
		//	Display_S8(MENU_END_VAR - S8_WIDTH, y, fg, bg, *((u8 *)msp->valp));
		//	break;
		case U16_TYPE:
			Display_U16(MENU_END_VAR - U16_WIDTH, y, fg, bg, *((u16 *)msp->valp));
 800e57a:	68a3      	ldr	r3, [r4, #8]
 800e57c:	20a0      	movs	r0, #160	; 0xa0
 800e57e:	881b      	ldrh	r3, [r3, #0]
 800e580:	4639      	mov	r1, r7
 800e582:	9300      	str	r3, [sp, #0]
 800e584:	4632      	mov	r2, r6
 800e586:	462b      	mov	r3, r5
 800e588:	f7fe fea7 	bl	800d2da <Display_U16>
			break;
 800e58c:	e027      	b.n	800e5de <Display_Menu_Line+0xd2>
		case S16_TYPE:
			Display_S16(MENU_END_VAR - S16_WIDTH, y, fg, bg, *((s16 *)msp->valp));
 800e58e:	68a3      	ldr	r3, [r4, #8]
 800e590:	2098      	movs	r0, #152	; 0x98
 800e592:	f9b3 3000 	ldrsh.w	r3, [r3]
 800e596:	4639      	mov	r1, r7
 800e598:	9300      	str	r3, [sp, #0]
 800e59a:	4632      	mov	r2, r6
 800e59c:	462b      	mov	r3, r5
 800e59e:	f7fe fe59 	bl	800d254 <Display_S16>
			break;
 800e5a2:	e01c      	b.n	800e5de <Display_Menu_Line+0xd2>
		case U32_TYPE:
			Display_U32(MENU_END_VAR - U32_WIDTH, y, fg, bg, *((u32 *)msp->valp));
 800e5a4:	68a3      	ldr	r3, [r4, #8]
 800e5a6:	2068      	movs	r0, #104	; 0x68
 800e5a8:	681b      	ldr	r3, [r3, #0]
 800e5aa:	4639      	mov	r1, r7
 800e5ac:	9300      	str	r3, [sp, #0]
 800e5ae:	4632      	mov	r2, r6
 800e5b0:	462b      	mov	r3, r5
 800e5b2:	f7fe fe7b 	bl	800d2ac <Display_U32>
			break;
 800e5b6:	e012      	b.n	800e5de <Display_Menu_Line+0xd2>
		case S32_TYPE:
			Display_S32(MENU_END_VAR - S32_WIDTH, y, fg, bg, *((s32 *)msp->valp));
 800e5b8:	68a3      	ldr	r3, [r4, #8]
 800e5ba:	2060      	movs	r0, #96	; 0x60
 800e5bc:	681b      	ldr	r3, [r3, #0]
 800e5be:	4639      	mov	r1, r7
 800e5c0:	9300      	str	r3, [sp, #0]
 800e5c2:	4632      	mov	r2, r6
 800e5c4:	462b      	mov	r3, r5
 800e5c6:	f7fe fe2e 	bl	800d226 <Display_S32>
			break;
 800e5ca:	e008      	b.n	800e5de <Display_Menu_Line+0xd2>
		case FIXED_TYPE:
			Display_Fixed(MENU_END_VAR - FIXED_WIDTH, y, fg, bg, *((fixed *)msp->valp));
 800e5cc:	68a3      	ldr	r3, [r4, #8]
 800e5ce:	2078      	movs	r0, #120	; 0x78
 800e5d0:	681b      	ldr	r3, [r3, #0]
 800e5d2:	4639      	mov	r1, r7
 800e5d4:	9300      	str	r3, [sp, #0]
 800e5d6:	4632      	mov	r2, r6
 800e5d8:	462b      	mov	r3, r5
 800e5da:	f7fe fe0d 	bl	800d1f8 <Display_Fixed>
			break;
		//case STR_TYPE:
 		//	__Display_Str(MENU_END_VAR -, y, fg, bg, (char *)msp->valp);
		//	break;
	}
}
 800e5de:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0800e5e0 <Display_Menu>:
 Para:
 	Index = currently selected menu line.
*******************************************************************************/
#define MENU_BRACKET 6 	// menu lines displayed above and below

void Display_Menu(s16 index) {
 800e5e0:	e92d 45f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, sl, lr}
 800e5e4:	4607      	mov	r7, r0
	s16 y;
	s16 n, m;
	configurations *cp = &configuration;

	Clear_Screen( BKGND_COLOR );
 800e5e6:	2000      	movs	r0, #0
 800e5e8:	f7fe fdd2 	bl	800d190 <Clear_Screen>
	// start at top
	y =  (cp->display_height / 2) + (MENU_BRACKET * CHAR_HEIGHT);
 800e5ec:	4b19      	ldr	r3, [pc, #100]	; (800e654 <Display_Menu+0x74>)
	n = index - MENU_BRACKET;
 800e5ee:	1fbc      	subs	r4, r7, #6
	s16 n, m;
	configurations *cp = &configuration;

	Clear_Screen( BKGND_COLOR );
	// start at top
	y =  (cp->display_height / 2) + (MENU_BRACKET * CHAR_HEIGHT);
 800e5f0:	f9b3 a012 	ldrsh.w	sl, [r3, #18]
	n = index - MENU_BRACKET;
 800e5f4:	b2a4      	uxth	r4, r4
	for(m = ( MENU_BRACKET * 2 ) + 1; m > 0; m--){
		if(n >= 0 && n < MENU_LINES){
			if(n == index){
				Display_Menu_Line(y, BKGND_COLOR, TXT_COLOR, &menu[n]);
 800e5f6:	4b18      	ldr	r3, [pc, #96]	; (800e658 <Display_Menu+0x78>)
 800e5f8:	2218      	movs	r2, #24
	s16 n, m;
	configurations *cp = &configuration;

	Clear_Screen( BKGND_COLOR );
	// start at top
	y =  (cp->display_height / 2) + (MENU_BRACKET * CHAR_HEIGHT);
 800e5fa:	eb0a 7ada 	add.w	sl, sl, sl, lsr #31
	n = index - MENU_BRACKET;
	for(m = ( MENU_BRACKET * 2 ) + 1; m > 0; m--){
		if(n >= 0 && n < MENU_LINES){
			if(n == index){
				Display_Menu_Line(y, BKGND_COLOR, TXT_COLOR, &menu[n]);
 800e5fe:	b226      	sxth	r6, r4
	s16 n, m;
	configurations *cp = &configuration;

	Clear_Screen( BKGND_COLOR );
	// start at top
	y =  (cp->display_height / 2) + (MENU_BRACKET * CHAR_HEIGHT);
 800e600:	ea4f 0a6a 	mov.w	sl, sl, asr #1
	n = index - MENU_BRACKET;
	for(m = ( MENU_BRACKET * 2 ) + 1; m > 0; m--){
		if(n >= 0 && n < MENU_LINES){
			if(n == index){
				Display_Menu_Line(y, BKGND_COLOR, TXT_COLOR, &menu[n]);
 800e604:	fb02 3807 	mla	r8, r2, r7, r3
 800e608:	fb02 3606 	mla	r6, r2, r6, r3
	s16 n, m;
	configurations *cp = &configuration;

	Clear_Screen( BKGND_COLOR );
	// start at top
	y =  (cp->display_height / 2) + (MENU_BRACKET * CHAR_HEIGHT);
 800e60c:	fa1f fa8a 	uxth.w	sl, sl
 800e610:	f10a 0560 	add.w	r5, sl, #96	; 0x60
 Para:
 	Index = currently selected menu line.
*******************************************************************************/
#define MENU_BRACKET 6 	// menu lines displayed above and below

void Display_Menu(s16 index) {
 800e614:	f1aa 0a60 	sub.w	sl, sl, #96	; 0x60
	s16 n, m;
	configurations *cp = &configuration;

	Clear_Screen( BKGND_COLOR );
	// start at top
	y =  (cp->display_height / 2) + (MENU_BRACKET * CHAR_HEIGHT);
 800e618:	b2ad      	uxth	r5, r5
 Para:
 	Index = currently selected menu line.
*******************************************************************************/
#define MENU_BRACKET 6 	// menu lines displayed above and below

void Display_Menu(s16 index) {
 800e61a:	fa1f fa8a 	uxth.w	sl, sl
	Clear_Screen( BKGND_COLOR );
	// start at top
	y =  (cp->display_height / 2) + (MENU_BRACKET * CHAR_HEIGHT);
	n = index - MENU_BRACKET;
	for(m = ( MENU_BRACKET * 2 ) + 1; m > 0; m--){
		if(n >= 0 && n < MENU_LINES){
 800e61e:	2c24      	cmp	r4, #36	; 0x24
 800e620:	d80e      	bhi.n	800e640 <Display_Menu+0x60>
			if(n == index){
 800e622:	b223      	sxth	r3, r4
 800e624:	42bb      	cmp	r3, r7
 800e626:	b2a8      	uxth	r0, r5
 800e628:	d104      	bne.n	800e634 <Display_Menu+0x54>
				Display_Menu_Line(y, BKGND_COLOR, TXT_COLOR, &menu[n]);
 800e62a:	2100      	movs	r1, #0
 800e62c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800e630:	4643      	mov	r3, r8
 800e632:	e003      	b.n	800e63c <Display_Menu+0x5c>
			} else {
				Display_Menu_Line(y, TXT_COLOR, BKGND_COLOR, &menu[n]);
 800e634:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800e638:	2200      	movs	r2, #0
 800e63a:	4633      	mov	r3, r6
 800e63c:	f7ff ff66 	bl	800e50c <Display_Menu_Line>
 800e640:	3618      	adds	r6, #24

	Clear_Screen( BKGND_COLOR );
	// start at top
	y =  (cp->display_height / 2) + (MENU_BRACKET * CHAR_HEIGHT);
	n = index - MENU_BRACKET;
	for(m = ( MENU_BRACKET * 2 ) + 1; m > 0; m--){
 800e642:	45aa      	cmp	sl, r5
 800e644:	d004      	beq.n	800e650 <Display_Menu+0x70>
				Display_Menu_Line(y, BKGND_COLOR, TXT_COLOR, &menu[n]);
			} else {
				Display_Menu_Line(y, TXT_COLOR, BKGND_COLOR, &menu[n]);
			}
		}
		n++;
 800e646:	3401      	adds	r4, #1
 Para:
 	Index = currently selected menu line.
*******************************************************************************/
#define MENU_BRACKET 6 	// menu lines displayed above and below

void Display_Menu(s16 index) {
 800e648:	3d10      	subs	r5, #16
				Display_Menu_Line(y, BKGND_COLOR, TXT_COLOR, &menu[n]);
			} else {
				Display_Menu_Line(y, TXT_COLOR, BKGND_COLOR, &menu[n]);
			}
		}
		n++;
 800e64a:	b2a4      	uxth	r4, r4
 Para:
 	Index = currently selected menu line.
*******************************************************************************/
#define MENU_BRACKET 6 	// menu lines displayed above and below

void Display_Menu(s16 index) {
 800e64c:	b2ad      	uxth	r5, r5
 800e64e:	e7e6      	b.n	800e61e <Display_Menu+0x3e>
 800e650:	e8bd 85f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, sl, pc}
 800e654:	20003ac8 	.word	0x20003ac8
 800e658:	0801029c 	.word	0x0801029c

0800e65c <Menu_Reset_Config>:

/*******************************************************************************
 Function Name : Menu_Reset_Config
 Description : Reset configuration and handles menu specific items.
 *******************************************************************************/
void Menu_Reset_Config(void){
 800e65c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	configurations *cp = &configuration;
	u16 menu_index;
	menu_index = cp->menu_index;
 800e65e:	4c0d      	ldr	r4, [pc, #52]	; (800e694 <Menu_Reset_Config+0x38>)
 800e660:	88a5      	ldrh	r5, [r4, #4]
	Reset_Config();
 800e662:	f7ff fecf 	bl	800e404 <Reset_Config>
	__Display_Str(22 * CHAR_WIDTH, cp->display_height / 2, BKGND_COLOR, TXT_COLOR, msg_succeed);
 800e666:	f9b4 1012 	ldrsh.w	r1, [r4, #18]
 800e66a:	4b0b      	ldr	r3, [pc, #44]	; (800e698 <Menu_Reset_Config+0x3c>)
 800e66c:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
 800e670:	681b      	ldr	r3, [r3, #0]
 800e672:	1049      	asrs	r1, r1, #1
 800e674:	9300      	str	r3, [sp, #0]
 800e676:	20b0      	movs	r0, #176	; 0xb0
 800e678:	b289      	uxth	r1, r1
 800e67a:	2200      	movs	r2, #0
 800e67c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800e680:	f7f5 fd55 	bl	800412e <__Display_Str>
	//Delay_MS(2000);
	cp->mode = MENU;
 800e684:	2302      	movs	r3, #2
	cp->menu_index = menu_index;
	Display_Menu(cp->menu_index);
 800e686:	b228      	sxth	r0, r5
	u16 menu_index;
	menu_index = cp->menu_index;
	Reset_Config();
	__Display_Str(22 * CHAR_WIDTH, cp->display_height / 2, BKGND_COLOR, TXT_COLOR, msg_succeed);
	//Delay_MS(2000);
	cp->mode = MENU;
 800e688:	71a3      	strb	r3, [r4, #6]
	cp->menu_index = menu_index;
 800e68a:	80a5      	strh	r5, [r4, #4]
	Display_Menu(cp->menu_index);
}
 800e68c:	b003      	add	sp, #12
 800e68e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	Reset_Config();
	__Display_Str(22 * CHAR_WIDTH, cp->display_height / 2, BKGND_COLOR, TXT_COLOR, msg_succeed);
	//Delay_MS(2000);
	cp->mode = MENU;
	cp->menu_index = menu_index;
	Display_Menu(cp->menu_index);
 800e692:	e7a5      	b.n	800e5e0 <Display_Menu>
 800e694:	20003ac8 	.word	0x20003ac8
 800e698:	2000182c 	.word	0x2000182c

0800e69c <Do_Keys_Menu>:
	static modes rtn_mode;
	configurations *cp = &configuration;
	u16 menu_index;

	TRACE("Do_Keys_Menu");
	msp = &menu[cp->menu_index];
 800e69c:	4b75      	ldr	r3, [pc, #468]	; (800e874 <Do_Keys_Menu+0x1d8>)
/*******************************************************************************
 Function Name : Do_Menu
 Description : Display menu and implement actions and change values until
 user selects "exit".
 *******************************************************************************/
void Do_Keys_Menu(keycodes key){
 800e69e:	b537      	push	{r0, r1, r2, r4, r5, lr}
	static modes rtn_mode;
	configurations *cp = &configuration;
	u16 menu_index;

	TRACE("Do_Keys_Menu");
	msp = &menu[cp->menu_index];
 800e6a0:	889b      	ldrh	r3, [r3, #4]
 800e6a2:	4a75      	ldr	r2, [pc, #468]	; (800e878 <Do_Keys_Menu+0x1dc>)
 800e6a4:	2418      	movs	r4, #24
	switch(key){
 800e6a6:	3803      	subs	r0, #3
	static modes rtn_mode;
	configurations *cp = &configuration;
	u16 menu_index;

	TRACE("Do_Keys_Menu");
	msp = &menu[cp->menu_index];
 800e6a8:	fb04 2403 	mla	r4, r4, r3, r2
	switch(key){
 800e6ac:	2805      	cmp	r0, #5
 800e6ae:	f200 80ff 	bhi.w	800e8b0 <Do_Keys_Menu+0x214>
 800e6b2:	e8df f010 	tbh	[pc, r0, lsl #1]
 800e6b6:	0006      	.short	0x0006
 800e6b8:	002e00fd 	.word	0x002e00fd
 800e6bc:	0039002a 	.word	0x0039002a
 800e6c0:	0082      	.short	0x0082
		case KEYCODE_M: // exit menu mode
			cp->orient = cp->rtn_orient;
 800e6c2:	4c6c      	ldr	r4, [pc, #432]	; (800e874 <Do_Keys_Menu+0x1d8>)
 800e6c4:	7ba3      	ldrb	r3, [r4, #14]
 800e6c6:	7363      	strb	r3, [r4, #13]
			Write_Config ();
 800e6c8:	f7ff ff0c 	bl	800e4e4 <Write_Config>
			Set_Orientation(cp->orient);
 800e6cc:	7b60      	ldrb	r0, [r4, #13]
 800e6ce:	f7fe fd41 	bl	800d154 <Set_Orientation>
			cp->mode = cp->rtn_mode;
 800e6d2:	79e3      	ldrb	r3, [r4, #7]
			Clear_Screen( BKGND_COLOR );
 800e6d4:	2000      	movs	r0, #0
	switch(key){
		case KEYCODE_M: // exit menu mode
			cp->orient = cp->rtn_orient;
			Write_Config ();
			Set_Orientation(cp->orient);
			cp->mode = cp->rtn_mode;
 800e6d6:	71a3      	strb	r3, [r4, #6]
			Clear_Screen( BKGND_COLOR );
 800e6d8:	f7fe fd5a 	bl	800d190 <Clear_Screen>
			Set_Range(cp->sig_range);
 800e6dc:	6b60      	ldr	r0, [r4, #52]	; 0x34
 800e6de:	f7fe fb9b 	bl	800ce18 <Set_Range>
			switch(cp->mode){
 800e6e2:	79a3      	ldrb	r3, [r4, #6]
 800e6e4:	b11b      	cbz	r3, 800e6ee <Do_Keys_Menu+0x52>
 800e6e6:	2b01      	cmp	r3, #1
 800e6e8:	f040 80e2 	bne.w	800e8b0 <Do_Keys_Menu+0x214>
 800e6ec:	e006      	b.n	800e6fc <Do_Keys_Menu+0x60>
			case PHA:
				Init_Spectrum();
 800e6ee:	f000 fbdf 	bl	800eeb0 <Init_Spectrum>
					break;
			}
			Display_Menu_Line(cp->display_height / 2,BKGND_COLOR, TXT_COLOR, msp);
			break;
	}
}
 800e6f2:	b003      	add	sp, #12
 800e6f4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
			Clear_Screen( BKGND_COLOR );
			Set_Range(cp->sig_range);
			switch(cp->mode){
			case PHA:
				Init_Spectrum();
				Display_Spectrum ();
 800e6f8:	f000 bbfe 	b.w	800eef8 <Display_Spectrum>
				break;
			case RATE:
				Init_Rate();
 800e6fc:	f000 fbbe 	bl	800ee7c <Init_Rate>
					break;
			}
			Display_Menu_Line(cp->display_height / 2,BKGND_COLOR, TXT_COLOR, msp);
			break;
	}
}
 800e700:	b003      	add	sp, #12
 800e702:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
				Init_Spectrum();
				Display_Spectrum ();
				break;
			case RATE:
				Init_Rate();
				Display_Rate();
 800e706:	f000 bb03 	b.w	800ed10 <Display_Rate>
				break;
			}
			return;
		case KEYCODE_DOWN:
			// scroll cursor down, menu up
			if(cp->menu_index < (MENU_LINES - 1))
 800e70a:	2b23      	cmp	r3, #35	; 0x23
 800e70c:	d805      	bhi.n	800e71a <Do_Keys_Menu+0x7e>
				cp->menu_index += 1;
 800e70e:	3301      	adds	r3, #1
 800e710:	e001      	b.n	800e716 <Do_Keys_Menu+0x7a>
			Display_Menu(cp->menu_index);
			msp = &menu[cp->menu_index];
			break;
		case KEYCODE_UP:
			// scroll cursor up, menu down
			if(cp->menu_index > 0)
 800e712:	b113      	cbz	r3, 800e71a <Do_Keys_Menu+0x7e>
				cp->menu_index -= 1;
 800e714:	3b01      	subs	r3, #1
 800e716:	4a57      	ldr	r2, [pc, #348]	; (800e874 <Do_Keys_Menu+0x1d8>)
 800e718:	8093      	strh	r3, [r2, #4]
			Display_Menu(cp->menu_index);
 800e71a:	4b56      	ldr	r3, [pc, #344]	; (800e874 <Do_Keys_Menu+0x1d8>)
 800e71c:	f9b3 0004 	ldrsh.w	r0, [r3, #4]
					break;
			}
			Display_Menu_Line(cp->display_height / 2,BKGND_COLOR, TXT_COLOR, msp);
			break;
	}
}
 800e720:	b003      	add	sp, #12
 800e722:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
			break;
		case KEYCODE_UP:
			// scroll cursor up, menu down
			if(cp->menu_index > 0)
				cp->menu_index -= 1;
			Display_Menu(cp->menu_index);
 800e726:	e75b      	b.n	800e5e0 <Display_Menu>
			msp = &menu[cp->menu_index];
			break;
		case KEYCODE_LEFT:
			// execute action or change variable
			switch(msp->type){
 800e728:	7923      	ldrb	r3, [r4, #4]
 800e72a:	4d52      	ldr	r5, [pc, #328]	; (800e874 <Do_Keys_Menu+0x1d8>)
 800e72c:	3b02      	subs	r3, #2
 800e72e:	2b11      	cmp	r3, #17
 800e730:	f200 80af 	bhi.w	800e892 <Do_Keys_Menu+0x1f6>
 800e734:	e8df f013 	tbh	[pc, r3, lsl #1]
 800e738:	00690066 	.word	0x00690066
 800e73c:	005100ad 	.word	0x005100ad
 800e740:	006c0054 	.word	0x006c0054
 800e744:	00150012 	.word	0x00150012
 800e748:	00150015 	.word	0x00150015
 800e74c:	0024001e 	.word	0x0024001e
 800e750:	00380029 	.word	0x00380029
 800e754:	00ad0032 	.word	0x00ad0032
 800e758:	003800ad 	.word	0x003800ad
					break;
				case ACT_RESET_PARAM:
					Menu_Reset_Config();
					break;
				case BOOL_TYPE:
					*((bool *)msp->valp) = FALSE;
 800e75c:	68a3      	ldr	r3, [r4, #8]
 800e75e:	2200      	movs	r2, #0
 800e760:	e062      	b.n	800e828 <Do_Keys_Menu+0x18c>
					break;
				case ENUM_TYPE:
					if(*((u8 *)msp->valp) > msp->min_val){
 800e762:	68a3      	ldr	r3, [r4, #8]
 800e764:	6921      	ldr	r1, [r4, #16]
 800e766:	781a      	ldrb	r2, [r3, #0]
 800e768:	428a      	cmp	r2, r1
 800e76a:	f340 8092 	ble.w	800e892 <Do_Keys_Menu+0x1f6>
						*((u8 *)msp->valp) -= msp->increment;
 800e76e:	7b21      	ldrb	r1, [r4, #12]
 800e770:	1a52      	subs	r2, r2, r1
 800e772:	e059      	b.n	800e828 <Do_Keys_Menu+0x18c>
					if(*((u8 *)msp->valp) > msp->min_val){
						*((u8 *)msp->valp) -= msp->increment;
					}
					break;
				case S8_TYPE:
					if(*((s8 *)msp->valp) > msp->min_val){
 800e774:	68a3      	ldr	r3, [r4, #8]
 800e776:	6921      	ldr	r1, [r4, #16]
 800e778:	781a      	ldrb	r2, [r3, #0]
 800e77a:	b250      	sxtb	r0, r2
 800e77c:	4288      	cmp	r0, r1
 800e77e:	e7f4      	b.n	800e76a <Do_Keys_Menu+0xce>
						*((s8 *)msp->valp) -= msp->increment;
					}
					break;
				case U16_TYPE:
					if(*((u16 *)msp->valp) > msp->min_val){
 800e780:	68a3      	ldr	r3, [r4, #8]
 800e782:	6921      	ldr	r1, [r4, #16]
 800e784:	881a      	ldrh	r2, [r3, #0]
 800e786:	428a      	cmp	r2, r1
 800e788:	e004      	b.n	800e794 <Do_Keys_Menu+0xf8>
						*((u16 *)msp->valp) -= msp->increment;
					}
					break;
				case S16_TYPE:
					if(*((s16 *)msp->valp) > msp->min_val){
 800e78a:	68a3      	ldr	r3, [r4, #8]
 800e78c:	6921      	ldr	r1, [r4, #16]
 800e78e:	881a      	ldrh	r2, [r3, #0]
 800e790:	b210      	sxth	r0, r2
 800e792:	4288      	cmp	r0, r1
 800e794:	dd7d      	ble.n	800e892 <Do_Keys_Menu+0x1f6>
						*((s16 *)msp->valp) -= msp->increment;
 800e796:	89a1      	ldrh	r1, [r4, #12]
 800e798:	1a52      	subs	r2, r2, r1
 800e79a:	e062      	b.n	800e862 <Do_Keys_Menu+0x1c6>
					}
					break;
				case U32_TYPE:
					if(*((u32 *)msp->valp) > msp->min_val){
 800e79c:	68a3      	ldr	r3, [r4, #8]
 800e79e:	6921      	ldr	r1, [r4, #16]
 800e7a0:	681a      	ldr	r2, [r3, #0]
 800e7a2:	428a      	cmp	r2, r1
 800e7a4:	d805      	bhi.n	800e7b2 <Do_Keys_Menu+0x116>
 800e7a6:	e074      	b.n	800e892 <Do_Keys_Menu+0x1f6>
					if(*((s32 *)msp->valp) > msp->min_val){
						*((s32 *)msp->valp) -= msp->increment;
					}
					break;
				case FIXED_TYPE:
					if(*((s32 *)msp->valp) > msp->min_val){
 800e7a8:	68a3      	ldr	r3, [r4, #8]
 800e7aa:	6921      	ldr	r1, [r4, #16]
 800e7ac:	681a      	ldr	r2, [r3, #0]
 800e7ae:	428a      	cmp	r2, r1
 800e7b0:	dd6f      	ble.n	800e892 <Do_Keys_Menu+0x1f6>
						*((s32 *)msp->valp) -= msp->increment;
 800e7b2:	f9b4 100c 	ldrsh.w	r1, [r4, #12]
 800e7b6:	1a52      	subs	r2, r2, r1
 800e7b8:	e06a      	b.n	800e890 <Do_Keys_Menu+0x1f4>
			}
			Display_Menu_Line(cp->display_height / 2, BKGND_COLOR, TXT_COLOR, msp);
			break;
		case KEYCODE_RIGHT:
			// execute action or change variable
			switch(msp->type){
 800e7ba:	7923      	ldrb	r3, [r4, #4]
 800e7bc:	4d2d      	ldr	r5, [pc, #180]	; (800e874 <Do_Keys_Menu+0x1d8>)
 800e7be:	3b02      	subs	r3, #2
 800e7c0:	2b11      	cmp	r3, #17
 800e7c2:	d866      	bhi.n	800e892 <Do_Keys_Menu+0x1f6>
 800e7c4:	e8df f003 	tbb	[pc, r3]
 800e7c8:	0965211e 	.word	0x0965211e
 800e7cc:	2a27240c 	.word	0x2a27240c
 800e7d0:	40373232 	.word	0x40373232
 800e7d4:	654f5c45 	.word	0x654f5c45
 800e7d8:	5c65      	.short	0x5c65
				case COMMENT:
					break;
				case ACT_SAV_CSV:
					Save_Spectrum_CSV();
 800e7da:	f7ff fc2b 	bl	800e034 <Save_Spectrum_CSV>
 800e7de:	e001      	b.n	800e7e4 <Do_Keys_Menu+0x148>
					__Display_Str(22 * CHAR_WIDTH, cp->display_height / 2, BKGND_COLOR, TXT_COLOR, msg_succeed);
					break;
				case ACT_SAV_N42:
					Save_Spectrum_N42();
 800e7e0:	f7ff fb48 	bl	800de74 <Save_Spectrum_N42>
					__Display_Str(22 * CHAR_WIDTH, cp->display_height / 2, BKGND_COLOR, TXT_COLOR, msg_succeed);
 800e7e4:	f9b5 1012 	ldrsh.w	r1, [r5, #18]
 800e7e8:	4b24      	ldr	r3, [pc, #144]	; (800e87c <Do_Keys_Menu+0x1e0>)
 800e7ea:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
 800e7ee:	681b      	ldr	r3, [r3, #0]
 800e7f0:	1049      	asrs	r1, r1, #1
 800e7f2:	9300      	str	r3, [sp, #0]
 800e7f4:	20b0      	movs	r0, #176	; 0xb0
 800e7f6:	b289      	uxth	r1, r1
 800e7f8:	2200      	movs	r2, #0
 800e7fa:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800e7fe:	f7f5 fc96 	bl	800412e <__Display_Str>
					break;
 800e802:	e046      	b.n	800e892 <Do_Keys_Menu+0x1f6>
				case ACT_RECAL:
					Cal_HW();
 800e804:	f7fe fb72 	bl	800ceec <Cal_HW>
 800e808:	e7ec      	b.n	800e7e4 <Do_Keys_Menu+0x148>
					__Display_Str(22 * CHAR_WIDTH, cp->display_height / 2, BKGND_COLOR, TXT_COLOR, msg_succeed);
					//Delay_MS(2000);
					break;
				case ACT_CLR_SPECT:
					Clear_All_Data();
 800e80a:	f7fe fa55 	bl	800ccb8 <Clear_All_Data>
 800e80e:	e7e9      	b.n	800e7e4 <Do_Keys_Menu+0x148>
					__Display_Str(22 * CHAR_WIDTH, cp->display_height / 2, BKGND_COLOR, TXT_COLOR, msg_succeed);
					//Delay_MS(2000);
					break;
				case ACT_RESET_PARAM:
					Menu_Reset_Config();
 800e810:	f7ff ff24 	bl	800e65c <Menu_Reset_Config>
					break;
 800e814:	e03d      	b.n	800e892 <Do_Keys_Menu+0x1f6>
				case BOOL_TYPE:
					*((bool *)msp->valp) = TRUE;
 800e816:	68a3      	ldr	r3, [r4, #8]
 800e818:	2201      	movs	r2, #1
 800e81a:	e005      	b.n	800e828 <Do_Keys_Menu+0x18c>
					break;
				case ENUM_TYPE:
					if(*((u8 *)msp->valp) < msp->max_val){
 800e81c:	68a3      	ldr	r3, [r4, #8]
 800e81e:	6961      	ldr	r1, [r4, #20]
 800e820:	781a      	ldrb	r2, [r3, #0]
 800e822:	428a      	cmp	r2, r1
 800e824:	da35      	bge.n	800e892 <Do_Keys_Menu+0x1f6>
						*((u8 *)msp->valp) += 1;
 800e826:	3201      	adds	r2, #1
 800e828:	701a      	strb	r2, [r3, #0]
 800e82a:	e032      	b.n	800e892 <Do_Keys_Menu+0x1f6>
					if(*((char *)msp->valp) < msp->max_val){
						*((char *)msp->valp) += msp->increment;
					}
					break;
				case U8_TYPE:
					if(*((u8 *)msp->valp) < msp->max_val){
 800e82c:	68a3      	ldr	r3, [r4, #8]
 800e82e:	6961      	ldr	r1, [r4, #20]
 800e830:	781a      	ldrb	r2, [r3, #0]
 800e832:	428a      	cmp	r2, r1
 800e834:	e004      	b.n	800e840 <Do_Keys_Menu+0x1a4>
						*((u8 *)msp->valp) += msp->increment;
					}
					break;
				case S8_TYPE:
					if( *((s8 *)msp->valp) < msp->max_val){
 800e836:	68a3      	ldr	r3, [r4, #8]
 800e838:	6961      	ldr	r1, [r4, #20]
 800e83a:	781a      	ldrb	r2, [r3, #0]
 800e83c:	b250      	sxtb	r0, r2
 800e83e:	4288      	cmp	r0, r1
 800e840:	da27      	bge.n	800e892 <Do_Keys_Menu+0x1f6>
						*((s8 *)msp->valp) += msp->increment;
 800e842:	7b21      	ldrb	r1, [r4, #12]
 800e844:	1852      	adds	r2, r2, r1
 800e846:	e7ef      	b.n	800e828 <Do_Keys_Menu+0x18c>
					}
					break;
				case U16_TYPE:
					if(*((u16 *)msp->valp) < msp->max_val){
 800e848:	68a3      	ldr	r3, [r4, #8]
 800e84a:	6961      	ldr	r1, [r4, #20]
 800e84c:	881a      	ldrh	r2, [r3, #0]
 800e84e:	428a      	cmp	r2, r1
 800e850:	e004      	b.n	800e85c <Do_Keys_Menu+0x1c0>
						*((u16 *)msp->valp) += msp->increment;
					}
					break;
				case S16_TYPE:
					if(*((s16 *)msp->valp) < msp->max_val){
 800e852:	68a3      	ldr	r3, [r4, #8]
 800e854:	6961      	ldr	r1, [r4, #20]
 800e856:	881a      	ldrh	r2, [r3, #0]
 800e858:	b210      	sxth	r0, r2
 800e85a:	4288      	cmp	r0, r1
 800e85c:	da19      	bge.n	800e892 <Do_Keys_Menu+0x1f6>
						*((s16 *)msp->valp) += msp->increment;
 800e85e:	89a1      	ldrh	r1, [r4, #12]
 800e860:	1852      	adds	r2, r2, r1
 800e862:	801a      	strh	r2, [r3, #0]
 800e864:	e015      	b.n	800e892 <Do_Keys_Menu+0x1f6>
					}
					break;
				case U32_TYPE:
					if(*((u32 *)msp->valp) < msp->max_val){
 800e866:	68a3      	ldr	r3, [r4, #8]
 800e868:	6961      	ldr	r1, [r4, #20]
 800e86a:	681a      	ldr	r2, [r3, #0]
 800e86c:	428a      	cmp	r2, r1
 800e86e:	d210      	bcs.n	800e892 <Do_Keys_Menu+0x1f6>
 800e870:	e00b      	b.n	800e88a <Do_Keys_Menu+0x1ee>
 800e872:	bf00      	nop
 800e874:	20003ac8 	.word	0x20003ac8
 800e878:	0801029c 	.word	0x0801029c
 800e87c:	2000182c 	.word	0x2000182c
					if( *((s32 *)msp->valp) < msp->max_val){
						*((s32 *)msp->valp) += msp->increment;
					}
					break;
				case FIXED_TYPE:
					if( *((s32 *)msp->valp) < msp->max_val){
 800e880:	68a3      	ldr	r3, [r4, #8]
 800e882:	6961      	ldr	r1, [r4, #20]
 800e884:	681a      	ldr	r2, [r3, #0]
 800e886:	428a      	cmp	r2, r1
 800e888:	da03      	bge.n	800e892 <Do_Keys_Menu+0x1f6>
						*((s32 *)msp->valp) += msp->increment;
 800e88a:	f9b4 100c 	ldrsh.w	r1, [r4, #12]
 800e88e:	1852      	adds	r2, r2, r1
 800e890:	601a      	str	r2, [r3, #0]
				case FLOAT_TYPE:
					break;
				case STR_TYPE:
					break;
			}
			Display_Menu_Line(cp->display_height / 2,BKGND_COLOR, TXT_COLOR, msp);
 800e892:	4b08      	ldr	r3, [pc, #32]	; (800e8b4 <Do_Keys_Menu+0x218>)
 800e894:	2100      	movs	r1, #0
 800e896:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 800e89a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800e89e:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 800e8a2:	1058      	asrs	r0, r3, #1
 800e8a4:	b280      	uxth	r0, r0
 800e8a6:	4623      	mov	r3, r4
			break;
	}
}
 800e8a8:	b003      	add	sp, #12
 800e8aa:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
				case FLOAT_TYPE:
					break;
				case STR_TYPE:
					break;
			}
			Display_Menu_Line(cp->display_height / 2,BKGND_COLOR, TXT_COLOR, msp);
 800e8ae:	e62d      	b.n	800e50c <Display_Menu_Line>
			break;
	}
}
 800e8b0:	b003      	add	sp, #12
 800e8b2:	bd30      	pop	{r4, r5, pc}
 800e8b4:	20003ac8 	.word	0x20003ac8

0800e8b8 <Scan_Samples>:
static s16 tail = -1; 			// tail of adc ring buffer


#define SAMP_PER_MS 2000

void  Scan_Samples(void){
 800e8b8:	b530      	push	{r4, r5, lr}
 800e8ba:	b089      	sub	sp, #36	; 0x24
	fixed alpha, beta, gamma, peak;
	s16 i;
	configurations *cp = &configuration;


	ADC_Stop();
 800e8bc:	f7fe faf4 	bl	800cea8 <ADC_Stop>
	tail = head = Get_Scan_Pos(); // get current absolute position in adc  buffer
 800e8c0:	f7fe fb8d 	bl	800cfde <Get_Scan_Pos>
 800e8c4:	4b6c      	ldr	r3, [pc, #432]	; (800ea78 <Scan_Samples+0x1c0>)
 800e8c6:	8018      	strh	r0, [r3, #0]
 800e8c8:	8058      	strh	r0, [r3, #2]
		dt = FIXED_HALF;			// sample time 0.5 uS
		tau = fixed_from_int(cp->sig_filter);  // filter time in uS
		alpha = fixed_div(dt, tau + dt);
	}
	*/
	ADC_Start();
 800e8ca:	f7fe faf7 	bl	800cebc <ADC_Start>
	while(TRUE){
		if(tail == head){
 800e8ce:	4c6a      	ldr	r4, [pc, #424]	; (800ea78 <Scan_Samples+0x1c0>)
 800e8d0:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
 800e8d4:	f9b4 3000 	ldrsh.w	r3, [r4]
 800e8d8:	429a      	cmp	r2, r3
 800e8da:	d102      	bne.n	800e8e2 <Scan_Samples+0x2a>
			head = Get_Scan_Pos();
 800e8dc:	f7fe fb7f 	bl	800cfde <Get_Scan_Pos>
 800e8e0:	8020      	strh	r0, [r4, #0]
				tau = fixed_from_int(cp->sig_filter);  // filter time in uS
				alpha = fixed_div(dt, tau + dt);
			}
			*/
		}
		if(tail == head)
 800e8e2:	4a65      	ldr	r2, [pc, #404]	; (800ea78 <Scan_Samples+0x1c0>)
 800e8e4:	8853      	ldrh	r3, [r2, #2]
 800e8e6:	8812      	ldrh	r2, [r2, #0]
 800e8e8:	4293      	cmp	r3, r2
 800e8ea:	d0f0      	beq.n	800e8ce <Scan_Samples+0x16>
			continue;
		// track live time
		if(samp_cntr++ >= SAMP_PER_MS){
 800e8ec:	4a63      	ldr	r2, [pc, #396]	; (800ea7c <Scan_Samples+0x1c4>)
 800e8ee:	6811      	ldr	r1, [r2, #0]
 800e8f0:	1c48      	adds	r0, r1, #1
 800e8f2:	f5b1 6ffa 	cmp.w	r1, #2000	; 0x7d0
 800e8f6:	6010      	str	r0, [r2, #0]
 800e8f8:	d305      	bcc.n	800e906 <Scan_Samples+0x4e>
			live_time++;
 800e8fa:	4961      	ldr	r1, [pc, #388]	; (800ea80 <Scan_Samples+0x1c8>)
 800e8fc:	6808      	ldr	r0, [r1, #0]
 800e8fe:	3001      	adds	r0, #1
 800e900:	6008      	str	r0, [r1, #0]
			samp_cntr = 0;
 800e902:	2100      	movs	r1, #0
 800e904:	6011      	str	r1, [r2, #0]
		}
		// get new value, adjust for zero and inversion at same time
		y = fixed_from_int(zero - scan_buffer[tail++]);
 800e906:	4a5f      	ldr	r2, [pc, #380]	; (800ea84 <Scan_Samples+0x1cc>)
 800e908:	b219      	sxth	r1, r3
 800e90a:	f832 0011 	ldrh.w	r0, [r2, r1, lsl #1]
 800e90e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800e912:	b200      	sxth	r0, r0
 800e914:	f5c0 6000 	rsb	r0, r0, #2048	; 0x800
 800e918:	4350      	muls	r0, r2
 800e91a:	3301      	adds	r3, #1
 800e91c:	4a56      	ldr	r2, [pc, #344]	; (800ea78 <Scan_Samples+0x1c0>)
 800e91e:	b29b      	uxth	r3, r3
 800e920:	8053      	strh	r3, [r2, #2]
		if(tail >= SCAN_BUFFER_SZ){
 800e922:	b21b      	sxth	r3, r3
 800e924:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
			tail = 0;
 800e928:	bfa4      	itt	ge
 800e92a:	2300      	movge	r3, #0
 800e92c:	8053      	strhge	r3, [r2, #2]
 800e92e:	ab03      	add	r3, sp, #12
static s16 tail = -1; 			// tail of adc ring buffer


#define SAMP_PER_MS 2000

void  Scan_Samples(void){
 800e930:	aa09      	add	r2, sp, #36	; 0x24
		*/
		// shift the boxcar window and find derivative
		yp0 =&ybox[0];
		yp1 = &ybox[1];
		for(i = 6; i > 0; i--){	// last box slot gets new y value
			*yp0++ = *yp1++;
 800e932:	f853 1c04 	ldr.w	r1, [r3, #-4]
 800e936:	f843 1c08 	str.w	r1, [r3, #-8]
 800e93a:	3304      	adds	r3, #4
		}
		*/
		// shift the boxcar window and find derivative
		yp0 =&ybox[0];
		yp1 = &ybox[1];
		for(i = 6; i > 0; i--){	// last box slot gets new y value
 800e93c:	4293      	cmp	r3, r2
 800e93e:	d1f8      	bne.n	800e932 <Scan_Samples+0x7a>
		deriv -= *yp0++;
		deriv -= *yp0++;
		alpha = *yp0;
		deriv -= *yp0++;
		beta = *yp0++;
		gamma = *yp0;
 800e940:	9a05      	ldr	r2, [sp, #20]
		deriv = 0;
		yp0 =&ybox[0];
		deriv -= *yp0++;
		deriv -= *yp0++;
		alpha = *yp0;
		deriv -= *yp0++;
 800e942:	9b06      	ldr	r3, [sp, #24]
		beta = *yp0++;
		gamma = *yp0;
		deriv += *yp0++;
		deriv += *yp0++;
 800e944:	9d01      	ldr	r5, [sp, #4]
		deriv = 0;
		yp0 =&ybox[0];
		deriv -= *yp0++;
		deriv -= *yp0++;
		alpha = *yp0;
		deriv -= *yp0++;
 800e946:	18d3      	adds	r3, r2, r3
		// compute the derivative
		deriv = 0;
		yp0 =&ybox[0];
		deriv -= *yp0++;
		deriv -= *yp0++;
		alpha = *yp0;
 800e948:	9903      	ldr	r1, [sp, #12]
		deriv -= *yp0++;
		beta = *yp0++;
		gamma = *yp0;
		deriv += *yp0++;
 800e94a:	181b      	adds	r3, r3, r0
		deriv += *yp0++;
 800e94c:	1b5b      	subs	r3, r3, r5
		deriv += *yp0++;
 800e94e:	9d02      	ldr	r5, [sp, #8]
		*yp0 = y;		// place latest sample in end of boxcar
		// compute the derivative
		deriv = 0;
		yp0 =&ybox[0];
		deriv -= *yp0++;
		deriv -= *yp0++;
 800e950:	1a5b      	subs	r3, r3, r1
		deriv -= *yp0++;
		beta = *yp0++;
		gamma = *yp0;
		deriv += *yp0++;
		deriv += *yp0++;
		deriv += *yp0++;
 800e952:	1b5b      	subs	r3, r3, r5
		// process depending on state
		switch(scan_state){
 800e954:	4d4c      	ldr	r5, [pc, #304]	; (800ea88 <Scan_Samples+0x1d0>)
		yp0 =&ybox[0];
		yp1 = &ybox[1];
		for(i = 6; i > 0; i--){	// last box slot gets new y value
			*yp0++ = *yp1++;
		}
		*yp0 = y;		// place latest sample in end of boxcar
 800e956:	9007      	str	r0, [sp, #28]
		gamma = *yp0;
		deriv += *yp0++;
		deriv += *yp0++;
		deriv += *yp0++;
		// process depending on state
		switch(scan_state){
 800e958:	f895 c000 	ldrb.w	ip, [r5]
		yp0 =&ybox[0];
		deriv -= *yp0++;
		deriv -= *yp0++;
		alpha = *yp0;
		deriv -= *yp0++;
		beta = *yp0++;
 800e95c:	9c04      	ldr	r4, [sp, #16]
		gamma = *yp0;
		deriv += *yp0++;
		deriv += *yp0++;
		deriv += *yp0++;
		// process depending on state
		switch(scan_state){
 800e95e:	f1bc 0f03 	cmp.w	ip, #3
 800e962:	d8b4      	bhi.n	800e8ce <Scan_Samples+0x16>
 800e964:	e8df f00c 	tbb	[pc, ip]
 800e968:	761c0402 	.word	0x761c0402
			case RESTART:
				scan_state = LEADING;
 800e96c:	2201      	movs	r2, #1
 800e96e:	e07f      	b.n	800ea70 <Scan_Samples+0x1b8>
				//cp->scope_valid = FALSE;
				break;
			case LEADING:
				if(cp->sig_type == PULSE_POS && deriv > cp->sig_dvdt_lim){
 800e970:	4a46      	ldr	r2, [pc, #280]	; (800ea8c <Scan_Samples+0x1d4>)
 800e972:	7e91      	ldrb	r1, [r2, #26]
 800e974:	b919      	cbnz	r1, 800e97e <Scan_Samples+0xc6>
 800e976:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800e978:	4293      	cmp	r3, r2
 800e97a:	dd07      	ble.n	800e98c <Scan_Samples+0xd4>
 800e97c:	e004      	b.n	800e988 <Scan_Samples+0xd0>
					scan_state = PEAK;
					break;
				}
				if(cp->sig_type == PULSE_NEG && deriv < cp->sig_dvdt_lim){
 800e97e:	2901      	cmp	r1, #1
 800e980:	d104      	bne.n	800e98c <Scan_Samples+0xd4>
 800e982:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800e984:	4293      	cmp	r3, r2
 800e986:	da01      	bge.n	800e98c <Scan_Samples+0xd4>
					scan_state = PEAK;
 800e988:	2202      	movs	r2, #2
 800e98a:	e071      	b.n	800ea70 <Scan_Samples+0x1b8>
					break;
				}
				// if no pulse then check the zero
				avg_zero = (avg_zero * 20 + y)/21;
 800e98c:	4b3b      	ldr	r3, [pc, #236]	; (800ea7c <Scan_Samples+0x1c4>)
 800e98e:	2114      	movs	r1, #20
 800e990:	685a      	ldr	r2, [r3, #4]
 800e992:	fb01 0002 	mla	r0, r1, r2, r0
 800e996:	2215      	movs	r2, #21
 800e998:	fb90 f0f2 	sdiv	r0, r0, r2
 800e99c:	6058      	str	r0, [r3, #4]
				break;
 800e99e:	e796      	b.n	800e8ce <Scan_Samples+0x16>
			case PEAK:
				// reverse derivative indicates peak
				if(cp->sig_type == PULSE_POS && deriv < 0){
 800e9a0:	483a      	ldr	r0, [pc, #232]	; (800ea8c <Scan_Samples+0x1d4>)
 800e9a2:	7e80      	ldrb	r0, [r0, #26]
 800e9a4:	b910      	cbnz	r0, 800e9ac <Scan_Samples+0xf4>
 800e9a6:	2b00      	cmp	r3, #0
 800e9a8:	da09      	bge.n	800e9be <Scan_Samples+0x106>
 800e9aa:	e003      	b.n	800e9b4 <Scan_Samples+0xfc>
					scan_state = TAIL;
				}
				if(cp->sig_type == PULSE_NEG && deriv > 0){
 800e9ac:	2801      	cmp	r0, #1
 800e9ae:	d106      	bne.n	800e9be <Scan_Samples+0x106>
 800e9b0:	2b00      	cmp	r3, #0
 800e9b2:	dd04      	ble.n	800e9be <Scan_Samples+0x106>
					scan_state = TAIL;
 800e9b4:	4b34      	ldr	r3, [pc, #208]	; (800ea88 <Scan_Samples+0x1d0>)
 800e9b6:	f04f 0c03 	mov.w	ip, #3
 800e9ba:	f883 c000 	strb.w	ip, [r3]
				}
				if(scan_state == TAIL){
 800e9be:	4b32      	ldr	r3, [pc, #200]	; (800ea88 <Scan_Samples+0x1d0>)
 800e9c0:	f893 c000 	ldrb.w	ip, [r3]
 800e9c4:	f1bc 0f03 	cmp.w	ip, #3
 800e9c8:	d181      	bne.n	800e8ce <Scan_Samples+0x16>
					// handle gaussian approximation if enabled
					if(cp->sig_gaussian){
 800e9ca:	4b30      	ldr	r3, [pc, #192]	; (800ea8c <Scan_Samples+0x1d4>)
 800e9cc:	f893 3020 	ldrb.w	r3, [r3, #32]
 800e9d0:	b19b      	cbz	r3, 800e9fa <Scan_Samples+0x142>
						// p = ((a - g)/(a -2b + g))/2 = position of peak
						peak = (fixed_div((alpha - gamma),(alpha - (2 * beta) + gamma))) / 2;
 800e9d2:	ebc2 0c01 	rsb	ip, r2, r1
						// y(p) = b - ((a - g) * p)/4  = peak value
						peak = beta - (fixed_mul((alpha - gamma), peak) / 4);
 800e9d6:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 800e9da:	fb03 f30c 	mul.w	r3, r3, ip
 800e9de:	1852      	adds	r2, r2, r1
 800e9e0:	ea4f 0e44 	mov.w	lr, r4, lsl #1
 800e9e4:	ebce 0202 	rsb	r2, lr, r2
 800e9e8:	fb93 f3f2 	sdiv	r3, r3, r2
 800e9ec:	fb0c f303 	mul.w	r3, ip, r3
 800e9f0:	4a27      	ldr	r2, [pc, #156]	; (800ea90 <Scan_Samples+0x1d8>)
 800e9f2:	fb93 f3f2 	sdiv	r3, r3, r2
 800e9f6:	191b      	adds	r3, r3, r4
 800e9f8:	e003      	b.n	800ea02 <Scan_Samples+0x14a>
					} else {
						peak = (alpha + beta + gamma) / 3;
 800e9fa:	1863      	adds	r3, r4, r1
 800e9fc:	189b      	adds	r3, r3, r2
 800e9fe:	fb93 f3fc 	sdiv	r3, r3, ip
					}
					if(cp->sig_type == PULSE_NEG){
						peak = -peak;
					}
					// peak now always positive
					if( peak > cp->sig_lo_lim && peak < cp->sig_hi_lim){
 800ea02:	4a22      	ldr	r2, [pc, #136]	; (800ea8c <Scan_Samples+0x1d4>)
						// y(p) = b - ((a - g) * p)/4  = peak value
						peak = beta - (fixed_mul((alpha - gamma), peak) / 4);
					} else {
						peak = (alpha + beta + gamma) / 3;
					}
					if(cp->sig_type == PULSE_NEG){
 800ea04:	2801      	cmp	r0, #1
						peak = -peak;
					}
					// peak now always positive
					if( peak > cp->sig_lo_lim && peak < cp->sig_hi_lim){
 800ea06:	6a91      	ldr	r1, [r2, #40]	; 0x28
						peak = beta - (fixed_mul((alpha - gamma), peak) / 4);
					} else {
						peak = (alpha + beta + gamma) / 3;
					}
					if(cp->sig_type == PULSE_NEG){
						peak = -peak;
 800ea08:	bf08      	it	eq
 800ea0a:	425b      	negeq	r3, r3
					}
					// peak now always positive
					if( peak > cp->sig_lo_lim && peak < cp->sig_hi_lim){
 800ea0c:	428b      	cmp	r3, r1
 800ea0e:	f77f af5e 	ble.w	800e8ce <Scan_Samples+0x16>
 800ea12:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 800ea14:	428b      	cmp	r3, r1
 800ea16:	f6bf af5a 	bge.w	800e8ce <Scan_Samples+0x16>
						bin = fixed_to_int(peak);
						pulse_height[bin]++;  // increment count in spectrum array
 800ea1a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800ea1e:	fb93 f3f1 	sdiv	r3, r3, r1
 800ea22:	491c      	ldr	r1, [pc, #112]	; (800ea94 <Scan_Samples+0x1dc>)
 800ea24:	b21b      	sxth	r3, r3
 800ea26:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
						cur_cnt++;
						// handle rate meter beeping
						if(cp->rate_beep && !alarm_on){
 800ea2a:	f892 2060 	ldrb.w	r2, [r2, #96]	; 0x60
						peak = -peak;
					}
					// peak now always positive
					if( peak > cp->sig_lo_lim && peak < cp->sig_hi_lim){
						bin = fixed_to_int(peak);
						pulse_height[bin]++;  // increment count in spectrum array
 800ea2e:	3001      	adds	r0, #1
 800ea30:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
						cur_cnt++;
 800ea34:	4b11      	ldr	r3, [pc, #68]	; (800ea7c <Scan_Samples+0x1c4>)
 800ea36:	6899      	ldr	r1, [r3, #8]
 800ea38:	3101      	adds	r1, #1
 800ea3a:	6099      	str	r1, [r3, #8]
						// handle rate meter beeping
						if(cp->rate_beep && !alarm_on){
 800ea3c:	2a00      	cmp	r2, #0
 800ea3e:	f43f af46 	beq.w	800e8ce <Scan_Samples+0x16>
 800ea42:	7b1b      	ldrb	r3, [r3, #12]
 800ea44:	2b00      	cmp	r3, #0
 800ea46:	f47f af42 	bne.w	800e8ce <Scan_Samples+0x16>
							Beep(BEEP_500Hz, 10);
 800ea4a:	200a      	movs	r0, #10
 800ea4c:	4601      	mov	r1, r0
 800ea4e:	f7fe fa83 	bl	800cf58 <Beep>
 800ea52:	e73c      	b.n	800e8ce <Scan_Samples+0x16>
					}
				}
				break;
			case TAIL:
				// find where curve turns back to baseline
				if(cp->sig_type == PULSE_POS && deriv >= 0){
 800ea54:	4a0d      	ldr	r2, [pc, #52]	; (800ea8c <Scan_Samples+0x1d4>)
 800ea56:	7e92      	ldrb	r2, [r2, #26]
 800ea58:	b922      	cbnz	r2, 800ea64 <Scan_Samples+0x1ac>
 800ea5a:	2b00      	cmp	r3, #0
 800ea5c:	f6ff af37 	blt.w	800e8ce <Scan_Samples+0x16>
					scan_state = LEADING;
 800ea60:	3201      	adds	r2, #1
 800ea62:	e005      	b.n	800ea70 <Scan_Samples+0x1b8>
				}
				if(cp->sig_type == PULSE_NEG && deriv <= 0){
 800ea64:	2a01      	cmp	r2, #1
 800ea66:	f47f af32 	bne.w	800e8ce <Scan_Samples+0x16>
 800ea6a:	2b00      	cmp	r3, #0
 800ea6c:	f73f af2f 	bgt.w	800e8ce <Scan_Samples+0x16>
					scan_state = LEADING;
 800ea70:	4b05      	ldr	r3, [pc, #20]	; (800ea88 <Scan_Samples+0x1d0>)
 800ea72:	701a      	strb	r2, [r3, #0]
 800ea74:	e72b      	b.n	800e8ce <Scan_Samples+0x16>
 800ea76:	bf00      	nop
 800ea78:	20001830 	.word	0x20001830
 800ea7c:	20004d8c 	.word	0x20004d8c
 800ea80:	20001840 	.word	0x20001840
 800ea84:	20003b34 	.word	0x20003b34
 800ea88:	20001804 	.word	0x20001804
 800ea8c:	20003ac8 	.word	0x20003ac8
 800ea90:	fffff060 	.word	0xfffff060
 800ea94:	20001848 	.word	0x20001848

0800ea98 <Update_Rate>:
	fixed ftmp;
	static u32 last_live_time;

	// update zero adjust
	//tim2 += fixed_to_int(avg_zero) ;
	if(avg_zero < -FIXED_HALF){
 800ea98:	4b20      	ldr	r3, [pc, #128]	; (800eb1c <Update_Rate+0x84>)
 800ea9a:	685b      	ldr	r3, [r3, #4]
 800ea9c:	f513 7ffa 	cmn.w	r3, #500	; 0x1f4
 800eaa0:	da03      	bge.n	800eaaa <Update_Rate+0x12>
		--tim2;
 800eaa2:	4b1f      	ldr	r3, [pc, #124]	; (800eb20 <Update_Rate+0x88>)
 800eaa4:	889a      	ldrh	r2, [r3, #4]
 800eaa6:	3a01      	subs	r2, #1
 800eaa8:	e005      	b.n	800eab6 <Update_Rate+0x1e>
	}
	if(avg_zero > FIXED_HALF){
 800eaaa:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 800eaae:	dd03      	ble.n	800eab8 <Update_Rate+0x20>
		++tim2;
 800eab0:	4b1b      	ldr	r3, [pc, #108]	; (800eb20 <Update_Rate+0x88>)
 800eab2:	889a      	ldrh	r2, [r3, #4]
 800eab4:	3201      	adds	r2, #1
 800eab6:	809a      	strh	r2, [r3, #4]
	}
	TIM2_CCR4 = tim2;
 800eab8:	4b19      	ldr	r3, [pc, #100]	; (800eb20 <Update_Rate+0x88>)
 800eaba:	889a      	ldrh	r2, [r3, #4]
 800eabc:	4b19      	ldr	r3, [pc, #100]	; (800eb24 <Update_Rate+0x8c>)
 800eabe:	601a      	str	r2, [r3, #0]
 800eac0:	4b19      	ldr	r3, [pc, #100]	; (800eb28 <Update_Rate+0x90>)
 Function Name : Update_Rate
 Description : update rate data
 Note: typical rate of 120 cpm comes to 2 pulses per second
 *******************************************************************************/

void Update_Rate(void)
 800eac2:	f503 721e 	add.w	r2, r3, #632	; 0x278
 800eac6:	3206      	adds	r2, #6
	//Display_Fixed(220, 0, TXT_COLOR, BKGND_COLOR, avg_zero);
	// scroll rate table
	rp0 = rp1 = &rate[0];
	rp1++;
	for (n = 1 ; n < MAX_RATE_SLOTS; n++) {
		*rp0++ = *rp1++;
 800eac8:	f833 1c02 	ldrh.w	r1, [r3, #-2]
 800eacc:	f823 1c04 	strh.w	r1, [r3, #-4]
 800ead0:	3302      	adds	r3, #2
	//Display_U16(220, 16, TXT_COLOR, BKGND_COLOR, tim2);
	//Display_Fixed(220, 0, TXT_COLOR, BKGND_COLOR, avg_zero);
	// scroll rate table
	rp0 = rp1 = &rate[0];
	rp1++;
	for (n = 1 ; n < MAX_RATE_SLOTS; n++) {
 800ead2:	4293      	cmp	r3, r2
 800ead4:	d1f8      	bne.n	800eac8 <Update_Rate+0x30>
	}
	// live time varies quite a bit so rate must be averaged
	// live time is in mS
	//live_rate = ((live_rate * 4) + (cur_cnt * 60 * 1000) / (live_time - last_live_time))/5;	// in cpm
	// refresh time in seconds
	live_rate = (cur_cnt * 60) / cp->refresh_time;
 800ead6:	4b11      	ldr	r3, [pc, #68]	; (800eb1c <Update_Rate+0x84>)
 800ead8:	213c      	movs	r1, #60	; 0x3c
 800eada:	689a      	ldr	r2, [r3, #8]
 800eadc:	4351      	muls	r1, r2
 800eade:	4a13      	ldr	r2, [pc, #76]	; (800eb2c <Update_Rate+0x94>)
 800eae0:	f9b2 000a 	ldrsh.w	r0, [r2, #10]
 800eae4:	fbb1 f1f0 	udiv	r1, r1, r0
 800eae8:	4811      	ldr	r0, [pc, #68]	; (800eb30 <Update_Rate+0x98>)
 800eaea:	6001      	str	r1, [r0, #0]
	last_live_time = live_time;
 800eaec:	4811      	ldr	r0, [pc, #68]	; (800eb34 <Update_Rate+0x9c>)
 800eaee:	6800      	ldr	r0, [r0, #0]
 800eaf0:	6118      	str	r0, [r3, #16]
	*rp0 = (u16)live_rate;	// store into end of rate array
 800eaf2:	4811      	ldr	r0, [pc, #68]	; (800eb38 <Update_Rate+0xa0>)
 800eaf4:	f8a0 127e 	strh.w	r1, [r0, #638]	; 0x27e
	cur_cnt = 0;
 800eaf8:	2000      	movs	r0, #0
 800eafa:	6098      	str	r0, [r3, #8]
	// handle alarm
	if(live_rate > cp->rate_alarm && cp->alarm_en){
 800eafc:	6d90      	ldr	r0, [r2, #88]	; 0x58
 800eafe:	4281      	cmp	r1, r0
 800eb00:	d908      	bls.n	800eb14 <Update_Rate+0x7c>
 800eb02:	7a12      	ldrb	r2, [r2, #8]
 800eb04:	b132      	cbz	r2, 800eb14 <Update_Rate+0x7c>
		alarm_on = TRUE;
 800eb06:	2201      	movs	r2, #1
		Beep(BEEP_500Hz, 5000);
 800eb08:	200a      	movs	r0, #10
 800eb0a:	f241 3188 	movw	r1, #5000	; 0x1388
	last_live_time = live_time;
	*rp0 = (u16)live_rate;	// store into end of rate array
	cur_cnt = 0;
	// handle alarm
	if(live_rate > cp->rate_alarm && cp->alarm_en){
		alarm_on = TRUE;
 800eb0e:	731a      	strb	r2, [r3, #12]
		Beep(BEEP_500Hz, 5000);
 800eb10:	f7fe ba22 	b.w	800cf58 <Beep>
	}else {
		alarm_on = FALSE;
 800eb14:	4b01      	ldr	r3, [pc, #4]	; (800eb1c <Update_Rate+0x84>)
 800eb16:	2200      	movs	r2, #0
 800eb18:	731a      	strb	r2, [r3, #12]
	}
}
 800eb1a:	4770      	bx	lr
 800eb1c:	20004d8c 	.word	0x20004d8c
 800eb20:	20001830 	.word	0x20001830
 800eb24:	40000040 	.word	0x40000040
 800eb28:	2000384c 	.word	0x2000384c
 800eb2c:	20003ac8 	.word	0x20003ac8
 800eb30:	20001844 	.word	0x20001844
 800eb34:	20001840 	.word	0x20001840
 800eb38:	20003848 	.word	0x20003848

0800eb3c <Acq_Clear_All>:

/*******************************************************************************
 Function Name : Acq_Clear_All
 Description : clear all data
 *******************************************************************************/
void Acq_Clear_All(void) {
 800eb3c:	b508      	push	{r3, lr}
	//__Display_Str(0, 0, WHITE, PRN, "Clear All");
	bzero(&pulse_height[0], sizeof(pulse_height));
 800eb3e:	2100      	movs	r1, #0
 800eb40:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800eb44:	4808      	ldr	r0, [pc, #32]	; (800eb68 <Acq_Clear_All+0x2c>)
 800eb46:	f001 f9bb 	bl	800fec0 <memset>
	bzero(&rate[0], sizeof(rate));
 800eb4a:	f44f 7220 	mov.w	r2, #640	; 0x280
 800eb4e:	4807      	ldr	r0, [pc, #28]	; (800eb6c <Acq_Clear_All+0x30>)
 800eb50:	2100      	movs	r1, #0
 800eb52:	f001 f9b5 	bl	800fec0 <memset>
	//bzero(&scope[0], sizeof(scope));
	live_time = 0;
 800eb56:	4a06      	ldr	r2, [pc, #24]	; (800eb70 <Acq_Clear_All+0x34>)
 800eb58:	2300      	movs	r3, #0
 800eb5a:	6013      	str	r3, [r2, #0]
	sys_time = 0;
 800eb5c:	4a05      	ldr	r2, [pc, #20]	; (800eb74 <Acq_Clear_All+0x38>)
 800eb5e:	6013      	str	r3, [r2, #0]
	scan_state = RESTART; 	// pulse detection state machine
 800eb60:	4a05      	ldr	r2, [pc, #20]	; (800eb78 <Acq_Clear_All+0x3c>)
 800eb62:	7013      	strb	r3, [r2, #0]
}
 800eb64:	bd08      	pop	{r3, pc}
 800eb66:	bf00      	nop
 800eb68:	20001848 	.word	0x20001848
 800eb6c:	20003848 	.word	0x20003848
 800eb70:	20001840 	.word	0x20001840
 800eb74:	20004b38 	.word	0x20004b38
 800eb78:	20001804 	.word	0x20001804

0800eb7c <CalCalib>:
 Description :  determines curve coefficents from points in config struct
 *******************************************************************************/
void CalCalib(void)
{
	return;
}
 800eb7c:	4770      	bx	lr

0800eb7e <Chan2Energy>:
 *******************************************************************************/
// FIXME: implement calibration here
fixed Chan2Energy(s16 chan)
{
	return fixed_from_int(chan);
}
 800eb7e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800eb82:	4358      	muls	r0, r3
 800eb84:	4770      	bx	lr

0800eb86 <Energy2Chan>:
 Function Name : u16 Energy2Chan(u16 cursor)
 Description : returns cursor position for given energy
 *******************************************************************************/
// FIXME: implement calibration here
s16 Energy2Chan(fixed energy)
{
 800eb86:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800eb8a:	fb90 f0f3 	sdiv	r0, r0, r3
	return(fixed_to_int(energy));
}
 800eb8e:	b200      	sxth	r0, r0
 800eb90:	4770      	bx	lr

0800eb92 <Plot_Graph>:
	x and y are relative to the lower left of graphics area, excluding text below
*******************************************************************************/
void Plot_Graph(s16 x, s16 y, s16 y_old){
	register configurations *cp = &configuration;

	if(x >= cp->graph_width)
 800eb92:	4b3c      	ldr	r3, [pc, #240]	; (800ec84 <Plot_Graph+0xf2>)
/*******************************************************************************
 Function Name : void Plot_Graph(void)
 Description : Updates display
	x and y are relative to the lower left of graphics area, excluding text below
*******************************************************************************/
void Plot_Graph(s16 x, s16 y, s16 y_old){
 800eb94:	b513      	push	{r0, r1, r4, lr}
	register configurations *cp = &configuration;

	if(x >= cp->graph_width)
 800eb96:	8a9b      	ldrh	r3, [r3, #20]
 800eb98:	fa0f fc83 	sxth.w	ip, r3
 800eb9c:	4560      	cmp	r0, ip
 800eb9e:	db01      	blt.n	800eba4 <Plot_Graph+0x12>
		x = cp->graph_width - 1;
 800eba0:	1e58      	subs	r0, r3, #1
 800eba2:	b200      	sxth	r0, r0
	if(x < 0)
		x = 0;
	if(y_old < 0)
		y_old = 0;
	if(y_old >= cp->graph_height)
 800eba4:	4b37      	ldr	r3, [pc, #220]	; (800ec84 <Plot_Graph+0xf2>)
*******************************************************************************/
void Plot_Graph(s16 x, s16 y, s16 y_old){
	register configurations *cp = &configuration;

	if(x >= cp->graph_width)
		x = cp->graph_width - 1;
 800eba6:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
	if(x < 0)
		x = 0;
	if(y_old < 0)
		y_old = 0;
	if(y_old >= cp->graph_height)
 800ebaa:	8adc      	ldrh	r4, [r3, #22]
 800ebac:	fa1f fc82 	uxth.w	ip, r2
 800ebb0:	b223      	sxth	r3, r4
 800ebb2:	429a      	cmp	r2, r3
		y_old = cp->graph_height - 1;
 800ebb4:	bfa8      	it	ge
 800ebb6:	f104 3cff 	addge.w	ip, r4, #4294967295
 800ebba:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if(y < 0)
		y = 0;
	if(y >= cp->graph_height)
 800ebbe:	b222      	sxth	r2, r4
*******************************************************************************/
void Plot_Graph(s16 x, s16 y, s16 y_old){
	register configurations *cp = &configuration;

	if(x >= cp->graph_width)
		x = cp->graph_width - 1;
 800ebc0:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
	if(x < 0)
		x = 0;
	if(y_old < 0)
		y_old = 0;
	if(y_old >= cp->graph_height)
		y_old = cp->graph_height - 1;
 800ebc4:	bfa8      	it	ge
 800ebc6:	fa1f fc8c 	uxthge.w	ip, ip
	if(y < 0)
		y = 0;
	if(y >= cp->graph_height)
 800ebca:	4291      	cmp	r1, r2
*******************************************************************************/
void Plot_Graph(s16 x, s16 y, s16 y_old){
	register configurations *cp = &configuration;

	if(x >= cp->graph_width)
		x = cp->graph_width - 1;
 800ebcc:	b280      	uxth	r0, r0
		y_old = 0;
	if(y_old >= cp->graph_height)
		y_old = cp->graph_height - 1;
	if(y < 0)
		y = 0;
	if(y >= cp->graph_height)
 800ebce:	b28b      	uxth	r3, r1
 800ebd0:	db01      	blt.n	800ebd6 <Plot_Graph+0x44>
		y = cp->graph_height - 1;
 800ebd2:	3c01      	subs	r4, #1
 800ebd4:	b2a3      	uxth	r3, r4
	y += GRAPH_Y;
 800ebd6:	3323      	adds	r3, #35	; 0x23
 800ebd8:	b299      	uxth	r1, r3
	y_old += GRAPH_Y;
	if(cp->graph == DOT){
 800ebda:	4b2a      	ldr	r3, [pc, #168]	; (800ec84 <Plot_Graph+0xf2>)
 800ebdc:	7b1a      	ldrb	r2, [r3, #12]
 800ebde:	b932      	cbnz	r2, 800ebee <Plot_Graph+0x5c>
		Draw_Dot(x, y, SPECT_COLOR);
 800ebe0:	f64f 72ff 	movw	r2, #65535	; 0xffff
		}
		if(y == y_old){
			__Fill_Rectangle((u16)(x - 1), (u16)y, 3, 3, SPECT_COLOR);
		}
	}
}
 800ebe4:	b002      	add	sp, #8
 800ebe6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	if(y >= cp->graph_height)
		y = cp->graph_height - 1;
	y += GRAPH_Y;
	y_old += GRAPH_Y;
	if(cp->graph == DOT){
		Draw_Dot(x, y, SPECT_COLOR);
 800ebea:	f7fe bc15 	b.w	800d418 <Draw_Dot>
	if(y < 0)
		y = 0;
	if(y >= cp->graph_height)
		y = cp->graph_height - 1;
	y += GRAPH_Y;
	y_old += GRAPH_Y;
 800ebee:	f10c 0c23 	add.w	ip, ip, #35	; 0x23
	if(cp->graph == DOT){
		Draw_Dot(x, y, SPECT_COLOR);
	} else if(cp->graph == LINE){
 800ebf2:	2a01      	cmp	r2, #1
	if(y < 0)
		y = 0;
	if(y >= cp->graph_height)
		y = cp->graph_height - 1;
	y += GRAPH_Y;
	y_old += GRAPH_Y;
 800ebf4:	fa1f fc8c 	uxth.w	ip, ip
	if(cp->graph == DOT){
		Draw_Dot(x, y, SPECT_COLOR);
	} else if(cp->graph == LINE){
 800ebf8:	d119      	bne.n	800ec2e <Plot_Graph+0x9c>
		if(y > y_old){
 800ebfa:	b20c      	sxth	r4, r1
 800ebfc:	fa0f f38c 	sxth.w	r3, ip
 800ec00:	429c      	cmp	r4, r3
 800ec02:	dd06      	ble.n	800ec12 <Plot_Graph+0x80>
			__Fill_Rectangle((u16)x, (u16)y_old, 1, (u16)(y - y_old), SPECT_COLOR);
 800ec04:	ebcc 0301 	rsb	r3, ip, r1
 800ec08:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800ec0c:	9100      	str	r1, [sp, #0]
 800ec0e:	4661      	mov	r1, ip
 800ec10:	e029      	b.n	800ec66 <Plot_Graph+0xd4>
		}
		if(y < y_old){
 800ec12:	da07      	bge.n	800ec24 <Plot_Graph+0x92>
			__Fill_Rectangle((u16)x, (u16)y, 1, (u16)(y_old - y), SPECT_COLOR);
 800ec14:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800ec18:	ebc1 0c0c 	rsb	ip, r1, ip
 800ec1c:	9300      	str	r3, [sp, #0]
 800ec1e:	fa1f f38c 	uxth.w	r3, ip
 800ec22:	e02a      	b.n	800ec7a <Plot_Graph+0xe8>
		}
		if(y == y_old){
 800ec24:	d12b      	bne.n	800ec7e <Plot_Graph+0xec>
			__Fill_Rectangle((u16)x, (u16)y, 1, 1, SPECT_COLOR);
 800ec26:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800ec2a:	9300      	str	r3, [sp, #0]
 800ec2c:	e024      	b.n	800ec78 <Plot_Graph+0xe6>
		}
	} else if(cp->graph == FATLINE){
 800ec2e:	2a02      	cmp	r2, #2
 800ec30:	d125      	bne.n	800ec7e <Plot_Graph+0xec>
		if(y > y_old){
 800ec32:	b20a      	sxth	r2, r1
 800ec34:	fa0f f38c 	sxth.w	r3, ip
 800ec38:	429a      	cmp	r2, r3
 800ec3a:	dd09      	ble.n	800ec50 <Plot_Graph+0xbe>
			__Fill_Rectangle((u16)(x - 1), (u16)y_old, 3, (u16)(y - y_old + 2), SPECT_COLOR);
 800ec3c:	3801      	subs	r0, #1
 800ec3e:	f1cc 0302 	rsb	r3, ip, #2
 800ec42:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ec46:	18cb      	adds	r3, r1, r3
 800ec48:	9200      	str	r2, [sp, #0]
 800ec4a:	b280      	uxth	r0, r0
 800ec4c:	4661      	mov	r1, ip
 800ec4e:	e009      	b.n	800ec64 <Plot_Graph+0xd2>
		}
		if(y < y_old){
 800ec50:	da0b      	bge.n	800ec6a <Plot_Graph+0xd8>
			__Fill_Rectangle((u16)(x - 1), (u16)y, 3, (u16)(y_old - y + 2), SPECT_COLOR);
 800ec52:	3801      	subs	r0, #1
 800ec54:	f10c 0c02 	add.w	ip, ip, #2
 800ec58:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ec5c:	ebc1 030c 	rsb	r3, r1, ip
 800ec60:	9200      	str	r2, [sp, #0]
 800ec62:	b280      	uxth	r0, r0
 800ec64:	2203      	movs	r2, #3
 800ec66:	b29b      	uxth	r3, r3
 800ec68:	e007      	b.n	800ec7a <Plot_Graph+0xe8>
		}
		if(y == y_old){
 800ec6a:	d108      	bne.n	800ec7e <Plot_Graph+0xec>
			__Fill_Rectangle((u16)(x - 1), (u16)y, 3, 3, SPECT_COLOR);
 800ec6c:	3801      	subs	r0, #1
 800ec6e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800ec72:	9300      	str	r3, [sp, #0]
 800ec74:	b280      	uxth	r0, r0
 800ec76:	2203      	movs	r2, #3
 800ec78:	4613      	mov	r3, r2
 800ec7a:	f7f5 fa5c 	bl	8004136 <__Fill_Rectangle>
		}
	}
}
 800ec7e:	b002      	add	sp, #8
 800ec80:	bd10      	pop	{r4, pc}
 800ec82:	bf00      	nop
 800ec84:	20003ac8 	.word	0x20003ac8

0800ec88 <Display_Common>:
	register configurations *cp = &configuration;

	// update live count, a horizontal bar
	scale = cp->rate_alarm / cp->display_width;
	tmp = live_rate / scale;
	__Fill_Rectangle(0, RATE_BAR_Y, (u16)tmp, 3, YEL);
 800ec88:	4b1a      	ldr	r3, [pc, #104]	; (800ecf4 <Display_Common+0x6c>)
/*******************************************************************************
 Function Name : void Display_Common(void)
 Description : Updates display that is common to all modes
 *******************************************************************************/

void Display_Common(void){
 800ec8a:	b507      	push	{r0, r1, r2, lr}
	register configurations *cp = &configuration;

	// update live count, a horizontal bar
	scale = cp->rate_alarm / cp->display_width;
	tmp = live_rate / scale;
	__Fill_Rectangle(0, RATE_BAR_Y, (u16)tmp, 3, YEL);
 800ec8c:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
 800ec90:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800ec92:	2000      	movs	r0, #0
 800ec94:	fbb3 f2f2 	udiv	r2, r3, r2
 800ec98:	4b17      	ldr	r3, [pc, #92]	; (800ecf8 <Display_Common+0x70>)
 800ec9a:	211f      	movs	r1, #31
 800ec9c:	681b      	ldr	r3, [r3, #0]
 800ec9e:	fbb3 f2f2 	udiv	r2, r3, r2
 800eca2:	f240 73ff 	movw	r3, #2047	; 0x7ff
 800eca6:	9300      	str	r3, [sp, #0]
 800eca8:	b292      	uxth	r2, r2
 800ecaa:	2303      	movs	r3, #3
 800ecac:	f7f5 fa43 	bl	8004136 <__Fill_Rectangle>
	// update run/stop
	if(stop){
 800ecb0:	4b12      	ldr	r3, [pc, #72]	; (800ecfc <Display_Common+0x74>)
 800ecb2:	781b      	ldrb	r3, [r3, #0]
 800ecb4:	b133      	cbz	r3, 800ecc4 <Display_Common+0x3c>
		__Display_Str(COM_X_PAUSE, MSG_LINE_0, RED, BKGND_COLOR, "#");
 800ecb6:	4b12      	ldr	r3, [pc, #72]	; (800ed00 <Display_Common+0x78>)
 800ecb8:	20b8      	movs	r0, #184	; 0xb8
 800ecba:	9300      	str	r3, [sp, #0]
 800ecbc:	2110      	movs	r1, #16
 800ecbe:	221f      	movs	r2, #31
 800ecc0:	2300      	movs	r3, #0
 800ecc2:	e005      	b.n	800ecd0 <Display_Common+0x48>
	}
	else{
		__Display_Str(COM_X_PAUSE, MSG_LINE_0, GRN, BKGND_COLOR, "\"");
 800ecc4:	4a0f      	ldr	r2, [pc, #60]	; (800ed04 <Display_Common+0x7c>)
 800ecc6:	20b8      	movs	r0, #184	; 0xb8
 800ecc8:	9200      	str	r2, [sp, #0]
 800ecca:	2110      	movs	r1, #16
 800eccc:	f44f 62fc 	mov.w	r2, #2016	; 0x7e0
 800ecd0:	f7f5 fa2d 	bl	800412e <__Display_Str>
	}
	// Update Battery status
	__Display_Str(COM_X_BAT, MSG_LINE_0, Battery_Color[pwr_lvl], BKGND_COLOR, Battery_Status[pwr_lvl]);
 800ecd4:	4b0c      	ldr	r3, [pc, #48]	; (800ed08 <Display_Common+0x80>)
 800ecd6:	20d0      	movs	r0, #208	; 0xd0
 800ecd8:	781a      	ldrb	r2, [r3, #0]
 800ecda:	7819      	ldrb	r1, [r3, #0]
 800ecdc:	4b0b      	ldr	r3, [pc, #44]	; (800ed0c <Display_Common+0x84>)
 800ecde:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 800ece2:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800ece6:	68db      	ldr	r3, [r3, #12]
 800ece8:	2110      	movs	r1, #16
 800ecea:	9300      	str	r3, [sp, #0]
 800ecec:	2300      	movs	r3, #0
 800ecee:	f7f5 fa1e 	bl	800412e <__Display_Str>
}
 800ecf2:	bd0e      	pop	{r1, r2, r3, pc}
 800ecf4:	20003ac8 	.word	0x20003ac8
 800ecf8:	20001844 	.word	0x20001844
 800ecfc:	2000183c 	.word	0x2000183c
 800ed00:	08011398 	.word	0x08011398
 800ed04:	0801139a 	.word	0x0801139a
 800ed08:	20004b44 	.word	0x20004b44
 800ed0c:	08010614 	.word	0x08010614

0800ed10 <Display_Rate>:
	__Display_Str(0, MSG_LINE_1, TXT_COLOR, BKGND_COLOR, msg_rate1);

}

void Display_Rate()
{
 800ed10:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u16  cnt, cnt_prev, cnt_max, cnt_at_cur;
	u16 *rp;
	configurations *cp = &configuration;

	// clear the graphical display
	__Fill_Rectangle(0, RATE_BAR_Y, cp->graph_width, cp->graph_height + 2, BKGND_COLOR);
 800ed14:	4e56      	ldr	r6, [pc, #344]	; (800ee70 <Display_Rate+0x160>)
 800ed16:	f04f 0800 	mov.w	r8, #0
 800ed1a:	8af3      	ldrh	r3, [r6, #22]
 800ed1c:	8ab2      	ldrh	r2, [r6, #20]
 800ed1e:	3302      	adds	r3, #2
 800ed20:	b29b      	uxth	r3, r3
 800ed22:	4640      	mov	r0, r8
 800ed24:	211f      	movs	r1, #31
 800ed26:	f8cd 8000 	str.w	r8, [sp]
 800ed2a:	f7f5 fa04 	bl	8004136 <__Fill_Rectangle>
	// rate[] is unfiltered, filtered result gets plotted
	if(cp->rate_filter){
 800ed2e:	f896 305c 	ldrb.w	r3, [r6, #92]	; 0x5c
 800ed32:	b913      	cbnz	r3, 800ed3a <Display_Rate+0x2a>
 800ed34:	461e      	mov	r6, r3
 800ed36:	4698      	mov	r8, r3
 800ed38:	e062      	b.n	800ee00 <Display_Rate+0xf0>
		// Set up Butterworth low pass filter
		dt = fixed_from_int(cp->refresh_time);
 800ed3a:	f9b6 200a 	ldrsh.w	r2, [r6, #10]
 800ed3e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800ed42:	435a      	muls	r2, r3
		tau = fixed_from_int(cp->rate_filter_coef);
		alpha = fixed_div(dt, tau + dt);
 800ed44:	f9b6 105e 	ldrsh.w	r1, [r6, #94]	; 0x5e
 800ed48:	fb03 fb02 	mul.w	fp, r3, r2
 800ed4c:	fb03 2301 	mla	r3, r3, r1, r2
 800ed50:	46c2      	mov	sl, r8
 800ed52:	fb9b fbf3 	sdiv	fp, fp, r3
 800ed56:	4646      	mov	r6, r8
 800ed58:	4645      	mov	r5, r8
 800ed5a:	4643      	mov	r3, r8
		y_prev = 0;
		cnt_prev = 0;
		cnt_max = 0;
		rp = &rate[0];
		for (n = 0; n < cp->graph_width; n++, rp++) {
 800ed5c:	e02c      	b.n	800edb8 <Display_Rate+0xa8>
			// y(t) = y(t-1) + alpha * (x(t) - y(t-1))
			cnt = *rp;
			x_i = fixed_from_uint(cnt);
			if(x_i < 0)
				x_i = (fixed) 0x7fffffff;
			y_i = y_prev + fixed_mul(alpha, (x_i - y_prev));
 800ed5e:	4a45      	ldr	r2, [pc, #276]	; (800ee74 <Display_Rate+0x164>)
 800ed60:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 800ed64:	f838 2002 	ldrh.w	r2, [r8, r2]
			if(y_i < 0)
				y_i = (fixed) 0x7fffffff;
			y_prev = y_i;
			cnt = fixed_to_uint(y_i);
			Plot_Graph(n, (cnt / rate_vscale), (cnt_prev / rate_vscale));
 800ed68:	b230      	sxth	r0, r6
			// y(t) = y(t-1) + alpha * (x(t) - y(t-1))
			cnt = *rp;
			x_i = fixed_from_uint(cnt);
			if(x_i < 0)
				x_i = (fixed) 0x7fffffff;
			y_i = y_prev + fixed_mul(alpha, (x_i - y_prev));
 800ed6a:	4362      	muls	r2, r4
 800ed6c:	ebca 0202 	rsb	r2, sl, r2
 800ed70:	fb0b f202 	mul.w	r2, fp, r2
 800ed74:	fb92 f2f4 	sdiv	r2, r2, r4
			if(y_i < 0)
 800ed78:	eb12 0a0a 	adds.w	sl, r2, sl
				y_i = (fixed) 0x7fffffff;
			y_prev = y_i;
			cnt = fixed_to_uint(y_i);
			Plot_Graph(n, (cnt / rate_vscale), (cnt_prev / rate_vscale));
 800ed7c:	4a3e      	ldr	r2, [pc, #248]	; (800ee78 <Display_Rate+0x168>)
			cnt = *rp;
			x_i = fixed_from_uint(cnt);
			if(x_i < 0)
				x_i = (fixed) 0x7fffffff;
			y_i = y_prev + fixed_mul(alpha, (x_i - y_prev));
			if(y_i < 0)
 800ed7e:	bf48      	it	mi
 800ed80:	f06f 4a00 	mvnmi.w	sl, #2147483648	; 0x80000000
				y_i = (fixed) 0x7fffffff;
			y_prev = y_i;
			cnt = fixed_to_uint(y_i);
			Plot_Graph(n, (cnt / rate_vscale), (cnt_prev / rate_vscale));
 800ed84:	6812      	ldr	r2, [r2, #0]
				x_i = (fixed) 0x7fffffff;
			y_i = y_prev + fixed_mul(alpha, (x_i - y_prev));
			if(y_i < 0)
				y_i = (fixed) 0x7fffffff;
			y_prev = y_i;
			cnt = fixed_to_uint(y_i);
 800ed86:	fb9a f4f4 	sdiv	r4, sl, r4
 800ed8a:	b2a4      	uxth	r4, r4
			Plot_Graph(n, (cnt / rate_vscale), (cnt_prev / rate_vscale));
 800ed8c:	fb94 f1f2 	sdiv	r1, r4, r2
 800ed90:	fb93 f2f2 	sdiv	r2, r3, r2
 800ed94:	b209      	sxth	r1, r1
 800ed96:	b212      	sxth	r2, r2
 800ed98:	f7ff fefb 	bl	800eb92 <Plot_Graph>
			cnt_prev = cnt;
			if(cnt > cnt_max)
				cnt_max = cnt;
			if(n == cp->rate_cursor)
 800ed9c:	f9b9 3062 	ldrsh.w	r3, [r9, #98]	; 0x62
 800eda0:	42ac      	cmp	r4, r5
 800eda2:	bf28      	it	cs
 800eda4:	4625      	movcs	r5, r4
 800eda6:	429e      	cmp	r6, r3
 800eda8:	bf08      	it	eq
 800edaa:	4627      	moveq	r7, r4
		alpha = fixed_div(dt, tau + dt);
		y_prev = 0;
		cnt_prev = 0;
		cnt_max = 0;
		rp = &rate[0];
		for (n = 0; n < cp->graph_width; n++, rp++) {
 800edac:	3601      	adds	r6, #1
			cnt = fixed_to_uint(y_i);
			Plot_Graph(n, (cnt / rate_vscale), (cnt_prev / rate_vscale));
			cnt_prev = cnt;
			if(cnt > cnt_max)
				cnt_max = cnt;
			if(n == cp->rate_cursor)
 800edae:	b2ad      	uxth	r5, r5
		alpha = fixed_div(dt, tau + dt);
		y_prev = 0;
		cnt_prev = 0;
		cnt_max = 0;
		rp = &rate[0];
		for (n = 0; n < cp->graph_width; n++, rp++) {
 800edb0:	b2b6      	uxth	r6, r6
 800edb2:	f108 0802 	add.w	r8, r8, #2
 800edb6:	4623      	mov	r3, r4
 800edb8:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 800ee70 <Display_Rate+0x160>
 800edbc:	f9b9 2014 	ldrsh.w	r2, [r9, #20]
 800edc0:	4296      	cmp	r6, r2
 800edc2:	dbcc      	blt.n	800ed5e <Display_Rate+0x4e>
 800edc4:	e022      	b.n	800ee0c <Display_Rate+0xfc>
		}
	} else {
		cnt_prev = 0;
		rp = &rate[0];
		for (n = 0; n < cp->graph_width; n++, rp++) {
			cnt = *rp;
 800edc6:	4a2b      	ldr	r2, [pc, #172]	; (800ee74 <Display_Rate+0x164>)
			Plot_Graph(n, (cnt / rate_vscale), (cnt_prev / rate_vscale));
 800edc8:	fa0f f088 	sxth.w	r0, r8
		}
	} else {
		cnt_prev = 0;
		rp = &rate[0];
		for (n = 0; n < cp->graph_width; n++, rp++) {
			cnt = *rp;
 800edcc:	5ab4      	ldrh	r4, [r6, r2]
			Plot_Graph(n, (cnt / rate_vscale), (cnt_prev / rate_vscale));
 800edce:	4a2a      	ldr	r2, [pc, #168]	; (800ee78 <Display_Rate+0x168>)
			cnt_prev = cnt;
			if(cnt > cnt_max)
				cnt_max = cnt;
			if(n == cp->rate_cursor)
 800edd0:	42a5      	cmp	r5, r4
 800edd2:	bf38      	it	cc
 800edd4:	4625      	movcc	r5, r4
	} else {
		cnt_prev = 0;
		rp = &rate[0];
		for (n = 0; n < cp->graph_width; n++, rp++) {
			cnt = *rp;
			Plot_Graph(n, (cnt / rate_vscale), (cnt_prev / rate_vscale));
 800edd6:	6812      	ldr	r2, [r2, #0]
			cnt_prev = cnt;
			if(cnt > cnt_max)
				cnt_max = cnt;
			if(n == cp->rate_cursor)
 800edd8:	b2ad      	uxth	r5, r5
	} else {
		cnt_prev = 0;
		rp = &rate[0];
		for (n = 0; n < cp->graph_width; n++, rp++) {
			cnt = *rp;
			Plot_Graph(n, (cnt / rate_vscale), (cnt_prev / rate_vscale));
 800edda:	fb94 f1f2 	sdiv	r1, r4, r2
 800edde:	fb93 f2f2 	sdiv	r2, r3, r2
 800ede2:	b209      	sxth	r1, r1
 800ede4:	b212      	sxth	r2, r2
 800ede6:	f7ff fed4 	bl	800eb92 <Plot_Graph>
			cnt_prev = cnt;
			if(cnt > cnt_max)
				cnt_max = cnt;
			if(n == cp->rate_cursor)
 800edea:	f9ba 3062 	ldrsh.w	r3, [sl, #98]	; 0x62
				cnt_at_cur = cnt;
		}
	} else {
		cnt_prev = 0;
		rp = &rate[0];
		for (n = 0; n < cp->graph_width; n++, rp++) {
 800edee:	3602      	adds	r6, #2
			cnt = *rp;
			Plot_Graph(n, (cnt / rate_vscale), (cnt_prev / rate_vscale));
			cnt_prev = cnt;
			if(cnt > cnt_max)
				cnt_max = cnt;
			if(n == cp->rate_cursor)
 800edf0:	4598      	cmp	r8, r3
 800edf2:	bf08      	it	eq
 800edf4:	4627      	moveq	r7, r4
				cnt_at_cur = cnt;
		}
	} else {
		cnt_prev = 0;
		rp = &rate[0];
		for (n = 0; n < cp->graph_width; n++, rp++) {
 800edf6:	f108 0801 	add.w	r8, r8, #1
 800edfa:	fa1f f888 	uxth.w	r8, r8
 800edfe:	4623      	mov	r3, r4
 800ee00:	f8df a06c 	ldr.w	sl, [pc, #108]	; 800ee70 <Display_Rate+0x160>
 800ee04:	f9ba 2014 	ldrsh.w	r2, [sl, #20]
 800ee08:	4590      	cmp	r8, r2
 800ee0a:	dbdc      	blt.n	800edc6 <Display_Rate+0xb6>
				cnt_max = cnt;
			if(n == cp->rate_cursor)
				cnt_at_cur = cnt;
		}
	}
	rate_vscale = cnt_max / cp->graph_height + 1;
 800ee0c:	4a18      	ldr	r2, [pc, #96]	; (800ee70 <Display_Rate+0x160>)
 800ee0e:	8ad3      	ldrh	r3, [r2, #22]
	// display cursor
	tmp = cp->rate_cursor;  			// map cursor to display column
 800ee10:	f8b2 0062 	ldrh.w	r0, [r2, #98]	; 0x62
				cnt_max = cnt;
			if(n == cp->rate_cursor)
				cnt_at_cur = cnt;
		}
	}
	rate_vscale = cnt_max / cp->graph_height + 1;
 800ee14:	b219      	sxth	r1, r3
	// display cursor
	tmp = cp->rate_cursor;  			// map cursor to display column
	if(cp->graph == FATLINE){
 800ee16:	7b12      	ldrb	r2, [r2, #12]
				cnt_max = cnt;
			if(n == cp->rate_cursor)
				cnt_at_cur = cnt;
		}
	}
	rate_vscale = cnt_max / cp->graph_height + 1;
 800ee18:	fb95 f5f1 	sdiv	r5, r5, r1
 800ee1c:	4916      	ldr	r1, [pc, #88]	; (800ee78 <Display_Rate+0x168>)
 800ee1e:	3501      	adds	r5, #1
	// display cursor
	tmp = cp->rate_cursor;  			// map cursor to display column
	if(cp->graph == FATLINE){
 800ee20:	2a02      	cmp	r2, #2
				cnt_max = cnt;
			if(n == cp->rate_cursor)
				cnt_at_cur = cnt;
		}
	}
	rate_vscale = cnt_max / cp->graph_height + 1;
 800ee22:	600d      	str	r5, [r1, #0]
	// display cursor
	tmp = cp->rate_cursor;  			// map cursor to display column
	if(cp->graph == FATLINE){
 800ee24:	d109      	bne.n	800ee3a <Display_Rate+0x12a>
		if(tmp == 0)
 800ee26:	2800      	cmp	r0, #0
 800ee28:	bf08      	it	eq
 800ee2a:	2001      	moveq	r0, #1
			tmp = 1;	// avoid negative x
		__Fill_Rectangle(tmp - 1, GRAPH_Y, 3, cp->graph_height, CURSOR_COLOR);
 800ee2c:	321d      	adds	r2, #29
 800ee2e:	3801      	subs	r0, #1
 800ee30:	9200      	str	r2, [sp, #0]
 800ee32:	b280      	uxth	r0, r0
 800ee34:	2123      	movs	r1, #35	; 0x23
 800ee36:	3a1c      	subs	r2, #28
 800ee38:	e003      	b.n	800ee42 <Display_Rate+0x132>
	} else {
		__Fill_Rectangle(tmp, GRAPH_Y, 1, cp->graph_height, CURSOR_COLOR);
 800ee3a:	221f      	movs	r2, #31
 800ee3c:	9200      	str	r2, [sp, #0]
 800ee3e:	2123      	movs	r1, #35	; 0x23
 800ee40:	3a1e      	subs	r2, #30
 800ee42:	f7f5 f978 	bl	8004136 <__Fill_Rectangle>
	}

	Display_U16(RATE_CPM, MSG_LINE_0, TXT_COLOR, BKGND_COLOR, cnt);	// filtered rate
 800ee46:	2110      	movs	r1, #16
 800ee48:	2300      	movs	r3, #0
 800ee4a:	2048      	movs	r0, #72	; 0x48
 800ee4c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ee50:	9400      	str	r4, [sp, #0]
 800ee52:	f7fe fa42 	bl	800d2da <Display_U16>
	Display_U16(RATE_CURSOR, MSG_LINE_1, TXT_COLOR, BKGND_COLOR, cnt_at_cur);	// at cursor
 800ee56:	2100      	movs	r1, #0
 800ee58:	2048      	movs	r0, #72	; 0x48
 800ee5a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ee5e:	460b      	mov	r3, r1
 800ee60:	9700      	str	r7, [sp, #0]
 800ee62:	f7fe fa3a 	bl	800d2da <Display_U16>
	Display_Common();
}
 800ee66:	b003      	add	sp, #12
 800ee68:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		__Fill_Rectangle(tmp, GRAPH_Y, 1, cp->graph_height, CURSOR_COLOR);
	}

	Display_U16(RATE_CPM, MSG_LINE_0, TXT_COLOR, BKGND_COLOR, cnt);	// filtered rate
	Display_U16(RATE_CURSOR, MSG_LINE_1, TXT_COLOR, BKGND_COLOR, cnt_at_cur);	// at cursor
	Display_Common();
 800ee6c:	e70c      	b.n	800ec88 <Display_Common>
 800ee6e:	bf00      	nop
 800ee70:	20003ac8 	.word	0x20003ac8
 800ee74:	20003848 	.word	0x20003848
 800ee78:	20004da0 	.word	0x20004da0

0800ee7c <Init_Rate>:
	x(t) is source
	y(t]) output
*/

void Init_Rate(void)
{
 800ee7c:	b513      	push	{r0, r1, r4, lr}
	register configurations *cp = &configuration;

	Clear_Screen( BKGND_COLOR );
	__Display_Str(0, MSG_LINE_0, TXT_COLOR, BKGND_COLOR, msg_rate0);
 800ee7e:	4c0b      	ldr	r4, [pc, #44]	; (800eeac <Init_Rate+0x30>)

void Init_Rate(void)
{
	register configurations *cp = &configuration;

	Clear_Screen( BKGND_COLOR );
 800ee80:	2000      	movs	r0, #0
 800ee82:	f7fe f985 	bl	800d190 <Clear_Screen>
	__Display_Str(0, MSG_LINE_0, TXT_COLOR, BKGND_COLOR, msg_rate0);
 800ee86:	6a23      	ldr	r3, [r4, #32]
 800ee88:	2000      	movs	r0, #0
 800ee8a:	9300      	str	r3, [sp, #0]
 800ee8c:	2110      	movs	r1, #16
 800ee8e:	4603      	mov	r3, r0
 800ee90:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ee94:	f7f5 f94b 	bl	800412e <__Display_Str>
	__Display_Str(0, MSG_LINE_1, TXT_COLOR, BKGND_COLOR, msg_rate1);
 800ee98:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800ee9a:	2000      	movs	r0, #0
 800ee9c:	9300      	str	r3, [sp, #0]
 800ee9e:	4601      	mov	r1, r0
 800eea0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800eea4:	4603      	mov	r3, r0
 800eea6:	f7f5 f942 	bl	800412e <__Display_Str>

}
 800eeaa:	bd1c      	pop	{r2, r3, r4, pc}
 800eeac:	08010614 	.word	0x08010614

0800eeb0 <Init_Spectrum>:

 *******************************************************************************/

// Initialize the display for spectrum
void Init_Spectrum(void)
{
 800eeb0:	b513      	push	{r0, r1, r4, lr}
	register configurations *cp = &configuration;
	u16 y;

	Clear_Screen( BKGND_COLOR );
	__Display_Str(0, MSG_LINE_0, TXT_COLOR, BKGND_COLOR, msg_pha0);
 800eeb2:	4c0f      	ldr	r4, [pc, #60]	; (800eef0 <Init_Spectrum+0x40>)
void Init_Spectrum(void)
{
	register configurations *cp = &configuration;
	u16 y;

	Clear_Screen( BKGND_COLOR );
 800eeb4:	2000      	movs	r0, #0
 800eeb6:	f7fe f96b 	bl	800d190 <Clear_Screen>
	__Display_Str(0, MSG_LINE_0, TXT_COLOR, BKGND_COLOR, msg_pha0);
 800eeba:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800eebc:	2000      	movs	r0, #0
 800eebe:	9300      	str	r3, [sp, #0]
 800eec0:	2110      	movs	r1, #16
 800eec2:	4603      	mov	r3, r0
 800eec4:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800eec8:	f7f5 f931 	bl	800412e <__Display_Str>
	if(cp->pha_cal){
 800eecc:	4b09      	ldr	r3, [pc, #36]	; (800eef4 <Init_Spectrum+0x44>)
 800eece:	f893 004a 	ldrb.w	r0, [r3, #74]	; 0x4a
 800eed2:	b118      	cbz	r0, 800eedc <Init_Spectrum+0x2c>
		__Display_Str(0, MSG_LINE_1, TXT_COLOR, BKGND_COLOR, msg_pha1_cal);
 800eed4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800eed6:	2000      	movs	r0, #0
 800eed8:	9300      	str	r3, [sp, #0]
 800eeda:	e001      	b.n	800eee0 <Init_Spectrum+0x30>
	}else{
		__Display_Str(0, MSG_LINE_1, TXT_COLOR, BKGND_COLOR, msg_pha1_nocal);
 800eedc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800eede:	9300      	str	r3, [sp, #0]
 800eee0:	4601      	mov	r1, r0
 800eee2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800eee6:	4603      	mov	r3, r0
 800eee8:	f7f5 f921 	bl	800412e <__Display_Str>
	}
}
 800eeec:	bd1c      	pop	{r2, r3, r4, pc}
 800eeee:	bf00      	nop
 800eef0:	08010614 	.word	0x08010614
 800eef4:	20003ac8 	.word	0x20003ac8

0800eef8 <Display_Spectrum>:

void Display_Spectrum(void){
 800eef8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	s16 chan, chan_lo, chan_hi, channels, window;
	s16 cursor_lo, cursor_hi;	// units are channels
	register configurations *cp = &configuration;

	// clear the graphical display
	__Fill_Rectangle(0, RATE_BAR_Y, cp->graph_width, cp->graph_height + 2, BKGND_COLOR);
 800eefc:	4c66      	ldr	r4, [pc, #408]	; (800f098 <Display_Spectrum+0x1a0>)
	}else{
		__Display_Str(0, MSG_LINE_1, TXT_COLOR, BKGND_COLOR, msg_pha1_nocal);
	}
}

void Display_Spectrum(void){
 800eefe:	b089      	sub	sp, #36	; 0x24
	s16 chan, chan_lo, chan_hi, channels, window;
	s16 cursor_lo, cursor_hi;	// units are channels
	register configurations *cp = &configuration;

	// clear the graphical display
	__Fill_Rectangle(0, RATE_BAR_Y, cp->graph_width, cp->graph_height + 2, BKGND_COLOR);
 800ef00:	8ae3      	ldrh	r3, [r4, #22]
 800ef02:	2000      	movs	r0, #0
 800ef04:	3302      	adds	r3, #2
 800ef06:	8aa2      	ldrh	r2, [r4, #20]
 800ef08:	211f      	movs	r1, #31
 800ef0a:	b29b      	uxth	r3, r3
 800ef0c:	9000      	str	r0, [sp, #0]
 800ef0e:	f7f5 f912 	bl	8004136 <__Fill_Rectangle>
	y_max = 0;
	cnt = curs_cnt = 0;
	x_nu = x = 0;
	y = y_old = 0;
	chan_lo = cp->pha_window_lo;
	chan_hi = cp->pha_window_hi;
 800ef12:	f8b4 0040 	ldrh.w	r0, [r4, #64]	; 0x40
	__Fill_Rectangle(0, RATE_BAR_Y, cp->graph_width, cp->graph_height + 2, BKGND_COLOR);
	y_max = 0;
	cnt = curs_cnt = 0;
	x_nu = x = 0;
	y = y_old = 0;
	chan_lo = cp->pha_window_lo;
 800ef16:	f8b4 7042 	ldrh.w	r7, [r4, #66]	; 0x42
	chan_hi = cp->pha_window_hi;
	cursor_hi = cp->pha_cursor_hi;
	cursor_lo = cp->pha_cursor_lo;
 800ef1a:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
	window = chan_hi - chan_lo;
	// display cursor
	x = ((cursor_lo - chan_lo) * cp->graph_width) / window;  		// map cursor to display column
 800ef1e:	1bc5      	subs	r5, r0, r7
 800ef20:	b213      	sxth	r3, r2
	y_max = 0;
	cnt = curs_cnt = 0;
	x_nu = x = 0;
	y = y_old = 0;
	chan_lo = cp->pha_window_lo;
	chan_hi = cp->pha_window_hi;
 800ef22:	9005      	str	r0, [sp, #20]
	cursor_hi = cp->pha_cursor_hi;
	cursor_lo = cp->pha_cursor_lo;
	window = chan_hi - chan_lo;
	// display cursor
	x = ((cursor_lo - chan_lo) * cp->graph_width) / window;  		// map cursor to display column
 800ef24:	b23e      	sxth	r6, r7
 800ef26:	f9b4 0014 	ldrsh.w	r0, [r4, #20]
 800ef2a:	9306      	str	r3, [sp, #24]
 800ef2c:	1b9b      	subs	r3, r3, r6
 800ef2e:	4358      	muls	r0, r3
	x_nu = ((cursor_hi - cursor_lo) * cp->graph_width) / window;	// map cursor width
	x_nu += 1; // do this as cursor_hi == cursor_lo is 1 pixel wide
	if(cp->graph == FATLINE){
 800ef30:	7b23      	ldrb	r3, [r4, #12]
	cnt = curs_cnt = 0;
	x_nu = x = 0;
	y = y_old = 0;
	chan_lo = cp->pha_window_lo;
	chan_hi = cp->pha_window_hi;
	cursor_hi = cp->pha_cursor_hi;
 800ef32:	f8b4 1046 	ldrh.w	r1, [r4, #70]	; 0x46
	cursor_lo = cp->pha_cursor_lo;
	window = chan_hi - chan_lo;
	// display cursor
	x = ((cursor_lo - chan_lo) * cp->graph_width) / window;  		// map cursor to display column
 800ef36:	b22d      	sxth	r5, r5
 800ef38:	fb90 f0f5 	sdiv	r0, r0, r5
	x_nu = ((cursor_hi - cursor_lo) * cp->graph_width) / window;	// map cursor width
	x_nu += 1; // do this as cursor_hi == cursor_lo is 1 pixel wide
	if(cp->graph == FATLINE){
 800ef3c:	2b02      	cmp	r3, #2
	cnt = curs_cnt = 0;
	x_nu = x = 0;
	y = y_old = 0;
	chan_lo = cp->pha_window_lo;
	chan_hi = cp->pha_window_hi;
	cursor_hi = cp->pha_cursor_hi;
 800ef3e:	9103      	str	r1, [sp, #12]
	cursor_lo = cp->pha_cursor_lo;
 800ef40:	9204      	str	r2, [sp, #16]
	window = chan_hi - chan_lo;
	// display cursor
	x = ((cursor_lo - chan_lo) * cp->graph_width) / window;  		// map cursor to display column
 800ef42:	b280      	uxth	r0, r0
	x_nu = ((cursor_hi - cursor_lo) * cp->graph_width) / window;	// map cursor width
	x_nu += 1; // do this as cursor_hi == cursor_lo is 1 pixel wide
	if(cp->graph == FATLINE){
 800ef44:	d10b      	bne.n	800ef5e <Display_Spectrum+0x66>
		if(x <= 0)
 800ef46:	b203      	sxth	r3, r0
 800ef48:	2b00      	cmp	r3, #0
 800ef4a:	bfd8      	it	le
 800ef4c:	2001      	movle	r0, #1
			x = 1;
		__Fill_Rectangle((u16)(x - 1), (u16)GRAPH_Y, (u16)3, (u16)cp->graph_height, CURSOR_COLOR);
 800ef4e:	221f      	movs	r2, #31
 800ef50:	3801      	subs	r0, #1
 800ef52:	8ae3      	ldrh	r3, [r4, #22]
 800ef54:	b280      	uxth	r0, r0
 800ef56:	9200      	str	r2, [sp, #0]
 800ef58:	2123      	movs	r1, #35	; 0x23
 800ef5a:	3a1c      	subs	r2, #28
 800ef5c:	e004      	b.n	800ef68 <Display_Spectrum+0x70>
	} else {
		__Fill_Rectangle((u16)x, (u16)GRAPH_Y, 1, (u16)cp->graph_height, CURSOR_COLOR);
 800ef5e:	221f      	movs	r2, #31
 800ef60:	8ae3      	ldrh	r3, [r4, #22]
 800ef62:	2123      	movs	r1, #35	; 0x23
 800ef64:	9200      	str	r2, [sp, #0]
 800ef66:	3a1e      	subs	r2, #30
 800ef68:	f7f5 f8e5 	bl	8004136 <__Fill_Rectangle>
	}

	// display the spectrum
	x = ((chan - chan_lo) * cp->graph_width) / window;  // map channel to display column;
 800ef6c:	4b4a      	ldr	r3, [pc, #296]	; (800f098 <Display_Spectrum+0x1a0>)
 800ef6e:	4276      	negs	r6, r6
 800ef70:	f9b3 0014 	ldrsh.w	r0, [r3, #20]
	y_old = 0;
	y_max = 0;
	cnt_max = 0;
	chanp = &pulse_height[chan_lo];
 800ef74:	4b49      	ldr	r3, [pc, #292]	; (800f09c <Display_Spectrum+0x1a4>)
	} else {
		__Fill_Rectangle((u16)x, (u16)GRAPH_Y, 1, (u16)cp->graph_height, CURSOR_COLOR);
	}

	// display the spectrum
	x = ((chan - chan_lo) * cp->graph_width) / window;  // map channel to display column;
 800ef76:	4370      	muls	r0, r6
	y_old = 0;
	y_max = 0;
	cnt_max = 0;
	chanp = &pulse_height[chan_lo];
 800ef78:	fa0f f887 	sxth.w	r8, r7
 800ef7c:	2600      	movs	r6, #0
 800ef7e:	eb03 0388 	add.w	r3, r3, r8, lsl #2
	} else {
		__Fill_Rectangle((u16)x, (u16)GRAPH_Y, 1, (u16)cp->graph_height, CURSOR_COLOR);
	}

	// display the spectrum
	x = ((chan - chan_lo) * cp->graph_width) / window;  // map channel to display column;
 800ef82:	fb90 f0f5 	sdiv	r0, r0, r5
	y_old = 0;
	y_max = 0;
	cnt_max = 0;
	chanp = &pulse_height[chan_lo];
 800ef86:	9307      	str	r3, [sp, #28]
	} else {
		__Fill_Rectangle((u16)x, (u16)GRAPH_Y, 1, (u16)cp->graph_height, CURSOR_COLOR);
	}

	// display the spectrum
	x = ((chan - chan_lo) * cp->graph_width) / window;  // map channel to display column;
 800ef88:	b280      	uxth	r0, r0
	y_old = 0;
	y_max = 0;
	cnt_max = 0;
	chanp = &pulse_height[chan_lo];
 800ef8a:	b2bf      	uxth	r7, r7
 800ef8c:	4632      	mov	r2, r6
 800ef8e:	46b2      	mov	sl, r6
 800ef90:	46b1      	mov	r9, r6
 800ef92:	4633      	mov	r3, r6
	for (chan = chan_lo; chan <= chan_hi; chanp++, chan++) {
 800ef94:	e03b      	b.n	800f00e <Display_Spectrum+0x116>
		// map current channel onto display
		x_nu = ((chan - chan_lo) * cp->graph_width) / window;  // map channel to display column
 800ef96:	f9b4 b014 	ldrsh.w	fp, [r4, #20]
 800ef9a:	fb0b fb06 	mul.w	fp, fp, r6
 800ef9e:	fb9b fbf5 	sdiv	fp, fp, r5
 800efa2:	fa1f fb8b 	uxth.w	fp, fp
		if(x_nu != x || chan == chan_hi){  // plot this column of pixels
 800efa6:	4558      	cmp	r0, fp
 800efa8:	d101      	bne.n	800efae <Display_Spectrum+0xb6>
 800efaa:	458c      	cmp	ip, r1
 800efac:	d10e      	bne.n	800efcc <Display_Spectrum+0xd4>
			if( cnt_max > y_max)	// track to update vertical scale later
				y_max = cnt_max;
			y = cnt_max / pha_vscale;
 800efae:	493c      	ldr	r1, [pc, #240]	; (800f0a0 <Display_Spectrum+0x1a8>)
			Plot_Graph(x, y, y_old);
 800efb0:	b212      	sxth	r2, r2
		// map current channel onto display
		x_nu = ((chan - chan_lo) * cp->graph_width) / window;  // map channel to display column
		if(x_nu != x || chan == chan_hi){  // plot this column of pixels
			if( cnt_max > y_max)	// track to update vertical scale later
				y_max = cnt_max;
			y = cnt_max / pha_vscale;
 800efb2:	684c      	ldr	r4, [r1, #4]
			Plot_Graph(x, y, y_old);
 800efb4:	b200      	sxth	r0, r0
		// map current channel onto display
		x_nu = ((chan - chan_lo) * cp->graph_width) / window;  // map channel to display column
		if(x_nu != x || chan == chan_hi){  // plot this column of pixels
			if( cnt_max > y_max)	// track to update vertical scale later
				y_max = cnt_max;
			y = cnt_max / pha_vscale;
 800efb6:	fbb3 f4f4 	udiv	r4, r3, r4
 800efba:	b2a4      	uxth	r4, r4
			Plot_Graph(x, y, y_old);
 800efbc:	b221      	sxth	r1, r4
	cnt_max = 0;
	chanp = &pulse_height[chan_lo];
	for (chan = chan_lo; chan <= chan_hi; chanp++, chan++) {
		// map current channel onto display
		x_nu = ((chan - chan_lo) * cp->graph_width) / window;  // map channel to display column
		if(x_nu != x || chan == chan_hi){  // plot this column of pixels
 800efbe:	459a      	cmp	sl, r3
 800efc0:	bf38      	it	cc
 800efc2:	469a      	movcc	sl, r3
			if( cnt_max > y_max)	// track to update vertical scale later
				y_max = cnt_max;
			y = cnt_max / pha_vscale;
			Plot_Graph(x, y, y_old);
 800efc4:	f7ff fde5 	bl	800eb92 <Plot_Graph>
 800efc8:	b2a2      	uxth	r2, r4
 800efca:	2300      	movs	r3, #0
			cnt_max = 0;
			x = x_nu;
			y_old = y;
		}
		cnt = *chanp;
 800efcc:	9807      	ldr	r0, [sp, #28]
 800efce:	f850 1026 	ldr.w	r1, [r0, r6, lsl #2]
		if(cp->pha_energy_comp){	// compensate for poor high energy response
 800efd2:	4831      	ldr	r0, [pc, #196]	; (800f098 <Display_Spectrum+0x1a0>)
 800efd4:	f890 003a 	ldrb.w	r0, [r0, #58]	; 0x3a
 800efd8:	b108      	cbz	r0, 800efde <Display_Spectrum+0xe6>
			cnt *= chan;
 800efda:	fb08 f101 	mul.w	r1, r8, r1
		}
		// find max as # channels mapping to 1 pixel column varies
		if(cnt > cnt_max)
			cnt_max = cnt;
		// find total counts under cursor
		if(cursor_lo <= chan && chan <= cursor_hi)
 800efde:	f8dd e010 	ldr.w	lr, [sp, #16]
 800efe2:	b238      	sxth	r0, r7
 800efe4:	fa0f fc8e 	sxth.w	ip, lr
 800efe8:	4584      	cmp	ip, r0
 800efea:	dc06      	bgt.n	800effa <Display_Spectrum+0x102>
 800efec:	f8dd e00c 	ldr.w	lr, [sp, #12]
 800eff0:	fa0f fc8e 	sxth.w	ip, lr
 800eff4:	4560      	cmp	r0, ip
			curs_cnt += cnt;
 800eff6:	bfd8      	it	le
 800eff8:	4489      	addle	r9, r1
	x = ((chan - chan_lo) * cp->graph_width) / window;  // map channel to display column;
	y_old = 0;
	y_max = 0;
	cnt_max = 0;
	chanp = &pulse_height[chan_lo];
	for (chan = chan_lo; chan <= chan_hi; chanp++, chan++) {
 800effa:	3701      	adds	r7, #1
		// find max as # channels mapping to 1 pixel column varies
		if(cnt > cnt_max)
			cnt_max = cnt;
		// find total counts under cursor
		if(cursor_lo <= chan && chan <= cursor_hi)
			curs_cnt += cnt;
 800effc:	428b      	cmp	r3, r1
 800effe:	bf38      	it	cc
 800f000:	460b      	movcc	r3, r1
	x = ((chan - chan_lo) * cp->graph_width) / window;  // map channel to display column;
	y_old = 0;
	y_max = 0;
	cnt_max = 0;
	chanp = &pulse_height[chan_lo];
	for (chan = chan_lo; chan <= chan_hi; chanp++, chan++) {
 800f002:	b2bf      	uxth	r7, r7
 800f004:	3601      	adds	r6, #1
 800f006:	f108 0801 	add.w	r8, r8, #1
 800f00a:	fa1f f08b 	uxth.w	r0, fp
 800f00e:	f8dd e014 	ldr.w	lr, [sp, #20]
 800f012:	fa0f fc87 	sxth.w	ip, r7
 800f016:	fa0f f18e 	sxth.w	r1, lr
 800f01a:	458c      	cmp	ip, r1
 800f01c:	4c1e      	ldr	r4, [pc, #120]	; (800f098 <Display_Spectrum+0x1a0>)
 800f01e:	ddba      	ble.n	800ef96 <Display_Spectrum+0x9e>
			cnt_max = cnt;
		// find total counts under cursor
		if(cursor_lo <= chan && chan <= cursor_hi)
			curs_cnt += cnt;
	}
	pha_vscale = (y_max / cp->graph_height) + 1;
 800f020:	f9b4 2016 	ldrsh.w	r2, [r4, #22]
 800f024:	4b1e      	ldr	r3, [pc, #120]	; (800f0a0 <Display_Spectrum+0x1a8>)
 800f026:	fbba faf2 	udiv	sl, sl, r2
 800f02a:	f10a 0201 	add.w	r2, sl, #1
 800f02e:	605a      	str	r2, [r3, #4]
	// update numeric display
	Display_U8(PHA_X_ZOOM, MSG_LINE_0, TXT_COLOR, BKGND_COLOR, cp->pha_zoom);
 800f030:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800f034:	2110      	movs	r1, #16
 800f036:	9300      	str	r3, [sp, #0]
 800f038:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800f03c:	2300      	movs	r3, #0
 800f03e:	2068      	movs	r0, #104	; 0x68
 800f040:	f7fe f9b8 	bl	800d3b4 <Display_U8>
	Display_U32(PHA_X_CURS_CNT, MSG_LINE_1, TXT_COLOR, BKGND_COLOR, curs_cnt);
 800f044:	2000      	movs	r0, #0
 800f046:	4601      	mov	r1, r0
 800f048:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800f04c:	4603      	mov	r3, r0
 800f04e:	f8cd 9000 	str.w	r9, [sp]
 800f052:	f7fe f92b 	bl	800d2ac <Display_U32>
	chan = (cursor_hi + cursor_lo) / 2;
 800f056:	9903      	ldr	r1, [sp, #12]
 800f058:	9a06      	ldr	r2, [sp, #24]
 800f05a:	b208      	sxth	r0, r1
 800f05c:	1880      	adds	r0, r0, r2
 800f05e:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
	if(cp->pha_cal){
 800f062:	f894 104a 	ldrb.w	r1, [r4, #74]	; 0x4a
	}
	pha_vscale = (y_max / cp->graph_height) + 1;
	// update numeric display
	Display_U8(PHA_X_ZOOM, MSG_LINE_0, TXT_COLOR, BKGND_COLOR, cp->pha_zoom);
	Display_U32(PHA_X_CURS_CNT, MSG_LINE_1, TXT_COLOR, BKGND_COLOR, curs_cnt);
	chan = (cursor_hi + cursor_lo) / 2;
 800f066:	1040      	asrs	r0, r0, #1
 800f068:	b200      	sxth	r0, r0
	if(cp->pha_cal){
 800f06a:	b151      	cbz	r1, 800f082 <Display_Spectrum+0x18a>
		Display_Fixed(PHA_X_CURS_KEV, MSG_LINE_1, TXT_COLOR, BKGND_COLOR, Chan2Energy(chan));
 800f06c:	f7ff fd87 	bl	800eb7e <Chan2Energy>
 800f070:	2100      	movs	r1, #0
 800f072:	9000      	str	r0, [sp, #0]
 800f074:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800f078:	2078      	movs	r0, #120	; 0x78
 800f07a:	460b      	mov	r3, r1
 800f07c:	f7fe f8bc 	bl	800d1f8 <Display_Fixed>
 800f080:	e006      	b.n	800f090 <Display_Spectrum+0x198>
	}else{
		Display_U16(PHA_X_CURS_KEV, MSG_LINE_1, TXT_COLOR, BKGND_COLOR, chan);
 800f082:	9000      	str	r0, [sp, #0]
 800f084:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800f088:	2078      	movs	r0, #120	; 0x78
 800f08a:	460b      	mov	r3, r1
 800f08c:	f7fe f925 	bl	800d2da <Display_U16>
	}
	Display_Common();
}
 800f090:	b009      	add	sp, #36	; 0x24
 800f092:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if(cp->pha_cal){
		Display_Fixed(PHA_X_CURS_KEV, MSG_LINE_1, TXT_COLOR, BKGND_COLOR, Chan2Energy(chan));
	}else{
		Display_U16(PHA_X_CURS_KEV, MSG_LINE_1, TXT_COLOR, BKGND_COLOR, chan);
	}
	Display_Common();
 800f096:	e5f7      	b.n	800ec88 <Display_Common>
 800f098:	20003ac8 	.word	0x20003ac8
 800f09c:	20001848 	.word	0x20001848
 800f0a0:	20004da0 	.word	0x20004da0

0800f0a4 <Disp_Clear_All>:

/*******************************************************************************
 Function Name : Clear_All
 Description : clear all data
 *******************************************************************************/
void Disp_Clear_All(void) {
 800f0a4:	b508      	push	{r3, lr}
	register configurations *cp = &configuration;

	//__Display_Str(0, 0, WHITE, "Clear All");
	bzero(&pulse_height[0], sizeof(pulse_height));
 800f0a6:	2100      	movs	r1, #0
 800f0a8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800f0ac:	4811      	ldr	r0, [pc, #68]	; (800f0f4 <Disp_Clear_All+0x50>)
 800f0ae:	f000 ff07 	bl	800fec0 <memset>
	bzero(&rate[0], sizeof(rate));
 800f0b2:	f44f 7220 	mov.w	r2, #640	; 0x280
 800f0b6:	4810      	ldr	r0, [pc, #64]	; (800f0f8 <Disp_Clear_All+0x54>)
 800f0b8:	2100      	movs	r1, #0
 800f0ba:	f000 ff01 	bl	800fec0 <memset>
	//bzero(&scope[0], sizeof(scope));
	cp->pha_window_hi = cp->pha_channels - 1;
 800f0be:	4b0f      	ldr	r3, [pc, #60]	; (800f0fc <Disp_Clear_All+0x58>)
 800f0c0:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
 800f0c2:	3a01      	subs	r2, #1
 800f0c4:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
	cp->pha_window_lo = 0;
 800f0c8:	f04f 0200 	mov.w	r2, #0
 800f0cc:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
	cp->pha_cursor_hi = cp->pha_cursor_lo = cp->graph_width / 2;
 800f0d0:	f9b3 2014 	ldrsh.w	r2, [r3, #20]
 800f0d4:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
 800f0d8:	1052      	asrs	r2, r2, #1
 800f0da:	b292      	uxth	r2, r2
 800f0dc:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
 800f0e0:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
	cp->pha_zoom = 1;
 800f0e4:	2201      	movs	r2, #1
 800f0e6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	pha_vscale = 1;
 800f0ea:	4b05      	ldr	r3, [pc, #20]	; (800f100 <Disp_Clear_All+0x5c>)
 800f0ec:	605a      	str	r2, [r3, #4]
	rate_vscale = 1;
 800f0ee:	601a      	str	r2, [r3, #0]
}
 800f0f0:	bd08      	pop	{r3, pc}
 800f0f2:	bf00      	nop
 800f0f4:	20001848 	.word	0x20001848
 800f0f8:	20003848 	.word	0x20003848
 800f0fc:	20003ac8 	.word	0x20003ac8
 800f100:	20004da0 	.word	0x20004da0

0800f104 <FLASH_SetLatency>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Sets the Latency value */
  FLASH->ACR &= ACR_LATENCY_Mask;
 800f104:	4b04      	ldr	r3, [pc, #16]	; (800f118 <FLASH_SetLatency+0x14>)
 800f106:	681a      	ldr	r2, [r3, #0]
 800f108:	f002 0238 	and.w	r2, r2, #56	; 0x38
 800f10c:	601a      	str	r2, [r3, #0]
  FLASH->ACR |= FLASH_Latency;
 800f10e:	681a      	ldr	r2, [r3, #0]
 800f110:	ea40 0202 	orr.w	r2, r0, r2
 800f114:	601a      	str	r2, [r3, #0]
}
 800f116:	4770      	bx	lr
 800f118:	40022000 	.word	0x40022000

0800f11c <FLASH_HalfCycleAccessCmd>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
  
  /* Enable or disable the Half cycle access */
  FLASH->ACR &= ACR_HLFCYA_Mask;
 800f11c:	4b04      	ldr	r3, [pc, #16]	; (800f130 <FLASH_HalfCycleAccessCmd+0x14>)
 800f11e:	681a      	ldr	r2, [r3, #0]
 800f120:	f022 0208 	bic.w	r2, r2, #8
 800f124:	601a      	str	r2, [r3, #0]
  FLASH->ACR |= FLASH_HalfCycleAccess;
 800f126:	681a      	ldr	r2, [r3, #0]
 800f128:	ea40 0202 	orr.w	r2, r0, r2
 800f12c:	601a      	str	r2, [r3, #0]
}
 800f12e:	4770      	bx	lr
 800f130:	40022000 	.word	0x40022000

0800f134 <FLASH_PrefetchBufferCmd>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
  
  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
 800f134:	4b04      	ldr	r3, [pc, #16]	; (800f148 <FLASH_PrefetchBufferCmd+0x14>)
 800f136:	681a      	ldr	r2, [r3, #0]
 800f138:	f022 0210 	bic.w	r2, r2, #16
 800f13c:	601a      	str	r2, [r3, #0]
  FLASH->ACR |= FLASH_PrefetchBuffer;
 800f13e:	681a      	ldr	r2, [r3, #0]
 800f140:	ea40 0202 	orr.w	r2, r0, r2
 800f144:	601a      	str	r2, [r3, #0]
}
 800f146:	4770      	bx	lr
 800f148:	40022000 	.word	0x40022000

0800f14c <FLASH_Unlock>:
* Return         : None
*******************************************************************************/
void FLASH_Unlock(void)
{
  /* Authorize the FPEC Access */
  FLASH->KEYR = FLASH_KEY1;
 800f14c:	4b02      	ldr	r3, [pc, #8]	; (800f158 <FLASH_Unlock+0xc>)
 800f14e:	4a03      	ldr	r2, [pc, #12]	; (800f15c <FLASH_Unlock+0x10>)
 800f150:	605a      	str	r2, [r3, #4]
  FLASH->KEYR = FLASH_KEY2;
 800f152:	4a03      	ldr	r2, [pc, #12]	; (800f160 <FLASH_Unlock+0x14>)
 800f154:	605a      	str	r2, [r3, #4]
}
 800f156:	4770      	bx	lr
 800f158:	40022000 	.word	0x40022000
 800f15c:	45670123 	.word	0x45670123
 800f160:	cdef89ab 	.word	0xcdef89ab

0800f164 <FLASH_Lock>:
* Return         : None
*******************************************************************************/
void FLASH_Lock(void)
{
  /* Set the Lock Bit to lock the FPEC and the FCR */
  FLASH->CR |= CR_LOCK_Set;
 800f164:	4b02      	ldr	r3, [pc, #8]	; (800f170 <FLASH_Lock+0xc>)
 800f166:	691a      	ldr	r2, [r3, #16]
 800f168:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800f16c:	611a      	str	r2, [r3, #16]
}
 800f16e:	4770      	bx	lr
 800f170:	40022000 	.word	0x40022000

0800f174 <FLASH_GetUserOptionByte>:
*                  and RST_STDBY(Bit2).
*******************************************************************************/
u32 FLASH_GetUserOptionByte(void)
{
  /* Return the User Option Byte */
  return (u32)(FLASH->OBR >> 2);
 800f174:	4b01      	ldr	r3, [pc, #4]	; (800f17c <FLASH_GetUserOptionByte+0x8>)
 800f176:	69d8      	ldr	r0, [r3, #28]
}
 800f178:	0880      	lsrs	r0, r0, #2
 800f17a:	4770      	bx	lr
 800f17c:	40022000 	.word	0x40022000

0800f180 <FLASH_GetWriteProtectionOptionByte>:
* Return         : The FLASH Write Protection  Option Bytes Register value
*******************************************************************************/
u32 FLASH_GetWriteProtectionOptionByte(void)
{
  /* Return the Falsh write protection Register value */
  return (u32)(FLASH->WRPR);
 800f180:	4b01      	ldr	r3, [pc, #4]	; (800f188 <FLASH_GetWriteProtectionOptionByte+0x8>)
 800f182:	6a18      	ldr	r0, [r3, #32]
}
 800f184:	4770      	bx	lr
 800f186:	bf00      	nop
 800f188:	40022000 	.word	0x40022000

0800f18c <FLASH_GetReadOutProtectionStatus>:
*******************************************************************************/
FlagStatus FLASH_GetReadOutProtectionStatus(void)
{
  FlagStatus readoutstatus = RESET;

  if ((FLASH->OBR & RDPRT_Mask) != (u32)RESET)
 800f18c:	4b02      	ldr	r3, [pc, #8]	; (800f198 <FLASH_GetReadOutProtectionStatus+0xc>)
 800f18e:	69d8      	ldr	r0, [r3, #28]
 800f190:	0840      	lsrs	r0, r0, #1
  else
  {
    readoutstatus = RESET;
  }
  return readoutstatus;
}
 800f192:	f000 0001 	and.w	r0, r0, #1
 800f196:	4770      	bx	lr
 800f198:	40022000 	.word	0x40022000

0800f19c <FLASH_GetPrefetchBufferStatus>:
*******************************************************************************/
FlagStatus FLASH_GetPrefetchBufferStatus(void)
{
  FlagStatus bitstatus = RESET;
  
  if ((FLASH->ACR & ACR_PRFTBS_Mask) != (u32)RESET)
 800f19c:	4b02      	ldr	r3, [pc, #8]	; (800f1a8 <FLASH_GetPrefetchBufferStatus+0xc>)
 800f19e:	6818      	ldr	r0, [r3, #0]
 800f1a0:	0940      	lsrs	r0, r0, #5
  {
    bitstatus = RESET;
  }
  /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
  return bitstatus; 
}
 800f1a2:	f000 0001 	and.w	r0, r0, #1
 800f1a6:	4770      	bx	lr
 800f1a8:	40022000 	.word	0x40022000

0800f1ac <FLASH_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_IT(FLASH_IT)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
 800f1ac:	b119      	cbz	r1, 800f1b6 <FLASH_ITConfig+0xa>
  {
    /* Enable the interrupt sources */
    FLASH->CR |= FLASH_IT;
 800f1ae:	4b05      	ldr	r3, [pc, #20]	; (800f1c4 <FLASH_ITConfig+0x18>)
 800f1b0:	691a      	ldr	r2, [r3, #16]
 800f1b2:	4310      	orrs	r0, r2
 800f1b4:	e003      	b.n	800f1be <FLASH_ITConfig+0x12>
  }
  else
  {
    /* Disable the interrupt sources */
    FLASH->CR &= ~(u32)FLASH_IT;
 800f1b6:	4b03      	ldr	r3, [pc, #12]	; (800f1c4 <FLASH_ITConfig+0x18>)
 800f1b8:	691a      	ldr	r2, [r3, #16]
 800f1ba:	ea22 0000 	bic.w	r0, r2, r0
 800f1be:	6118      	str	r0, [r3, #16]
 800f1c0:	4770      	bx	lr
 800f1c2:	bf00      	nop
 800f1c4:	40022000 	.word	0x40022000

0800f1c8 <FLASH_GetFlagStatus>:
  FlagStatus bitstatus = RESET;

  /* Check the parameters */
  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;

  if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
 800f1c8:	2801      	cmp	r0, #1
  {
    if((FLASH->OBR & FLASH_FLAG_OPTERR) != (u32)RESET)
 800f1ca:	4b06      	ldr	r3, [pc, #24]	; (800f1e4 <FLASH_GetFlagStatus+0x1c>)
  FlagStatus bitstatus = RESET;

  /* Check the parameters */
  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;

  if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
 800f1cc:	d103      	bne.n	800f1d6 <FLASH_GetFlagStatus+0xe>
  {
    if((FLASH->OBR & FLASH_FLAG_OPTERR) != (u32)RESET)
 800f1ce:	69d8      	ldr	r0, [r3, #28]
 800f1d0:	f000 0001 	and.w	r0, r0, #1
 800f1d4:	4770      	bx	lr
      bitstatus = RESET;
    }
  }
  else
  {
   if((FLASH->SR & FLASH_FLAG) != (u32)RESET)
 800f1d6:	68db      	ldr	r3, [r3, #12]
 800f1d8:	4218      	tst	r0, r3
 800f1da:	bf0c      	ite	eq
 800f1dc:	2000      	moveq	r0, #0
 800f1de:	2001      	movne	r0, #1
      bitstatus = RESET;
    }
  }
  /* Return the new state of FLASH_FLAG (SET or RESET) */
  return bitstatus;
}
 800f1e0:	4770      	bx	lr
 800f1e2:	bf00      	nop
 800f1e4:	40022000 	.word	0x40022000

0800f1e8 <FLASH_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
  
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
 800f1e8:	4b01      	ldr	r3, [pc, #4]	; (800f1f0 <FLASH_ClearFlag+0x8>)
 800f1ea:	60d8      	str	r0, [r3, #12]
}
 800f1ec:	4770      	bx	lr
 800f1ee:	bf00      	nop
 800f1f0:	40022000 	.word	0x40022000

0800f1f4 <FLASH_GetStatus>:
*******************************************************************************/
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 800f1f4:	4b0a      	ldr	r3, [pc, #40]	; (800f220 <FLASH_GetStatus+0x2c>)
 800f1f6:	68da      	ldr	r2, [r3, #12]
 800f1f8:	f012 0f01 	tst.w	r2, #1
 800f1fc:	d001      	beq.n	800f202 <FLASH_GetStatus+0xe>
 800f1fe:	2001      	movs	r0, #1
 800f200:	4770      	bx	lr
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if(FLASH->SR & FLASH_FLAG_PGERR)
 800f202:	68da      	ldr	r2, [r3, #12]
 800f204:	f012 0f04 	tst.w	r2, #4
 800f208:	d001      	beq.n	800f20e <FLASH_GetStatus+0x1a>
 800f20a:	2002      	movs	r0, #2
 800f20c:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if(FLASH->SR & FLASH_FLAG_WRPRTERR)
 800f20e:	68d8      	ldr	r0, [r3, #12]
 800f210:	f000 0010 	and.w	r0, r0, #16
 800f214:	2800      	cmp	r0, #0
 800f216:	bf14      	ite	ne
 800f218:	2003      	movne	r0, #3
 800f21a:	2004      	moveq	r0, #4
      }
    }
  }
  /* Return the Flash Status */
  return flashstatus;
}
 800f21c:	4770      	bx	lr
 800f21e:	bf00      	nop
 800f220:	40022000 	.word	0x40022000

0800f224 <FLASH_WaitForLastOperation>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_WaitForLastOperation(u32 Timeout)
{ 
 800f224:	b513      	push	{r0, r1, r4, lr}
 800f226:	4604      	mov	r4, r0
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetStatus();
 800f228:	f7ff ffe4 	bl	800f1f4 <FLASH_GetStatus>

  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 800f22c:	e00c      	b.n	800f248 <FLASH_WaitForLastOperation+0x24>
* Output         : None
* Return         : None
*******************************************************************************/
static void delay(void)
{
  vu32 i = 0;
 800f22e:	2300      	movs	r3, #0
 800f230:	9301      	str	r3, [sp, #4]

  for(i = 0xFF; i != 0; i--)
 800f232:	33ff      	adds	r3, #255	; 0xff
 800f234:	e001      	b.n	800f23a <FLASH_WaitForLastOperation+0x16>
 800f236:	9b01      	ldr	r3, [sp, #4]
 800f238:	3b01      	subs	r3, #1
 800f23a:	9301      	str	r3, [sp, #4]
 800f23c:	9b01      	ldr	r3, [sp, #4]
 800f23e:	2b00      	cmp	r3, #0
 800f240:	d1f9      	bne.n	800f236 <FLASH_WaitForLastOperation+0x12>

  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    delay();
    status = FLASH_GetStatus();
 800f242:	f7ff ffd7 	bl	800f1f4 <FLASH_GetStatus>
    Timeout--;
 800f246:	3c01      	subs	r4, #1
   
  /* Check for the Flash Status */
  status = FLASH_GetStatus();

  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 800f248:	2801      	cmp	r0, #1
 800f24a:	d102      	bne.n	800f252 <FLASH_WaitForLastOperation+0x2e>
 800f24c:	2c00      	cmp	r4, #0
 800f24e:	d1ee      	bne.n	800f22e <FLASH_WaitForLastOperation+0xa>
 800f250:	e000      	b.n	800f254 <FLASH_WaitForLastOperation+0x30>
    delay();
    status = FLASH_GetStatus();
    Timeout--;
  }

  if(Timeout == 0x00 )
 800f252:	b904      	cbnz	r4, 800f256 <FLASH_WaitForLastOperation+0x32>
 800f254:	2005      	movs	r0, #5
    status = FLASH_TIMEOUT;
  }

  /* Return the operation status */
  return status;
}
 800f256:	bd1c      	pop	{r2, r3, r4, pc}

0800f258 <FLASH_UserOptionByteConfig>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
{
 800f258:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
 800f25a:	4e11      	ldr	r6, [pc, #68]	; (800f2a0 <FLASH_UserOptionByteConfig+0x48>)
 800f25c:	4b11      	ldr	r3, [pc, #68]	; (800f2a4 <FLASH_UserOptionByteConfig+0x4c>)
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
{
 800f25e:	4604      	mov	r4, r0
  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
 800f260:	60b3      	str	r3, [r6, #8]
  FLASH->OPTKEYR = FLASH_KEY2;
 800f262:	4b11      	ldr	r3, [pc, #68]	; (800f2a8 <FLASH_UserOptionByteConfig+0x50>)
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f264:	200f      	movs	r0, #15
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
  FLASH->OPTKEYR = FLASH_KEY2;
 800f266:	60b3      	str	r3, [r6, #8]
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
{
 800f268:	460d      	mov	r5, r1
 800f26a:	4617      	mov	r7, r2
  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
  FLASH->OPTKEYR = FLASH_KEY2;
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f26c:	f7ff ffda 	bl	800f224 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 800f270:	2804      	cmp	r0, #4
 800f272:	d114      	bne.n	800f29e <FLASH_UserOptionByteConfig+0x46>
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
 800f274:	6933      	ldr	r3, [r6, #16]
           
    OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
 800f276:	f044 04f8 	orr.w	r4, r4, #248	; 0xf8
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
 800f27a:	f043 0310 	orr.w	r3, r3, #16
 800f27e:	6133      	str	r3, [r6, #16]
           
    OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
 800f280:	4325      	orrs	r5, r4
 800f282:	4b0a      	ldr	r3, [pc, #40]	; (800f2ac <FLASH_UserOptionByteConfig+0x54>)
 800f284:	432f      	orrs	r7, r5
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f286:	300b      	adds	r0, #11
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
           
    OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
 800f288:	805f      	strh	r7, [r3, #2]
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f28a:	f7ff ffcb 	bl	800f224 <FLASH_WaitForLastOperation>

    if(status != FLASH_BUSY)
 800f28e:	2801      	cmp	r0, #1
 800f290:	d005      	beq.n	800f29e <FLASH_UserOptionByteConfig+0x46>
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= CR_OPTPG_Reset;
 800f292:	6932      	ldr	r2, [r6, #16]
 800f294:	f641 73ef 	movw	r3, #8175	; 0x1fef
 800f298:	ea02 0303 	and.w	r3, r2, r3
 800f29c:	6133      	str	r3, [r6, #16]
    }
  }    
  /* Return the Option Byte program Status */
  return status;
}
 800f29e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800f2a0:	40022000 	.word	0x40022000
 800f2a4:	45670123 	.word	0x45670123
 800f2a8:	cdef89ab 	.word	0xcdef89ab
 800f2ac:	1ffff800 	.word	0x1ffff800

0800f2b0 <FLASH_ReadOutProtection>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
{
 800f2b0:	b538      	push	{r3, r4, r5, lr}
 800f2b2:	4605      	mov	r5, r0
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  status = FLASH_WaitForLastOperation(EraseTimeout);
 800f2b4:	f640 70ff 	movw	r0, #4095	; 0xfff
 800f2b8:	f7ff ffb4 	bl	800f224 <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 800f2bc:	2804      	cmp	r0, #4
 800f2be:	d13b      	bne.n	800f338 <FLASH_ReadOutProtection+0x88>
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 800f2c0:	4c1e      	ldr	r4, [pc, #120]	; (800f33c <FLASH_ReadOutProtection+0x8c>)
 800f2c2:	4b1f      	ldr	r3, [pc, #124]	; (800f340 <FLASH_ReadOutProtection+0x90>)

    FLASH->CR |= CR_OPTER_Set;
    FLASH->CR |= CR_STRT_Set;

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 800f2c4:	f640 70ff 	movw	r0, #4095	; 0xfff
  status = FLASH_WaitForLastOperation(EraseTimeout);

  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 800f2c8:	60a3      	str	r3, [r4, #8]
    FLASH->OPTKEYR = FLASH_KEY2;
 800f2ca:	4b1e      	ldr	r3, [pc, #120]	; (800f344 <FLASH_ReadOutProtection+0x94>)
 800f2cc:	60a3      	str	r3, [r4, #8]

    FLASH->CR |= CR_OPTER_Set;
 800f2ce:	6923      	ldr	r3, [r4, #16]
 800f2d0:	f043 0320 	orr.w	r3, r3, #32
 800f2d4:	6123      	str	r3, [r4, #16]
    FLASH->CR |= CR_STRT_Set;
 800f2d6:	6923      	ldr	r3, [r4, #16]
 800f2d8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800f2dc:	6123      	str	r3, [r4, #16]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 800f2de:	f7ff ffa1 	bl	800f224 <FLASH_WaitForLastOperation>

    if(status == FLASH_COMPLETE)
 800f2e2:	2804      	cmp	r0, #4
 800f2e4:	d120      	bne.n	800f328 <FLASH_ReadOutProtection+0x78>
    {
      /* if the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= CR_OPTER_Reset;
 800f2e6:	6922      	ldr	r2, [r4, #16]
 800f2e8:	f641 73df 	movw	r3, #8159	; 0x1fdf
 800f2ec:	ea02 0303 	and.w	r3, r2, r3
 800f2f0:	6123      	str	r3, [r4, #16]

      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set; 
 800f2f2:	6923      	ldr	r3, [r4, #16]
 800f2f4:	f043 0310 	orr.w	r3, r3, #16
 800f2f8:	6123      	str	r3, [r4, #16]

      if(NewState != DISABLE)
 800f2fa:	b11d      	cbz	r5, 800f304 <FLASH_ReadOutProtection+0x54>
      {
        OB->RDP = 0x00;
 800f2fc:	4b12      	ldr	r3, [pc, #72]	; (800f348 <FLASH_ReadOutProtection+0x98>)
 800f2fe:	f04f 0200 	mov.w	r2, #0
 800f302:	e002      	b.n	800f30a <FLASH_ReadOutProtection+0x5a>
      }
      else
      {
        OB->RDP = RDP_Key;  
 800f304:	4b10      	ldr	r3, [pc, #64]	; (800f348 <FLASH_ReadOutProtection+0x98>)
 800f306:	f04f 02a5 	mov.w	r2, #165	; 0xa5
 800f30a:	801a      	strh	r2, [r3, #0]
      }

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(EraseTimeout); 
 800f30c:	f640 70ff 	movw	r0, #4095	; 0xfff
 800f310:	f7ff ff88 	bl	800f224 <FLASH_WaitForLastOperation>
    
      if(status != FLASH_BUSY)
 800f314:	2801      	cmp	r0, #1
 800f316:	d00f      	beq.n	800f338 <FLASH_ReadOutProtection+0x88>
      {
        /* if the program operation is completed, disable the OPTPG Bit */
        FLASH->CR &= CR_OPTPG_Reset;
 800f318:	4a08      	ldr	r2, [pc, #32]	; (800f33c <FLASH_ReadOutProtection+0x8c>)
 800f31a:	f641 73ef 	movw	r3, #8175	; 0x1fef
 800f31e:	6911      	ldr	r1, [r2, #16]
 800f320:	ea01 0303 	and.w	r3, r1, r3
 800f324:	6113      	str	r3, [r2, #16]
 800f326:	bd38      	pop	{r3, r4, r5, pc}
      }
    }
    else 
    {
      if(status != FLASH_BUSY)
 800f328:	2801      	cmp	r0, #1
 800f32a:	d005      	beq.n	800f338 <FLASH_ReadOutProtection+0x88>
      {
        /* Disable the OPTER Bit */
        FLASH->CR &= CR_OPTER_Reset;
 800f32c:	6922      	ldr	r2, [r4, #16]
 800f32e:	f641 73df 	movw	r3, #8159	; 0x1fdf
 800f332:	ea02 0303 	and.w	r3, r2, r3
 800f336:	6123      	str	r3, [r4, #16]
      }
    }
  }
  /* Return the protection operation Status */
  return status;      
}
 800f338:	bd38      	pop	{r3, r4, r5, pc}
 800f33a:	bf00      	nop
 800f33c:	40022000 	.word	0x40022000
 800f340:	45670123 	.word	0x45670123
 800f344:	cdef89ab 	.word	0xcdef89ab
 800f348:	1ffff800 	.word	0x1ffff800

0800f34c <FLASH_EnableWriteProtection>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages)
{
 800f34c:	b510      	push	{r4, lr}
 800f34e:	4604      	mov	r4, r0
  WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
  WRP2_Data = (vu16)((FLASH_Pages & WRP2_Mask) >> 16);
  WRP3_Data = (vu16)((FLASH_Pages & WRP3_Mask) >> 24);
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f350:	200f      	movs	r0, #15
 800f352:	f7ff ff67 	bl	800f224 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 800f356:	2804      	cmp	r0, #4
 800f358:	d13e      	bne.n	800f3d8 <FLASH_EnableWriteProtection+0x8c>
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 800f35a:	4b20      	ldr	r3, [pc, #128]	; (800f3dc <FLASH_EnableWriteProtection+0x90>)
 800f35c:	4920      	ldr	r1, [pc, #128]	; (800f3e0 <FLASH_EnableWriteProtection+0x94>)
  FLASH_Status status = FLASH_COMPLETE;
  
  /* Check the parameters */
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (u32)(~FLASH_Pages);
 800f35e:	43e4      	mvns	r4, r4
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 800f360:	6099      	str	r1, [r3, #8]
    FLASH->OPTKEYR = FLASH_KEY2;
 800f362:	4920      	ldr	r1, [pc, #128]	; (800f3e4 <FLASH_EnableWriteProtection+0x98>)
  
  /* Check the parameters */
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (u32)(~FLASH_Pages);
  WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
 800f364:	b2e2      	uxtb	r2, r4
  
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
    FLASH->OPTKEYR = FLASH_KEY2;
 800f366:	6099      	str	r1, [r3, #8]
    FLASH->CR |= CR_OPTPG_Set;
 800f368:	6919      	ldr	r1, [r3, #16]

    if(WRP0_Data != 0xFF)
 800f36a:	2aff      	cmp	r2, #255	; 0xff
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
    FLASH->OPTKEYR = FLASH_KEY2;
    FLASH->CR |= CR_OPTPG_Set;
 800f36c:	f041 0110 	orr.w	r1, r1, #16
 800f370:	6119      	str	r1, [r3, #16]

    if(WRP0_Data != 0xFF)
 800f372:	d006      	beq.n	800f382 <FLASH_EnableWriteProtection+0x36>
    {
      OB->WRP0 = WRP0_Data;
 800f374:	4b1c      	ldr	r3, [pc, #112]	; (800f3e8 <FLASH_EnableWriteProtection+0x9c>)
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f376:	300b      	adds	r0, #11
    FLASH->OPTKEYR = FLASH_KEY2;
    FLASH->CR |= CR_OPTPG_Set;

    if(WRP0_Data != 0xFF)
    {
      OB->WRP0 = WRP0_Data;
 800f378:	811a      	strh	r2, [r3, #8]
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f37a:	f7ff ff53 	bl	800f224 <FLASH_WaitForLastOperation>
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
 800f37e:	2804      	cmp	r0, #4
 800f380:	d121      	bne.n	800f3c6 <FLASH_EnableWriteProtection+0x7a>
  /* Check the parameters */
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (u32)(~FLASH_Pages);
  WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
 800f382:	f404 437f 	and.w	r3, r4, #65280	; 0xff00
 800f386:	0a1b      	lsrs	r3, r3, #8
      OB->WRP0 = WRP0_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
 800f388:	2bff      	cmp	r3, #255	; 0xff
 800f38a:	d006      	beq.n	800f39a <FLASH_EnableWriteProtection+0x4e>
    {
      OB->WRP1 = WRP1_Data;
 800f38c:	4a16      	ldr	r2, [pc, #88]	; (800f3e8 <FLASH_EnableWriteProtection+0x9c>)
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f38e:	200f      	movs	r0, #15
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
    {
      OB->WRP1 = WRP1_Data;
 800f390:	8153      	strh	r3, [r2, #10]
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f392:	f7ff ff47 	bl	800f224 <FLASH_WaitForLastOperation>
    }

    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
 800f396:	2804      	cmp	r0, #4
 800f398:	d115      	bne.n	800f3c6 <FLASH_EnableWriteProtection+0x7a>
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (u32)(~FLASH_Pages);
  WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
  WRP2_Data = (vu16)((FLASH_Pages & WRP2_Mask) >> 16);
 800f39a:	f404 037f 	and.w	r3, r4, #16711680	; 0xff0000
 800f39e:	0c1b      	lsrs	r3, r3, #16
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }

    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
 800f3a0:	2bff      	cmp	r3, #255	; 0xff
 800f3a2:	d006      	beq.n	800f3b2 <FLASH_EnableWriteProtection+0x66>
    {
      OB->WRP2 = WRP2_Data;
 800f3a4:	4a10      	ldr	r2, [pc, #64]	; (800f3e8 <FLASH_EnableWriteProtection+0x9c>)
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f3a6:	200f      	movs	r0, #15
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }

    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
    {
      OB->WRP2 = WRP2_Data;
 800f3a8:	8193      	strh	r3, [r2, #12]
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f3aa:	f7ff ff3b 	bl	800f224 <FLASH_WaitForLastOperation>
    }
    
    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
 800f3ae:	2804      	cmp	r0, #4
 800f3b0:	d109      	bne.n	800f3c6 <FLASH_EnableWriteProtection+0x7a>
  
  FLASH_Pages = (u32)(~FLASH_Pages);
  WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
  WRP2_Data = (vu16)((FLASH_Pages & WRP2_Mask) >> 16);
  WRP3_Data = (vu16)((FLASH_Pages & WRP3_Mask) >> 24);
 800f3b2:	0e24      	lsrs	r4, r4, #24
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    
    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
 800f3b4:	2cff      	cmp	r4, #255	; 0xff
 800f3b6:	d101      	bne.n	800f3bc <FLASH_EnableWriteProtection+0x70>
 800f3b8:	2004      	movs	r0, #4
 800f3ba:	e006      	b.n	800f3ca <FLASH_EnableWriteProtection+0x7e>
    {
      OB->WRP3 = WRP3_Data;
 800f3bc:	4b0a      	ldr	r3, [pc, #40]	; (800f3e8 <FLASH_EnableWriteProtection+0x9c>)
     
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f3be:	200f      	movs	r0, #15
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    
    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
    {
      OB->WRP3 = WRP3_Data;
 800f3c0:	81dc      	strh	r4, [r3, #14]
     
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f3c2:	f7ff ff2f 	bl	800f224 <FLASH_WaitForLastOperation>
    }
          
    if(status != FLASH_BUSY)
 800f3c6:	2801      	cmp	r0, #1
 800f3c8:	d006      	beq.n	800f3d8 <FLASH_EnableWriteProtection+0x8c>
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= CR_OPTPG_Reset;
 800f3ca:	4a04      	ldr	r2, [pc, #16]	; (800f3dc <FLASH_EnableWriteProtection+0x90>)
 800f3cc:	f641 73ef 	movw	r3, #8175	; 0x1fef
 800f3d0:	6911      	ldr	r1, [r2, #16]
 800f3d2:	ea01 0303 	and.w	r3, r1, r3
 800f3d6:	6113      	str	r3, [r2, #16]
    }
  } 
  /* Return the write protection operation Status */
  return status;       
}
 800f3d8:	bd10      	pop	{r4, pc}
 800f3da:	bf00      	nop
 800f3dc:	40022000 	.word	0x40022000
 800f3e0:	45670123 	.word	0x45670123
 800f3e4:	cdef89ab 	.word	0xcdef89ab
 800f3e8:	1ffff800 	.word	0x1ffff800

0800f3ec <FLASH_ProgramOptionByteData>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY=1, 
*                  FLASH_ERROR_PG=2, FLASH_ERROR_WRP=3, FLASH_COMPLETE=4, 
*                  FLASH_TIMEOUT=5.
*******************************************************************************/
FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data)
{
 800f3ec:	b570      	push	{r4, r5, r6, lr}
 800f3ee:	4604      	mov	r4, r0
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_OB_DATA_ADDRESS(Address));

  status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f3f0:	200f      	movs	r0, #15
* Return         : FLASH Status: The returned value can be: FLASH_BUSY=1, 
*                  FLASH_ERROR_PG=2, FLASH_ERROR_WRP=3, FLASH_COMPLETE=4, 
*                  FLASH_TIMEOUT=5.
*******************************************************************************/
FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data)
{
 800f3f2:	460e      	mov	r6, r1
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_OB_DATA_ADDRESS(Address));

  status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f3f4:	f7ff ff16 	bl	800f224 <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 800f3f8:	2804      	cmp	r0, #4
 800f3fa:	d114      	bne.n	800f426 <FLASH_ProgramOptionByteData+0x3a>
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 800f3fc:	4d0a      	ldr	r5, [pc, #40]	; (800f428 <FLASH_ProgramOptionByteData+0x3c>)
 800f3fe:	4b0b      	ldr	r3, [pc, #44]	; (800f42c <FLASH_ProgramOptionByteData+0x40>)
    /* Enables the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
    *(vu16*)Address = Data;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f400:	300b      	adds	r0, #11
  status = FLASH_WaitForLastOperation(ProgramTimeout);

  if(status == FLASH_COMPLETE)
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 800f402:	60ab      	str	r3, [r5, #8]
    FLASH->OPTKEYR = FLASH_KEY2;
 800f404:	4b0a      	ldr	r3, [pc, #40]	; (800f430 <FLASH_ProgramOptionByteData+0x44>)
 800f406:	60ab      	str	r3, [r5, #8]

    /* Enables the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
 800f408:	692b      	ldr	r3, [r5, #16]
 800f40a:	f043 0310 	orr.w	r3, r3, #16
 800f40e:	612b      	str	r3, [r5, #16]
    *(vu16*)Address = Data;
 800f410:	8026      	strh	r6, [r4, #0]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f412:	f7ff ff07 	bl	800f224 <FLASH_WaitForLastOperation>

    if(status != FLASH_BUSY)
 800f416:	2801      	cmp	r0, #1
 800f418:	d005      	beq.n	800f426 <FLASH_ProgramOptionByteData+0x3a>
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= CR_OPTPG_Reset;
 800f41a:	692a      	ldr	r2, [r5, #16]
 800f41c:	f641 73ef 	movw	r3, #8175	; 0x1fef
 800f420:	ea02 0303 	and.w	r3, r2, r3
 800f424:	612b      	str	r3, [r5, #16]
    }
  }    
  /* Return the Option Byte Data Program Status */
  return status;      
}
 800f426:	bd70      	pop	{r4, r5, r6, pc}
 800f428:	40022000 	.word	0x40022000
 800f42c:	45670123 	.word	0x45670123
 800f430:	cdef89ab 	.word	0xcdef89ab

0800f434 <FLASH_ProgramHalfWord>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY=1, 
*                  FLASH_ERROR_PG=2, FLASH_ERROR_WRP=3, FLASH_COMPLETE=4, 
*                  FLASH_TIMEOUT=5.
*******************************************************************************/
FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data)
{
 800f434:	b570      	push	{r4, r5, r6, lr}
 800f436:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f438:	200f      	movs	r0, #15
* Return         : FLASH Status: The returned value can be: FLASH_BUSY=1, 
*                  FLASH_ERROR_PG=2, FLASH_ERROR_WRP=3, FLASH_COMPLETE=4, 
*                  FLASH_TIMEOUT=5.
*******************************************************************************/
FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data)
{
 800f43a:	460e      	mov	r6, r1

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f43c:	f7ff fef2 	bl	800f224 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 800f440:	2804      	cmp	r0, #4
 800f442:	d110      	bne.n	800f466 <FLASH_ProgramHalfWord+0x32>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR |= CR_PG_Set;
 800f444:	4d08      	ldr	r5, [pc, #32]	; (800f468 <FLASH_ProgramHalfWord+0x34>)
  
    *(vu16*)Address = Data;
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f446:	300b      	adds	r0, #11
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR |= CR_PG_Set;
 800f448:	692b      	ldr	r3, [r5, #16]
 800f44a:	f043 0301 	orr.w	r3, r3, #1
 800f44e:	612b      	str	r3, [r5, #16]
  
    *(vu16*)Address = Data;
 800f450:	8026      	strh	r6, [r4, #0]
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f452:	f7ff fee7 	bl	800f224 <FLASH_WaitForLastOperation>

    if(status != FLASH_BUSY)
 800f456:	2801      	cmp	r0, #1
 800f458:	d005      	beq.n	800f466 <FLASH_ProgramHalfWord+0x32>
    {
      /* if the program operation is completed, disable the PG Bit */
      FLASH->CR &= CR_PG_Reset;
 800f45a:	692a      	ldr	r2, [r5, #16]
 800f45c:	f641 73fe 	movw	r3, #8190	; 0x1ffe
 800f460:	ea02 0303 	and.w	r3, r2, r3
 800f464:	612b      	str	r3, [r5, #16]
    }
  } 
  /* Return the Program Status */
  return status;
}
 800f466:	bd70      	pop	{r4, r5, r6, pc}
 800f468:	40022000 	.word	0x40022000

0800f46c <FLASH_ProgramWord>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY=1, 
*                  FLASH_ERROR_PG=2, FLASH_ERROR_WRP=3, FLASH_COMPLETE=4, 
*                  FLASH_TIMEOUT=5.
*******************************************************************************/
FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data)
{
 800f46c:	b570      	push	{r4, r5, r6, lr}
 800f46e:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f470:	200f      	movs	r0, #15
* Return         : FLASH Status: The returned value can be: FLASH_BUSY=1, 
*                  FLASH_ERROR_PG=2, FLASH_ERROR_WRP=3, FLASH_COMPLETE=4, 
*                  FLASH_TIMEOUT=5.
*******************************************************************************/
FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data)
{
 800f472:	460e      	mov	r6, r1

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f474:	f7ff fed6 	bl	800f224 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 800f478:	2804      	cmp	r0, #4
 800f47a:	d121      	bne.n	800f4c0 <FLASH_ProgramWord+0x54>
  {
    /* if the previous operation is completed, proceed to program the new first 
    half word */
    FLASH->CR |= CR_PG_Set;
 800f47c:	4d11      	ldr	r5, [pc, #68]	; (800f4c4 <FLASH_ProgramWord+0x58>)
  
    *(vu16*)Address = (u16)Data;

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f47e:	300b      	adds	r0, #11
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to program the new first 
    half word */
    FLASH->CR |= CR_PG_Set;
 800f480:	692b      	ldr	r3, [r5, #16]
 800f482:	f043 0301 	orr.w	r3, r3, #1
 800f486:	612b      	str	r3, [r5, #16]
  
    *(vu16*)Address = (u16)Data;
 800f488:	b2b3      	uxth	r3, r6
 800f48a:	8023      	strh	r3, [r4, #0]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f48c:	f7ff feca 	bl	800f224 <FLASH_WaitForLastOperation>
 
    if(status == FLASH_COMPLETE)
 800f490:	2804      	cmp	r0, #4
 800f492:	d10d      	bne.n	800f4b0 <FLASH_ProgramWord+0x44>
    {
      /* if the previous operation is completed, proceed to program the new second 
      half word */
      *(vu16*)(Address + 2) = Data >> 16;
 800f494:	0c36      	lsrs	r6, r6, #16
    
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f496:	300b      	adds	r0, #11
 
    if(status == FLASH_COMPLETE)
    {
      /* if the previous operation is completed, proceed to program the new second 
      half word */
      *(vu16*)(Address + 2) = Data >> 16;
 800f498:	8066      	strh	r6, [r4, #2]
    
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f49a:	f7ff fec3 	bl	800f224 <FLASH_WaitForLastOperation>
        
      if(status != FLASH_BUSY)
 800f49e:	2801      	cmp	r0, #1
 800f4a0:	d00e      	beq.n	800f4c0 <FLASH_ProgramWord+0x54>
      {
        /* Disable the PG Bit */
        FLASH->CR &= CR_PG_Reset;
 800f4a2:	692a      	ldr	r2, [r5, #16]
 800f4a4:	f641 73fe 	movw	r3, #8190	; 0x1ffe
 800f4a8:	ea02 0303 	and.w	r3, r2, r3
 800f4ac:	612b      	str	r3, [r5, #16]
 800f4ae:	bd70      	pop	{r4, r5, r6, pc}
      }
    }
    else
    {
      if (status != FLASH_BUSY)
 800f4b0:	2801      	cmp	r0, #1
 800f4b2:	d005      	beq.n	800f4c0 <FLASH_ProgramWord+0x54>
      {
        /* Disable the PG Bit */
        FLASH->CR &= CR_PG_Reset;
 800f4b4:	692a      	ldr	r2, [r5, #16]
 800f4b6:	f641 73fe 	movw	r3, #8190	; 0x1ffe
 800f4ba:	ea02 0303 	and.w	r3, r2, r3
 800f4be:	612b      	str	r3, [r5, #16]
      }
     }
  }
  /* Return the Program Status */
  return status;
}
 800f4c0:	bd70      	pop	{r4, r5, r6, pc}
 800f4c2:	bf00      	nop
 800f4c4:	40022000 	.word	0x40022000

0800f4c8 <FLASH_EraseOptionBytes>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY=1, 
*                  FLASH_ERROR_PG=2, FLASH_ERROR_WRP=3, FLASH_COMPLETE=4, 
*                  FLASH_TIMEOUT=5.
*******************************************************************************/
FLASH_Status FLASH_EraseOptionBytes(void)
{
 800f4c8:	b510      	push	{r4, lr}
  FLASH_Status status = FLASH_COMPLETE;
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
 800f4ca:	f640 70ff 	movw	r0, #4095	; 0xfff
 800f4ce:	f7ff fea9 	bl	800f224 <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 800f4d2:	2804      	cmp	r0, #4
 800f4d4:	d134      	bne.n	800f540 <FLASH_EraseOptionBytes+0x78>
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 800f4d6:	4c1b      	ldr	r4, [pc, #108]	; (800f544 <FLASH_EraseOptionBytes+0x7c>)
 800f4d8:	4b1b      	ldr	r3, [pc, #108]	; (800f548 <FLASH_EraseOptionBytes+0x80>)
    /* if the previous operation is completed, proceed to erase the option bytes */
    FLASH->CR |= CR_OPTER_Set;
    FLASH->CR |= CR_STRT_Set;

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 800f4da:	f640 70ff 	movw	r0, #4095	; 0xfff
  status = FLASH_WaitForLastOperation(EraseTimeout);

  if(status == FLASH_COMPLETE)
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 800f4de:	60a3      	str	r3, [r4, #8]
    FLASH->OPTKEYR = FLASH_KEY2;
 800f4e0:	4b1a      	ldr	r3, [pc, #104]	; (800f54c <FLASH_EraseOptionBytes+0x84>)
 800f4e2:	60a3      	str	r3, [r4, #8]
    
    /* if the previous operation is completed, proceed to erase the option bytes */
    FLASH->CR |= CR_OPTER_Set;
 800f4e4:	6923      	ldr	r3, [r4, #16]
 800f4e6:	f043 0320 	orr.w	r3, r3, #32
 800f4ea:	6123      	str	r3, [r4, #16]
    FLASH->CR |= CR_STRT_Set;
 800f4ec:	6923      	ldr	r3, [r4, #16]
 800f4ee:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800f4f2:	6123      	str	r3, [r4, #16]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 800f4f4:	f7ff fe96 	bl	800f224 <FLASH_WaitForLastOperation>
    
    if(status == FLASH_COMPLETE)
 800f4f8:	2804      	cmp	r0, #4
 800f4fa:	d119      	bne.n	800f530 <FLASH_EraseOptionBytes+0x68>
    {
      /* if the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= CR_OPTER_Reset;
 800f4fc:	6922      	ldr	r2, [r4, #16]
 800f4fe:	f641 73df 	movw	r3, #8159	; 0x1fdf
 800f502:	ea02 0303 	and.w	r3, r2, r3
 800f506:	6123      	str	r3, [r4, #16]
       
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set;
 800f508:	6923      	ldr	r3, [r4, #16]

      /* Enable the readout access */
      OB->RDP= RDP_Key; 
 800f50a:	f04f 02a5 	mov.w	r2, #165	; 0xa5
    {
      /* if the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= CR_OPTER_Reset;
       
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set;
 800f50e:	f043 0310 	orr.w	r3, r3, #16
 800f512:	6123      	str	r3, [r4, #16]

      /* Enable the readout access */
      OB->RDP= RDP_Key; 
 800f514:	4b0e      	ldr	r3, [pc, #56]	; (800f550 <FLASH_EraseOptionBytes+0x88>)

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f516:	300b      	adds	r0, #11
       
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set;

      /* Enable the readout access */
      OB->RDP= RDP_Key; 
 800f518:	801a      	strh	r2, [r3, #0]

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800f51a:	f7ff fe83 	bl	800f224 <FLASH_WaitForLastOperation>
 
      if(status != FLASH_BUSY)
 800f51e:	2801      	cmp	r0, #1
 800f520:	d00e      	beq.n	800f540 <FLASH_EraseOptionBytes+0x78>
      {
        /* if the program operation is completed, disable the OPTPG Bit */
        FLASH->CR &= CR_OPTPG_Reset;
 800f522:	6922      	ldr	r2, [r4, #16]
 800f524:	f641 73ef 	movw	r3, #8175	; 0x1fef
 800f528:	ea02 0303 	and.w	r3, r2, r3
 800f52c:	6123      	str	r3, [r4, #16]
 800f52e:	bd10      	pop	{r4, pc}
      }
    }
    else
    {
      if (status != FLASH_BUSY)
 800f530:	2801      	cmp	r0, #1
 800f532:	d005      	beq.n	800f540 <FLASH_EraseOptionBytes+0x78>
      {
        /* Disable the OPTPG Bit */
        FLASH->CR &= CR_OPTPG_Reset;
 800f534:	6922      	ldr	r2, [r4, #16]
 800f536:	f641 73ef 	movw	r3, #8175	; 0x1fef
 800f53a:	ea02 0303 	and.w	r3, r2, r3
 800f53e:	6123      	str	r3, [r4, #16]
      }
    }  
  }
  /* Return the erase status */
  return status;
}
 800f540:	bd10      	pop	{r4, pc}
 800f542:	bf00      	nop
 800f544:	40022000 	.word	0x40022000
 800f548:	45670123 	.word	0x45670123
 800f54c:	cdef89ab 	.word	0xcdef89ab
 800f550:	1ffff800 	.word	0x1ffff800

0800f554 <FLASH_EraseAllPages>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY=1, 
*                  FLASH_ERROR_PG=2, FLASH_ERROR_WRP=3, FLASH_COMPLETE=4, 
*                  FLASH_TIMEOUT=5.
*******************************************************************************/
FLASH_Status FLASH_EraseAllPages(void)
{
 800f554:	b510      	push	{r4, lr}
  FLASH_Status status = FLASH_COMPLETE;

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
 800f556:	f640 70ff 	movw	r0, #4095	; 0xfff
 800f55a:	f7ff fe63 	bl	800f224 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 800f55e:	2804      	cmp	r0, #4
 800f560:	d114      	bne.n	800f58c <FLASH_EraseAllPages+0x38>
  {
    /* if the previous operation is completed, proceed to erase all pages */
     FLASH->CR |= CR_MER_Set;
 800f562:	4c0b      	ldr	r4, [pc, #44]	; (800f590 <FLASH_EraseAllPages+0x3c>)
     FLASH->CR |= CR_STRT_Set;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 800f564:	f640 70ff 	movw	r0, #4095	; 0xfff
  status = FLASH_WaitForLastOperation(EraseTimeout);
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to erase all pages */
     FLASH->CR |= CR_MER_Set;
 800f568:	6923      	ldr	r3, [r4, #16]
 800f56a:	f043 0304 	orr.w	r3, r3, #4
 800f56e:	6123      	str	r3, [r4, #16]
     FLASH->CR |= CR_STRT_Set;
 800f570:	6923      	ldr	r3, [r4, #16]
 800f572:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800f576:	6123      	str	r3, [r4, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 800f578:	f7ff fe54 	bl	800f224 <FLASH_WaitForLastOperation>

    if(status != FLASH_BUSY)
 800f57c:	2801      	cmp	r0, #1
 800f57e:	d005      	beq.n	800f58c <FLASH_EraseAllPages+0x38>
    {
      /* if the erase operation is completed, disable the MER Bit */
      FLASH->CR &= CR_MER_Reset;
 800f580:	6922      	ldr	r2, [r4, #16]
 800f582:	f641 73fb 	movw	r3, #8187	; 0x1ffb
 800f586:	ea02 0303 	and.w	r3, r2, r3
 800f58a:	6123      	str	r3, [r4, #16]
    }
  }	   
  /* Return the Erase Status */
  return status;
}
 800f58c:	bd10      	pop	{r4, pc}
 800f58e:	bf00      	nop
 800f590:	40022000 	.word	0x40022000

0800f594 <FLASH_ErasePage>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY=1, 
*                  FLASH_ERROR_PG=2, FLASH_ERROR_WRP=3, FLASH_COMPLETE=4, 
*                  FLASH_TIMEOUT=5.
*******************************************************************************/
FLASH_Status FLASH_ErasePage(u32 Page_Address)
{
 800f594:	b538      	push	{r3, r4, r5, lr}
 800f596:	4605      	mov	r5, r0

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Page_Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
 800f598:	f640 70ff 	movw	r0, #4095	; 0xfff
 800f59c:	f7ff fe42 	bl	800f224 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 800f5a0:	2804      	cmp	r0, #4
 800f5a2:	d115      	bne.n	800f5d0 <FLASH_ErasePage+0x3c>
  { 
    /* if the previous operation is completed, proceed to erase the page */
    FLASH->CR|= CR_PER_Set;
 800f5a4:	4c0b      	ldr	r4, [pc, #44]	; (800f5d4 <FLASH_ErasePage+0x40>)
    FLASH->AR = Page_Address; 
    FLASH->CR|= CR_STRT_Set;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 800f5a6:	f640 70ff 	movw	r0, #4095	; 0xfff
  status = FLASH_WaitForLastOperation(EraseTimeout);
  
  if(status == FLASH_COMPLETE)
  { 
    /* if the previous operation is completed, proceed to erase the page */
    FLASH->CR|= CR_PER_Set;
 800f5aa:	6923      	ldr	r3, [r4, #16]
 800f5ac:	f043 0302 	orr.w	r3, r3, #2
 800f5b0:	6123      	str	r3, [r4, #16]
    FLASH->AR = Page_Address; 
 800f5b2:	6165      	str	r5, [r4, #20]
    FLASH->CR|= CR_STRT_Set;
 800f5b4:	6923      	ldr	r3, [r4, #16]
 800f5b6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800f5ba:	6123      	str	r3, [r4, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 800f5bc:	f7ff fe32 	bl	800f224 <FLASH_WaitForLastOperation>

    if(status != FLASH_BUSY)
 800f5c0:	2801      	cmp	r0, #1
 800f5c2:	d005      	beq.n	800f5d0 <FLASH_ErasePage+0x3c>
    {
      /* if the erase operation is completed, disable the PER Bit */
      FLASH->CR &= CR_PER_Reset;
 800f5c4:	6922      	ldr	r2, [r4, #16]
 800f5c6:	f641 73fd 	movw	r3, #8189	; 0x1ffd
 800f5ca:	ea02 0303 	and.w	r3, r2, r3
 800f5ce:	6123      	str	r3, [r4, #16]
    }
  }
  /* Return the Erase Status */
  return status;
}
 800f5d0:	bd38      	pop	{r3, r4, r5, pc}
 800f5d2:	bf00      	nop
 800f5d4:	40022000 	.word	0x40022000

0800f5d8 <NVIC_DeInit>:
*******************************************************************************/
void NVIC_DeInit(void)
{
  u32 index = 0;
  
  NVIC->ICER[0] = 0xFFFFFFFF;
 800f5d8:	4b0b      	ldr	r3, [pc, #44]	; (800f608 <NVIC_DeInit+0x30>)
 800f5da:	f04f 31ff 	mov.w	r1, #4294967295
  NVIC->ICER[1] = 0x000007FF;
 800f5de:	f240 72ff 	movw	r2, #2047	; 0x7ff
*******************************************************************************/
void NVIC_DeInit(void)
{
  u32 index = 0;
  
  NVIC->ICER[0] = 0xFFFFFFFF;
 800f5e2:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
  NVIC->ICER[1] = 0x000007FF;
 800f5e6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  NVIC->ICPR[0] = 0xFFFFFFFF;
 800f5ea:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->ICPR[1] = 0x000007FF;
 800f5ee:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
 800f5f2:	2300      	movs	r3, #0
  
  for(index = 0; index < 0x0B; index++)
  {
     NVIC->IPR[index] = 0x00000000;
 800f5f4:	f103 01c0 	add.w	r1, r3, #192	; 0xc0
 800f5f8:	4a03      	ldr	r2, [pc, #12]	; (800f608 <NVIC_DeInit+0x30>)
  NVIC->ICER[0] = 0xFFFFFFFF;
  NVIC->ICER[1] = 0x000007FF;
  NVIC->ICPR[0] = 0xFFFFFFFF;
  NVIC->ICPR[1] = 0x000007FF;
  
  for(index = 0; index < 0x0B; index++)
 800f5fa:	3301      	adds	r3, #1
  {
     NVIC->IPR[index] = 0x00000000;
 800f5fc:	2000      	movs	r0, #0
  NVIC->ICER[0] = 0xFFFFFFFF;
  NVIC->ICER[1] = 0x000007FF;
  NVIC->ICPR[0] = 0xFFFFFFFF;
  NVIC->ICPR[1] = 0x000007FF;
  
  for(index = 0; index < 0x0B; index++)
 800f5fe:	2b0b      	cmp	r3, #11
  {
     NVIC->IPR[index] = 0x00000000;
 800f600:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
  NVIC->ICER[0] = 0xFFFFFFFF;
  NVIC->ICER[1] = 0x000007FF;
  NVIC->ICPR[0] = 0xFFFFFFFF;
  NVIC->ICPR[1] = 0x000007FF;
  
  for(index = 0; index < 0x0B; index++)
 800f604:	d1f6      	bne.n	800f5f4 <NVIC_DeInit+0x1c>
  {
     NVIC->IPR[index] = 0x00000000;
  } 
}
 800f606:	4770      	bx	lr
 800f608:	e000e100 	.word	0xe000e100

0800f60c <NVIC_SCBDeInit>:
*******************************************************************************/
void NVIC_SCBDeInit(void)
{
  u32 index = 0x00;
  
  SCB->ICSR = 0x0A000000;
 800f60c:	4b09      	ldr	r3, [pc, #36]	; (800f634 <NVIC_SCBDeInit+0x28>)
 800f60e:	f04f 6220 	mov.w	r2, #167772160	; 0xa000000
  SCB->VTOR = 0x00000000;
  SCB->AIRCR = AIRCR_VECTKEY_MASK;
 800f612:	4909      	ldr	r1, [pc, #36]	; (800f638 <NVIC_SCBDeInit+0x2c>)
*******************************************************************************/
void NVIC_SCBDeInit(void)
{
  u32 index = 0x00;
  
  SCB->ICSR = 0x0A000000;
 800f614:	605a      	str	r2, [r3, #4]
  SCB->VTOR = 0x00000000;
 800f616:	2200      	movs	r2, #0
 800f618:	609a      	str	r2, [r3, #8]
  SCB->AIRCR = AIRCR_VECTKEY_MASK;
 800f61a:	60d9      	str	r1, [r3, #12]
  SCB->SCR = 0x00000000;
 800f61c:	611a      	str	r2, [r3, #16]
  SCB->CCR = 0x00000000;
 800f61e:	615a      	str	r2, [r3, #20]
  for(index = 0; index < 0x03; index++)
  {
     SCB->SHPR[index] = 0;
 800f620:	619a      	str	r2, [r3, #24]
 800f622:	61da      	str	r2, [r3, #28]
 800f624:	621a      	str	r2, [r3, #32]
  }
  SCB->SHCSR = 0x00000000;
 800f626:	625a      	str	r2, [r3, #36]	; 0x24
  SCB->CFSR = 0xFFFFFFFF;
 800f628:	3a01      	subs	r2, #1
 800f62a:	629a      	str	r2, [r3, #40]	; 0x28
  SCB->HFSR = 0xFFFFFFFF;
 800f62c:	62da      	str	r2, [r3, #44]	; 0x2c
  SCB->DFSR = 0xFFFFFFFF;
 800f62e:	631a      	str	r2, [r3, #48]	; 0x30
}
 800f630:	4770      	bx	lr
 800f632:	bf00      	nop
 800f634:	e000ed00 	.word	0xe000ed00
 800f638:	05fa0000 	.word	0x05fa0000

0800f63c <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 800f63c:	f040 60be 	orr.w	r0, r0, #99614720	; 0x5f00000
 800f640:	4b02      	ldr	r3, [pc, #8]	; (800f64c <NVIC_PriorityGroupConfig+0x10>)
 800f642:	f440 2020 	orr.w	r0, r0, #655360	; 0xa0000
 800f646:	60d8      	str	r0, [r3, #12]
}
 800f648:	4770      	bx	lr
 800f64a:	bf00      	nop
 800f64c:	e000ed00 	.word	0xe000ed00

0800f650 <NVIC_Init>:
*                    specified NVIC peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_Init(NVIC_InitType* NVIC_InitStruct)
{
 800f650:	b530      	push	{r4, r5, lr}
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_InitStruct->NVIC_IRQChannel));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 800f652:	78c2      	ldrb	r2, [r0, #3]
 800f654:	7803      	ldrb	r3, [r0, #0]
 800f656:	b36a      	cbz	r2, 800f6b4 <NVIC_Init+0x64>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
 800f658:	4a1c      	ldr	r2, [pc, #112]	; (800f6cc <NVIC_Init+0x7c>)
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 800f65a:	7844      	ldrb	r4, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
 800f65c:	68d2      	ldr	r2, [r2, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 800f65e:	7880      	ldrb	r0, [r0, #2]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
 800f660:	43d2      	mvns	r2, r2
 800f662:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 800f666:	0a12      	lsrs	r2, r2, #8
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 800f668:	f1c2 0104 	rsb	r1, r2, #4
 800f66c:	fa14 f101 	lsls.w	r1, r4, r1
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 800f670:	240f      	movs	r4, #15
 800f672:	40d4      	lsrs	r4, r2
 800f674:	4004      	ands	r4, r0
 800f676:	430c      	orrs	r4, r1

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 800f678:	f003 0c03 	and.w	ip, r3, #3
 800f67c:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
 800f680:	0124      	lsls	r4, r4, #4
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    
    tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 800f682:	20ff      	movs	r0, #255	; 0xff
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 800f684:	fa04 f40c 	lsl.w	r4, r4, ip
    
    tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 800f688:	fa00 f00c 	lsl.w	r0, r0, ip
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    
    tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
 800f68c:	0899      	lsrs	r1, r3, #2
 800f68e:	4a10      	ldr	r2, [pc, #64]	; (800f6d0 <NVIC_Init+0x80>)
 800f690:	31c0      	adds	r1, #192	; 0xc0
 800f692:	f852 5021 	ldr.w	r5, [r2, r1, lsl #2]
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
 800f696:	ea25 0c00 	bic.w	ip, r5, r0
    tmppriority &= tmpmask;  
    tmpreg |= tmppriority;
 800f69a:	ea04 0000 	and.w	r0, r4, r0
 800f69e:	ea40 000c 	orr.w	r0, r0, ip

    NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
 800f6a2:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 800f6a6:	0959      	lsrs	r1, r3, #5
      (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 800f6a8:	2001      	movs	r0, #1
 800f6aa:	f003 031f 	and.w	r3, r3, #31
 800f6ae:	fa10 f303 	lsls.w	r3, r0, r3
 800f6b2:	e007      	b.n	800f6c4 <NVIC_Init+0x74>
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 800f6b4:	0959      	lsrs	r1, r3, #5
      (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 800f6b6:	2201      	movs	r2, #1
 800f6b8:	f003 031f 	and.w	r3, r3, #31
 800f6bc:	fa12 f303 	lsls.w	r3, r2, r3
      (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 800f6c0:	4a03      	ldr	r2, [pc, #12]	; (800f6d0 <NVIC_Init+0x80>)
 800f6c2:	3120      	adds	r1, #32
 800f6c4:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 800f6c8:	bd30      	pop	{r4, r5, pc}
 800f6ca:	bf00      	nop
 800f6cc:	e000ed00 	.word	0xe000ed00
 800f6d0:	e000e100 	.word	0xe000e100

0800f6d4 <NVIC_StructInit>:
* Return         : None
*******************************************************************************/
void NVIC_StructInit(NVIC_InitType* NVIC_InitStruct)
{
  /* NVIC_InitStruct members default value */
  NVIC_InitStruct->NVIC_IRQChannel = 0x00;
 800f6d4:	2300      	movs	r3, #0
 800f6d6:	7003      	strb	r3, [r0, #0]
  NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority = 0x00;
 800f6d8:	7043      	strb	r3, [r0, #1]
  NVIC_InitStruct->NVIC_IRQChannelSubPriority = 0x00;
 800f6da:	7083      	strb	r3, [r0, #2]
  NVIC_InitStruct->NVIC_IRQChannelCmd = DISABLE;
 800f6dc:	70c3      	strb	r3, [r0, #3]
}
 800f6de:	4770      	bx	lr

0800f6e0 <NVIC_GetCurrentPendingIRQChannel>:
* Output         : None
* Return         : Pending IRQ Channel Identifier.
*******************************************************************************/
u16 NVIC_GetCurrentPendingIRQChannel(void)
{
  return ((u16)((SCB->ICSR & (u32)0x003FF000) >> 0x0C));
 800f6e0:	4b03      	ldr	r3, [pc, #12]	; (800f6f0 <NVIC_GetCurrentPendingIRQChannel+0x10>)
 800f6e2:	4804      	ldr	r0, [pc, #16]	; (800f6f4 <NVIC_GetCurrentPendingIRQChannel+0x14>)
 800f6e4:	685b      	ldr	r3, [r3, #4]
 800f6e6:	ea03 0000 	and.w	r0, r3, r0
}
 800f6ea:	0b00      	lsrs	r0, r0, #12
 800f6ec:	4770      	bx	lr
 800f6ee:	bf00      	nop
 800f6f0:	e000ed00 	.word	0xe000ed00
 800f6f4:	003ff000 	.word	0x003ff000

0800f6f8 <NVIC_GetIRQChannelPendingBitStatus>:
  u32 tmp = 0x00;
  
  /* Check the parameters */
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
  
  tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
 800f6f8:	2201      	movs	r2, #1
 800f6fa:	f000 031f 	and.w	r3, r0, #31
 800f6fe:	fa12 f303 	lsls.w	r3, r2, r3

  if (((NVIC->ISPR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp)
 800f702:	0940      	lsrs	r0, r0, #5
 800f704:	4a04      	ldr	r2, [pc, #16]	; (800f718 <NVIC_GetIRQChannelPendingBitStatus+0x20>)
 800f706:	3040      	adds	r0, #64	; 0x40
 800f708:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 800f70c:	4018      	ands	r0, r3
  else
  {
    pendingirqstatus = RESET;
  }
  return pendingirqstatus;
}
 800f70e:	4298      	cmp	r0, r3
 800f710:	bf14      	ite	ne
 800f712:	2000      	movne	r0, #0
 800f714:	2001      	moveq	r0, #1
 800f716:	4770      	bx	lr
 800f718:	e000e100 	.word	0xe000e100

0800f71c <NVIC_SetIRQChannelPendingBit>:
void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
{
  /* Check the parameters */
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
  
  *(u32*)0xE000EF00 = (u32)NVIC_IRQChannel;
 800f71c:	4b01      	ldr	r3, [pc, #4]	; (800f724 <NVIC_SetIRQChannelPendingBit+0x8>)
 800f71e:	6018      	str	r0, [r3, #0]
}
 800f720:	4770      	bx	lr
 800f722:	bf00      	nop
 800f724:	e000ef00 	.word	0xe000ef00

0800f728 <NVIC_ClearIRQChannelPendingBit>:
void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
{
  /* Check the parameters */
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
  
  NVIC->ICPR[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u32)0x1F);
 800f728:	0942      	lsrs	r2, r0, #5
 800f72a:	2301      	movs	r3, #1
 800f72c:	f000 001f 	and.w	r0, r0, #31
 800f730:	fa13 f000 	lsls.w	r0, r3, r0
 800f734:	4b02      	ldr	r3, [pc, #8]	; (800f740 <NVIC_ClearIRQChannelPendingBit+0x18>)
 800f736:	3260      	adds	r2, #96	; 0x60
 800f738:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
}
 800f73c:	4770      	bx	lr
 800f73e:	bf00      	nop
 800f740:	e000e100 	.word	0xe000e100

0800f744 <NVIC_GetCurrentActiveHandler>:
* Output         : None
* Return         : Active Handler Identifier.
*******************************************************************************/
u16 NVIC_GetCurrentActiveHandler(void)
{
  return ((u16)(SCB->ICSR & (u32)0x3FF));
 800f744:	4b02      	ldr	r3, [pc, #8]	; (800f750 <NVIC_GetCurrentActiveHandler+0xc>)
 800f746:	6858      	ldr	r0, [r3, #4]
}
 800f748:	0580      	lsls	r0, r0, #22
 800f74a:	0d80      	lsrs	r0, r0, #22
 800f74c:	4770      	bx	lr
 800f74e:	bf00      	nop
 800f750:	e000ed00 	.word	0xe000ed00

0800f754 <NVIC_GetIRQChannelActiveBitStatus>:
  u32 tmp = 0x00;

  /* Check the parameters */
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
  
  tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
 800f754:	2201      	movs	r2, #1
 800f756:	f000 031f 	and.w	r3, r0, #31
 800f75a:	fa12 f303 	lsls.w	r3, r2, r3

  if (((NVIC->IABR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp )
 800f75e:	0940      	lsrs	r0, r0, #5
 800f760:	4a04      	ldr	r2, [pc, #16]	; (800f774 <NVIC_GetIRQChannelActiveBitStatus+0x20>)
 800f762:	3080      	adds	r0, #128	; 0x80
 800f764:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 800f768:	4018      	ands	r0, r3
  else
  {
    activeirqstatus = RESET;
  }
  return activeirqstatus;
}
 800f76a:	4298      	cmp	r0, r3
 800f76c:	bf14      	ite	ne
 800f76e:	2000      	movne	r0, #0
 800f770:	2001      	moveq	r0, #1
 800f772:	4770      	bx	lr
 800f774:	e000e100 	.word	0xe000e100

0800f778 <NVIC_GetCPUID>:
* Output         : None
* Return         : CPU ID.
*******************************************************************************/
u32 NVIC_GetCPUID(void)
{
  return (SCB->CPUID);
 800f778:	4b01      	ldr	r3, [pc, #4]	; (800f780 <NVIC_GetCPUID+0x8>)
 800f77a:	6818      	ldr	r0, [r3, #0]
}
 800f77c:	4770      	bx	lr
 800f77e:	bf00      	nop
 800f780:	e000ed00 	.word	0xe000ed00

0800f784 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (u32)0x1FFFFF80);
 800f784:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 800f788:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 800f78c:	4b01      	ldr	r3, [pc, #4]	; (800f794 <NVIC_SetVectorTable+0x10>)
 800f78e:	4301      	orrs	r1, r0
 800f790:	6099      	str	r1, [r3, #8]
}
 800f792:	4770      	bx	lr
 800f794:	e000ed00 	.word	0xe000ed00

0800f798 <NVIC_GenerateSystemReset>:
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_GenerateSystemReset(void)
{
  SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x04;
 800f798:	4a01      	ldr	r2, [pc, #4]	; (800f7a0 <NVIC_GenerateSystemReset+0x8>)
 800f79a:	4b02      	ldr	r3, [pc, #8]	; (800f7a4 <NVIC_GenerateSystemReset+0xc>)
 800f79c:	60da      	str	r2, [r3, #12]
}
 800f79e:	4770      	bx	lr
 800f7a0:	05fa0004 	.word	0x05fa0004
 800f7a4:	e000ed00 	.word	0xe000ed00

0800f7a8 <NVIC_GenerateCoreReset>:
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_GenerateCoreReset(void)
{
  SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x01;
 800f7a8:	4a01      	ldr	r2, [pc, #4]	; (800f7b0 <NVIC_GenerateCoreReset+0x8>)
 800f7aa:	4b02      	ldr	r3, [pc, #8]	; (800f7b4 <NVIC_GenerateCoreReset+0xc>)
 800f7ac:	60da      	str	r2, [r3, #12]
}
 800f7ae:	4770      	bx	lr
 800f7b0:	05fa0001 	.word	0x05fa0001
 800f7b4:	e000ed00 	.word	0xe000ed00

0800f7b8 <NVIC_SystemLPConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 800f7b8:	b119      	cbz	r1, 800f7c2 <NVIC_SystemLPConfig+0xa>
  {
    SCB->SCR |= LowPowerMode;
 800f7ba:	4b05      	ldr	r3, [pc, #20]	; (800f7d0 <NVIC_SystemLPConfig+0x18>)
 800f7bc:	691a      	ldr	r2, [r3, #16]
 800f7be:	4310      	orrs	r0, r2
 800f7c0:	e003      	b.n	800f7ca <NVIC_SystemLPConfig+0x12>
  }
  else
  {
    SCB->SCR &= (u32)(~(u32)LowPowerMode);
 800f7c2:	4b03      	ldr	r3, [pc, #12]	; (800f7d0 <NVIC_SystemLPConfig+0x18>)
 800f7c4:	691a      	ldr	r2, [r3, #16]
 800f7c6:	ea22 0000 	bic.w	r0, r2, r0
 800f7ca:	6118      	str	r0, [r3, #16]
 800f7cc:	4770      	bx	lr
 800f7ce:	bf00      	nop
 800f7d0:	e000ed00 	.word	0xe000ed00

0800f7d4 <NVIC_SystemHandlerConfig>:

  /* Check the parameters */
  assert_param(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  tmpreg =  (u32)0x01 << (SystemHandler & (u32)0x1F);
 800f7d4:	f000 001f 	and.w	r0, r0, #31
 800f7d8:	2301      	movs	r3, #1
 800f7da:	fa13 f000 	lsls.w	r0, r3, r0

  if (NewState != DISABLE)
 800f7de:	b119      	cbz	r1, 800f7e8 <NVIC_SystemHandlerConfig+0x14>
  {
    SCB->SHCSR |= tmpreg;
 800f7e0:	4b04      	ldr	r3, [pc, #16]	; (800f7f4 <NVIC_SystemHandlerConfig+0x20>)
 800f7e2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800f7e4:	4310      	orrs	r0, r2
 800f7e6:	e003      	b.n	800f7f0 <NVIC_SystemHandlerConfig+0x1c>
  }
  else
  {
    SCB->SHCSR &= ~tmpreg;
 800f7e8:	4b02      	ldr	r3, [pc, #8]	; (800f7f4 <NVIC_SystemHandlerConfig+0x20>)
 800f7ea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800f7ec:	ea22 0000 	bic.w	r0, r2, r0
 800f7f0:	6258      	str	r0, [r3, #36]	; 0x24
 800f7f2:	4770      	bx	lr
 800f7f4:	e000ed00 	.word	0xe000ed00

0800f7f8 <NVIC_SystemHandlerPriorityConfig>:
  /* Check the parameters */
  assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
    
  tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
 800f7f8:	4b14      	ldr	r3, [pc, #80]	; (800f84c <NVIC_SystemHandlerPriorityConfig+0x54>)
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
                                      u8 SystemHandlerSubPriority)
{
 800f7fa:	b530      	push	{r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
    
  tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
 800f7fc:	68dc      	ldr	r4, [r3, #12]
  tmp1 = (0x4 - tmppriority);
  tmp2 = tmp2 >> tmppriority;
    
  tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
  tmppriority |=  SystemHandlerSubPriority & tmp2;
 800f7fe:	25ff      	movs	r5, #255	; 0xff
  /* Check the parameters */
  assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
    
  tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
 800f800:	ea6f 0c04 	mvn.w	ip, r4
 800f804:	f40c 6ce0 	and.w	ip, ip, #1792	; 0x700
 800f808:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
  tmp1 = (0x4 - tmppriority);
  tmp2 = tmp2 >> tmppriority;
    
  tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
 800f80c:	f1cc 0404 	rsb	r4, ip, #4
  tmppriority |=  SystemHandlerSubPriority & tmp2;
 800f810:	fa25 fc0c 	lsr.w	ip, r5, ip
    
  tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
  tmp1 = (0x4 - tmppriority);
  tmp2 = tmp2 >> tmppriority;
    
  tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
 800f814:	40a1      	lsls	r1, r4
  tmppriority |=  SystemHandlerSubPriority & tmp2;
 800f816:	ea02 0c0c 	and.w	ip, r2, ip

  tmppriority = tmppriority << 0x04;
  tmp1 = SystemHandler & (u32)0xC0;
 800f81a:	f000 02c0 	and.w	r2, r0, #192	; 0xc0
  tmp1 = tmp1 >> 0x06; 
  tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
  tmppriority = tmppriority << (tmp2 * 0x08);
 800f81e:	0940      	lsrs	r0, r0, #5
 800f820:	f000 0018 	and.w	r0, r0, #24
  handlermask = (u32)0xFF << (tmp2 * 0x08);
  
  SCB->SHPR[tmp1] &= ~handlermask;
 800f824:	4085      	lsls	r5, r0
  tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
  tmp1 = (0x4 - tmppriority);
  tmp2 = tmp2 >> tmppriority;
    
  tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
  tmppriority |=  SystemHandlerSubPriority & tmp2;
 800f826:	ea4c 0101 	orr.w	r1, ip, r1

  tmppriority = tmppriority << 0x04;
 800f82a:	0109      	lsls	r1, r1, #4
  tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
  tmppriority = tmppriority << (tmp2 * 0x08);
  handlermask = (u32)0xFF << (tmp2 * 0x08);
  
  SCB->SHPR[tmp1] &= ~handlermask;
  SCB->SHPR[tmp1] |= tmppriority;
 800f82c:	fa11 f000 	lsls.w	r0, r1, r0
  tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
  tmppriority |=  SystemHandlerSubPriority & tmp2;

  tmppriority = tmppriority << 0x04;
  tmp1 = SystemHandler & (u32)0xC0;
  tmp1 = tmp1 >> 0x06; 
 800f830:	0992      	lsrs	r2, r2, #6
  tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
  tmppriority = tmppriority << (tmp2 * 0x08);
  handlermask = (u32)0xFF << (tmp2 * 0x08);
  
  SCB->SHPR[tmp1] &= ~handlermask;
 800f832:	3206      	adds	r2, #6
 800f834:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
 800f838:	ea24 0505 	bic.w	r5, r4, r5
 800f83c:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
  SCB->SHPR[tmp1] |= tmppriority;
 800f840:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 800f844:	4328      	orrs	r0, r5
 800f846:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
}
 800f84a:	bd30      	pop	{r4, r5, pc}
 800f84c:	e000ed00 	.word	0xe000ed00

0800f850 <NVIC_GetSystemHandlerPendingBitStatus>:
  u32 tmp = 0x00, tmppos = 0x00;

  /* Check the parameters */
  assert_param(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
  
  tmppos = (SystemHandler >> 0x0A);
 800f850:	0a83      	lsrs	r3, r0, #10
  tmppos &= (u32)0x0F;

  tmppos = (u32)0x01 << tmppos;
 800f852:	2201      	movs	r2, #1
 800f854:	f003 030f 	and.w	r3, r3, #15
 800f858:	fa12 f303 	lsls.w	r3, r2, r3

  tmp = SCB->SHCSR & tmppos;
 800f85c:	4a04      	ldr	r2, [pc, #16]	; (800f870 <NVIC_GetSystemHandlerPendingBitStatus+0x20>)
 800f85e:	6a50      	ldr	r0, [r2, #36]	; 0x24
 800f860:	ea03 0000 	and.w	r0, r3, r0
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 800f864:	4298      	cmp	r0, r3
 800f866:	bf14      	ite	ne
 800f868:	2000      	movne	r0, #0
 800f86a:	2001      	moveq	r0, #1
 800f86c:	4770      	bx	lr
 800f86e:	bf00      	nop
 800f870:	e000ed00 	.word	0xe000ed00

0800f874 <NVIC_SetSystemHandlerPendingBit>:
  assert_param(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
  
  /* Get the System Handler pending bit position */
  tmp = SystemHandler & (u32)0x1F;
  /* Set the corresponding System Handler pending bit */
  SCB->ICSR |= ((u32)0x01 << tmp);
 800f874:	f000 001f 	and.w	r0, r0, #31
 800f878:	2101      	movs	r1, #1
 800f87a:	fa11 f000 	lsls.w	r0, r1, r0
 800f87e:	4b03      	ldr	r3, [pc, #12]	; (800f88c <NVIC_SetSystemHandlerPendingBit+0x18>)
 800f880:	685a      	ldr	r2, [r3, #4]
 800f882:	ea40 0202 	orr.w	r2, r0, r2
 800f886:	605a      	str	r2, [r3, #4]
}
 800f888:	4770      	bx	lr
 800f88a:	bf00      	nop
 800f88c:	e000ed00 	.word	0xe000ed00

0800f890 <NVIC_ClearSystemHandlerPendingBit>:
  assert_param(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
  
  /* Get the System Handler pending bit position */
  tmp = SystemHandler & (u32)0x1F;
  /* Clear the corresponding System Handler pending bit */
  SCB->ICSR |= ((u32)0x01 << (tmp - 0x01));
 800f890:	f000 011f 	and.w	r1, r0, #31
 800f894:	3901      	subs	r1, #1
 800f896:	2001      	movs	r0, #1
 800f898:	fa10 f101 	lsls.w	r1, r0, r1
 800f89c:	4b02      	ldr	r3, [pc, #8]	; (800f8a8 <NVIC_ClearSystemHandlerPendingBit+0x18>)
 800f89e:	685a      	ldr	r2, [r3, #4]
 800f8a0:	ea41 0202 	orr.w	r2, r1, r2
 800f8a4:	605a      	str	r2, [r3, #4]
}
 800f8a6:	4770      	bx	lr
 800f8a8:	e000ed00 	.word	0xe000ed00

0800f8ac <NVIC_GetSystemHandlerActiveBitStatus>:
  /* Check the parameters */
  assert_param(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
  
  tmppos = (SystemHandler >> 0x0E) & (u32)0x0F;

  tmppos = (u32)0x01 << tmppos;
 800f8ac:	0b83      	lsrs	r3, r0, #14
 800f8ae:	2201      	movs	r2, #1
 800f8b0:	f003 030f 	and.w	r3, r3, #15
 800f8b4:	fa12 f303 	lsls.w	r3, r2, r3

  tmp = SCB->SHCSR & tmppos;
 800f8b8:	4a04      	ldr	r2, [pc, #16]	; (800f8cc <NVIC_GetSystemHandlerActiveBitStatus+0x20>)
 800f8ba:	6a50      	ldr	r0, [r2, #36]	; 0x24
 800f8bc:	ea03 0000 	and.w	r0, r3, r0
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 800f8c0:	4298      	cmp	r0, r3
 800f8c2:	bf14      	ite	ne
 800f8c4:	2000      	movne	r0, #0
 800f8c6:	2001      	moveq	r0, #1
 800f8c8:	4770      	bx	lr
 800f8ca:	bf00      	nop
 800f8cc:	e000ed00 	.word	0xe000ed00

0800f8d0 <NVIC_GetFaultHandlerSources>:
  u32 tmpreg = 0x00, tmppos = 0x00;

  /* Check the parameters */
  assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
  
  tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
 800f8d0:	0c83      	lsrs	r3, r0, #18
  tmppos = (SystemHandler >> 0x14) & (u32)0x03;

  if (tmpreg == 0x00)
 800f8d2:	f013 0303 	ands.w	r3, r3, #3
 800f8d6:	d102      	bne.n	800f8de <NVIC_GetFaultHandlerSources+0xe>
  {
    faultsources = SCB->HFSR;
 800f8d8:	4b0a      	ldr	r3, [pc, #40]	; (800f904 <NVIC_GetFaultHandlerSources+0x34>)
 800f8da:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800f8dc:	4770      	bx	lr
  }
  else if (tmpreg == 0x01)
 800f8de:	2b01      	cmp	r3, #1
 800f8e0:	d10d      	bne.n	800f8fe <NVIC_GetFaultHandlerSources+0x2e>
  {
    faultsources = SCB->CFSR >> (tmppos * 0x08);
 800f8e2:	4a08      	ldr	r2, [pc, #32]	; (800f904 <NVIC_GetFaultHandlerSources+0x34>)

  /* Check the parameters */
  assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
  
  tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
  tmppos = (SystemHandler >> 0x14) & (u32)0x03;
 800f8e4:	0d03      	lsrs	r3, r0, #20
 800f8e6:	f003 0303 	and.w	r3, r3, #3
  {
    faultsources = SCB->HFSR;
  }
  else if (tmpreg == 0x01)
  {
    faultsources = SCB->CFSR >> (tmppos * 0x08);
 800f8ea:	6a90      	ldr	r0, [r2, #40]	; 0x28
 800f8ec:	00da      	lsls	r2, r3, #3
 800f8ee:	40d0      	lsrs	r0, r2
    if (tmppos != 0x02)
 800f8f0:	2b02      	cmp	r3, #2
    {
      faultsources &= (u32)0x0F;
 800f8f2:	bf14      	ite	ne
 800f8f4:	f000 000f 	andne.w	r0, r0, #15
    }
    else
    {
      faultsources &= (u32)0xFF;
 800f8f8:	f000 00ff 	andeq.w	r0, r0, #255	; 0xff
 800f8fc:	4770      	bx	lr
    }
  }
  else
  {
    faultsources = SCB->DFSR;
 800f8fe:	4b01      	ldr	r3, [pc, #4]	; (800f904 <NVIC_GetFaultHandlerSources+0x34>)
 800f900:	6b18      	ldr	r0, [r3, #48]	; 0x30
  }
  return faultsources;
}
 800f902:	4770      	bx	lr
 800f904:	e000ed00 	.word	0xe000ed00

0800f908 <NVIC_GetFaultAddress>:
  
  tmp = (SystemHandler >> 0x16) & (u32)0x01;

  if (tmp == 0x00)
  {
    faultaddress = SCB->MMFAR;
 800f908:	4b03      	ldr	r3, [pc, #12]	; (800f918 <NVIC_GetFaultAddress+0x10>)
  /* Check the parameters */
  assert_param(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
  
  tmp = (SystemHandler >> 0x16) & (u32)0x01;

  if (tmp == 0x00)
 800f90a:	f410 0f80 	tst.w	r0, #4194304	; 0x400000
  {
    faultaddress = SCB->MMFAR;
 800f90e:	bf0c      	ite	eq
 800f910:	6b58      	ldreq	r0, [r3, #52]	; 0x34
  }
  else
  {
    faultaddress = SCB->BFAR;
 800f912:	6b98      	ldrne	r0, [r3, #56]	; 0x38
  }
  return faultaddress;
}
 800f914:	4770      	bx	lr
 800f916:	bf00      	nop
 800f918:	e000ed00 	.word	0xe000ed00

0800f91c <NVIC_GetBASEPRI>:
* Output         : None
* Return         : BASEPRI register value
*******************************************************************************/
u32 NVIC_GetBASEPRI(void)
{
  return (__GetBASEPRI());
 800f91c:	f7fc bfa0 	b.w	800c860 <__GetBASEPRI>

0800f920 <NVIC_BASEPRICONFIG>:
void NVIC_BASEPRICONFIG(u32 NewPriority)
{
  /* Check the parameters */
  assert_param(IS_NVIC_BASE_PRI(NewPriority));
  
  __BASEPRICONFIG(NewPriority << 0x04);
 800f920:	0100      	lsls	r0, r0, #4
 800f922:	f7fc bf9a 	b.w	800c85a <__BASEPRICONFIG>

0800f926 <NVIC_RESETFAULTMASK>:
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_RESETFAULTMASK(void)
{
  __RESETFAULTMASK();
 800f926:	f7fc bf96 	b.w	800c856 <__RESETFAULTMASK>

0800f92a <NVIC_SETFAULTMASK>:
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_SETFAULTMASK(void)
{
  __SETFAULTMASK();
 800f92a:	f7fc bf92 	b.w	800c852 <__SETFAULTMASK>

0800f92e <NVIC_RESETPRIMASK>:
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_RESETPRIMASK(void)
{
  __RESETPRIMASK();
 800f92e:	f7fc bf8e 	b.w	800c84e <__RESETPRIMASK>

0800f932 <NVIC_SETPRIMASK>:
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_SETPRIMASK(void)
{
  __SETPRIMASK();
 800f932:	f7fc bf8a 	b.w	800c84a <__SETPRIMASK>
 800f936:	bf00      	nop

0800f938 <RCC_DeInit>:
* Return         : None
*******************************************************************************/
void RCC_DeInit(void)
{
  /* Disable APB2 Peripheral Reset */
  RCC->APB2RSTR = 0x00000000;
 800f938:	4b10      	ldr	r3, [pc, #64]	; (800f97c <RCC_DeInit+0x44>)
 800f93a:	2200      	movs	r2, #0

  /* Disable APB1 Peripheral Reset */
  RCC->APB1RSTR = 0x00000000;

  /* FLITF and SRAM Clock ON */
  RCC->AHBENR = 0x00000014;
 800f93c:	2114      	movs	r1, #20
* Return         : None
*******************************************************************************/
void RCC_DeInit(void)
{
  /* Disable APB2 Peripheral Reset */
  RCC->APB2RSTR = 0x00000000;
 800f93e:	60da      	str	r2, [r3, #12]

  /* Disable APB1 Peripheral Reset */
  RCC->APB1RSTR = 0x00000000;
 800f940:	611a      	str	r2, [r3, #16]

  /* FLITF and SRAM Clock ON */
  RCC->AHBENR = 0x00000014;
 800f942:	6159      	str	r1, [r3, #20]

  /* Disable APB2 Peripheral Clock */
  RCC->APB2ENR = 0x00000000;
 800f944:	619a      	str	r2, [r3, #24]

  /* Disable APB1 Peripheral Clock */
  RCC->APB1ENR = 0x00000000;
 800f946:	61da      	str	r2, [r3, #28]

  /* Set HSION bit */
  RCC->CR |= (u32)0x00000001;
 800f948:	6819      	ldr	r1, [r3, #0]
 800f94a:	f041 0101 	orr.w	r1, r1, #1
 800f94e:	6019      	str	r1, [r3, #0]

  /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits*/
  RCC->CFGR &= 0xF8FF0000;
 800f950:	6858      	ldr	r0, [r3, #4]
 800f952:	490b      	ldr	r1, [pc, #44]	; (800f980 <RCC_DeInit+0x48>)
 800f954:	ea00 0101 	and.w	r1, r0, r1
 800f958:	6059      	str	r1, [r3, #4]
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= 0xFEF6FFFF;
 800f95a:	6819      	ldr	r1, [r3, #0]
 800f95c:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
 800f960:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 800f964:	6019      	str	r1, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFF;
 800f966:	6819      	ldr	r1, [r3, #0]
 800f968:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 800f96c:	6019      	str	r1, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
  RCC->CFGR &= 0xFF80FFFF;
 800f96e:	6859      	ldr	r1, [r3, #4]
 800f970:	f421 01fe 	bic.w	r1, r1, #8323072	; 0x7f0000
 800f974:	6059      	str	r1, [r3, #4]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800f976:	609a      	str	r2, [r3, #8]
}
 800f978:	4770      	bx	lr
 800f97a:	bf00      	nop
 800f97c:	40021000 	.word	0x40021000
 800f980:	f8ff0000 	.word	0xf8ff0000

0800f984 <RCC_HSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 800f984:	4b0c      	ldr	r3, [pc, #48]	; (800f9b8 <RCC_HSEConfig+0x34>)

  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;

  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 800f986:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 800f98a:	681a      	ldr	r2, [r3, #0]
 800f98c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800f990:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
 800f992:	681a      	ldr	r2, [r3, #0]
 800f994:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800f998:	601a      	str	r2, [r3, #0]

  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 800f99a:	d003      	beq.n	800f9a4 <RCC_HSEConfig+0x20>
 800f99c:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 800f9a0:	d109      	bne.n	800f9b6 <RCC_HSEConfig+0x32>
 800f9a2:	e004      	b.n	800f9ae <RCC_HSEConfig+0x2a>
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
 800f9a4:	681a      	ldr	r2, [r3, #0]
 800f9a6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800f9aa:	601a      	str	r2, [r3, #0]
      break;
 800f9ac:	4770      	bx	lr
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 800f9ae:	681a      	ldr	r2, [r3, #0]
 800f9b0:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 800f9b4:	601a      	str	r2, [r3, #0]
 800f9b6:	4770      	bx	lr
 800f9b8:	40021000 	.word	0x40021000

0800f9bc <RCC_AdjustHSICalibrationValue>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
 800f9bc:	4b03      	ldr	r3, [pc, #12]	; (800f9cc <RCC_AdjustHSICalibrationValue+0x10>)
 800f9be:	681a      	ldr	r2, [r3, #0]

  /* Clear HSITRIM[7:3] bits */
  tmpreg &= CR_HSITRIM_Mask;
 800f9c0:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8

  /* Set the HSITRIM[7:3] bits according to HSICalibrationValue value */
  tmpreg |= (u32)HSICalibrationValue << 3;
 800f9c4:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3

  /* Store the new value */
  RCC->CR = tmpreg;
 800f9c8:	601a      	str	r2, [r3, #0]
}
 800f9ca:	4770      	bx	lr
 800f9cc:	40021000 	.word	0x40021000

0800f9d0 <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_HSION_BB = (u32)NewState;
 800f9d0:	4b01      	ldr	r3, [pc, #4]	; (800f9d8 <RCC_HSICmd+0x8>)
 800f9d2:	6018      	str	r0, [r3, #0]
}
 800f9d4:	4770      	bx	lr
 800f9d6:	bf00      	nop
 800f9d8:	42420000 	.word	0x42420000

0800f9dc <RCC_PLLConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 800f9dc:	4b04      	ldr	r3, [pc, #16]	; (800f9f0 <RCC_PLLConfig+0x14>)
 800f9de:	685a      	ldr	r2, [r3, #4]

  /* Clear PLLSRC, PLLXTPRE and PLLMUL[21:18] bits */
  tmpreg &= CFGR_PLL_Mask;

  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 800f9e0:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 800f9e4:	ea40 0202 	orr.w	r2, r0, r2
 800f9e8:	430a      	orrs	r2, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800f9ea:	605a      	str	r2, [r3, #4]
}
 800f9ec:	4770      	bx	lr
 800f9ee:	bf00      	nop
 800f9f0:	40021000 	.word	0x40021000

0800f9f4 <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_PLLON_BB = (u32)NewState;
 800f9f4:	4b01      	ldr	r3, [pc, #4]	; (800f9fc <RCC_PLLCmd+0x8>)
 800f9f6:	6018      	str	r0, [r3, #0]
}
 800f9f8:	4770      	bx	lr
 800f9fa:	bf00      	nop
 800f9fc:	42420060 	.word	0x42420060

0800fa00 <RCC_SYSCLKConfig>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 800fa00:	4b03      	ldr	r3, [pc, #12]	; (800fa10 <RCC_SYSCLKConfig+0x10>)
 800fa02:	685a      	ldr	r2, [r3, #4]

  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 800fa04:	f022 0203 	bic.w	r2, r2, #3

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 800fa08:	ea40 0202 	orr.w	r2, r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800fa0c:	605a      	str	r2, [r3, #4]
}
 800fa0e:	4770      	bx	lr
 800fa10:	40021000 	.word	0x40021000

0800fa14 <RCC_GetSYSCLKSource>:
*                       - 0x04: HSE used as system clock
*                       - 0x08: PLL used as system clock
*******************************************************************************/
u8 RCC_GetSYSCLKSource(void)
{
  return ((u8)(RCC->CFGR & CFGR_SWS_Mask));
 800fa14:	4b02      	ldr	r3, [pc, #8]	; (800fa20 <RCC_GetSYSCLKSource+0xc>)
 800fa16:	6858      	ldr	r0, [r3, #4]
}
 800fa18:	f000 000c 	and.w	r0, r0, #12
 800fa1c:	4770      	bx	lr
 800fa1e:	bf00      	nop
 800fa20:	40021000 	.word	0x40021000

0800fa24 <RCC_HCLKConfig>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 800fa24:	4b03      	ldr	r3, [pc, #12]	; (800fa34 <RCC_HCLKConfig+0x10>)
 800fa26:	685a      	ldr	r2, [r3, #4]

  /* Clear HPRE[7:4] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 800fa28:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0

  /* Set HPRE[7:4] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 800fa2c:	ea40 0202 	orr.w	r2, r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800fa30:	605a      	str	r2, [r3, #4]
}
 800fa32:	4770      	bx	lr
 800fa34:	40021000 	.word	0x40021000

0800fa38 <RCC_PCLK1Config>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_PCLK1));

  tmpreg = RCC->CFGR;
 800fa38:	4b03      	ldr	r3, [pc, #12]	; (800fa48 <RCC_PCLK1Config+0x10>)
 800fa3a:	685a      	ldr	r2, [r3, #4]

  /* Clear PPRE1[10:8] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 800fa3c:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700

  /* Set PPRE1[10:8] bits according to RCC_PCLK1 value */
  tmpreg |= RCC_PCLK1;
 800fa40:	ea40 0202 	orr.w	r2, r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800fa44:	605a      	str	r2, [r3, #4]
}
 800fa46:	4770      	bx	lr
 800fa48:	40021000 	.word	0x40021000

0800fa4c <RCC_PCLK2Config>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_PCLK2));

  tmpreg = RCC->CFGR;
 800fa4c:	4b03      	ldr	r3, [pc, #12]	; (800fa5c <RCC_PCLK2Config+0x10>)
 800fa4e:	685a      	ldr	r2, [r3, #4]

  /* Clear PPRE2[13:11] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 800fa50:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800

  /* Set PPRE2[13:11] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2 << 3;
 800fa54:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800fa58:	605a      	str	r2, [r3, #4]
}
 800fa5a:	4770      	bx	lr
 800fa5c:	40021000 	.word	0x40021000

0800fa60 <RCC_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800fa60:	b119      	cbz	r1, 800fa6a <RCC_ITConfig+0xa>
  {
    /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
    *(vu8 *) 0x40021009 |= RCC_IT;
 800fa62:	4b05      	ldr	r3, [pc, #20]	; (800fa78 <RCC_ITConfig+0x18>)
 800fa64:	781a      	ldrb	r2, [r3, #0]
 800fa66:	4310      	orrs	r0, r2
 800fa68:	e003      	b.n	800fa72 <RCC_ITConfig+0x12>
  }
  else
  {
    /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
    *(vu8 *) 0x40021009 &= ~(u32)RCC_IT;
 800fa6a:	4b03      	ldr	r3, [pc, #12]	; (800fa78 <RCC_ITConfig+0x18>)
 800fa6c:	781a      	ldrb	r2, [r3, #0]
 800fa6e:	ea22 0000 	bic.w	r0, r2, r0
 800fa72:	7018      	strb	r0, [r3, #0]
 800fa74:	4770      	bx	lr
 800fa76:	bf00      	nop
 800fa78:	40021009 	.word	0x40021009

0800fa7c <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(u32 RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(vu32 *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 800fa7c:	4b01      	ldr	r3, [pc, #4]	; (800fa84 <RCC_USBCLKConfig+0x8>)
 800fa7e:	6018      	str	r0, [r3, #0]
}
 800fa80:	4770      	bx	lr
 800fa82:	bf00      	nop
 800fa84:	424200d8 	.word	0x424200d8

0800fa88 <RCC_ADCCLKConfig>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_ADCCLK));

  tmpreg = RCC->CFGR;
 800fa88:	4b03      	ldr	r3, [pc, #12]	; (800fa98 <RCC_ADCCLKConfig+0x10>)
 800fa8a:	685a      	ldr	r2, [r3, #4]

  /* Clear ADCPRE[15:14] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
 800fa8c:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000

  /* Set ADCPRE[15:14] bits according to RCC_ADCCLK value */
  tmpreg |= RCC_ADCCLK;
 800fa90:	ea40 0202 	orr.w	r2, r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800fa94:	605a      	str	r2, [r3, #4]
}
 800fa96:	4770      	bx	lr
 800fa98:	40021000 	.word	0x40021000

0800fa9c <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(vu8 *) BDCR_BASE = RCC_LSE_OFF;
 800fa9c:	4b06      	ldr	r3, [pc, #24]	; (800fab8 <RCC_LSEConfig+0x1c>)
 800fa9e:	2200      	movs	r2, #0

  /* Reset LSEBYP bit */
  *(vu8 *) BDCR_BASE = RCC_LSE_OFF;

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 800faa0:	2801      	cmp	r0, #1
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(vu8 *) BDCR_BASE = RCC_LSE_OFF;
 800faa2:	701a      	strb	r2, [r3, #0]

  /* Reset LSEBYP bit */
  *(vu8 *) BDCR_BASE = RCC_LSE_OFF;
 800faa4:	701a      	strb	r2, [r3, #0]

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 800faa6:	d002      	beq.n	800faae <RCC_LSEConfig+0x12>
 800faa8:	2804      	cmp	r0, #4
 800faaa:	d104      	bne.n	800fab6 <RCC_LSEConfig+0x1a>
 800faac:	e001      	b.n	800fab2 <RCC_LSEConfig+0x16>
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(vu8 *) BDCR_BASE = RCC_LSE_ON;
 800faae:	7018      	strb	r0, [r3, #0]
      break;
 800fab0:	4770      	bx	lr
      
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(vu8 *) BDCR_BASE = RCC_LSE_Bypass | RCC_LSE_ON;
 800fab2:	2205      	movs	r2, #5
 800fab4:	701a      	strb	r2, [r3, #0]
 800fab6:	4770      	bx	lr
 800fab8:	40021020 	.word	0x40021020

0800fabc <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CSR_LSION_BB = (u32)NewState;
 800fabc:	4b01      	ldr	r3, [pc, #4]	; (800fac4 <RCC_LSICmd+0x8>)
 800fabe:	6018      	str	r0, [r3, #0]
}
 800fac0:	4770      	bx	lr
 800fac2:	bf00      	nop
 800fac4:	42420480 	.word	0x42420480

0800fac8 <RCC_RTCCLKConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 800fac8:	4b02      	ldr	r3, [pc, #8]	; (800fad4 <RCC_RTCCLKConfig+0xc>)
 800faca:	6a1a      	ldr	r2, [r3, #32]
 800facc:	ea40 0202 	orr.w	r2, r0, r2
 800fad0:	621a      	str	r2, [r3, #32]
}
 800fad2:	4770      	bx	lr
 800fad4:	40021000 	.word	0x40021000

0800fad8 <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) BDCR_RTCEN_BB = (u32)NewState;
 800fad8:	4b01      	ldr	r3, [pc, #4]	; (800fae0 <RCC_RTCCLKCmd+0x8>)
 800fada:	6018      	str	r0, [r3, #0]
}
 800fadc:	4770      	bx	lr
 800fade:	bf00      	nop
 800fae0:	4242043c 	.word	0x4242043c

0800fae4 <RCC_GetClocksFreq>:
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 800fae4:	4b23      	ldr	r3, [pc, #140]	; (800fb74 <RCC_GetClocksFreq+0x90>)
*                    will hold the clocks frequencies.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 800fae6:	b510      	push	{r4, lr}
  u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 800fae8:	685a      	ldr	r2, [r3, #4]

  switch (tmp)
 800faea:	f002 020c 	and.w	r2, r2, #12
 800faee:	2a04      	cmp	r2, #4
 800faf0:	d014      	beq.n	800fb1c <RCC_GetClocksFreq+0x38>
 800faf2:	2a08      	cmp	r2, #8
 800faf4:	d112      	bne.n	800fb1c <RCC_GetClocksFreq+0x38>
      RCC_Clocks->SYSCLK_Frequency = HSE_Value;
      break;

    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 800faf6:	685a      	ldr	r2, [r3, #4]
      pllmull = ( pllmull >> 18) + 2;

      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 800faf8:	6859      	ldr	r1, [r3, #4]
      break;

    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
      pllmull = ( pllmull >> 18) + 2;
 800fafa:	f402 1270 	and.w	r2, r2, #3932160	; 0x3c0000
 800fafe:	0c92      	lsrs	r2, r2, #18
 800fb00:	3202      	adds	r2, #2

      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;

      if (pllsource == 0x00)
 800fb02:	f411 3f80 	tst.w	r1, #65536	; 0x10000
 800fb06:	d003      	beq.n	800fb10 <RCC_GetClocksFreq+0x2c>
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
      }
      else
      {/* HSE selected as PLL clock entry */

        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (u32)RESET)
 800fb08:	685b      	ldr	r3, [r3, #4]
 800fb0a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800fb0e:	d001      	beq.n	800fb14 <RCC_GetClocksFreq+0x30>
        {/* HSE oscillator clock divided by 2 */

          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
 800fb10:	4b19      	ldr	r3, [pc, #100]	; (800fb78 <RCC_GetClocksFreq+0x94>)
 800fb12:	e000      	b.n	800fb16 <RCC_GetClocksFreq+0x32>
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
 800fb14:	4b19      	ldr	r3, [pc, #100]	; (800fb7c <RCC_GetClocksFreq+0x98>)
 800fb16:	435a      	muls	r2, r3
 800fb18:	6002      	str	r2, [r0, #0]
 800fb1a:	e001      	b.n	800fb20 <RCC_GetClocksFreq+0x3c>
        }
      }
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
 800fb1c:	4b17      	ldr	r3, [pc, #92]	; (800fb7c <RCC_GetClocksFreq+0x98>)
 800fb1e:	6003      	str	r3, [r0, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 800fb20:	4a14      	ldr	r2, [pc, #80]	; (800fb74 <RCC_GetClocksFreq+0x90>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];

  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800fb22:	4b17      	ldr	r3, [pc, #92]	; (800fb80 <RCC_GetClocksFreq+0x9c>)
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 800fb24:	6851      	ldr	r1, [r2, #4]
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];

  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800fb26:	6804      	ldr	r4, [r0, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 800fb28:	f001 01f0 	and.w	r1, r1, #240	; 0xf0
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];

  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800fb2c:	0909      	lsrs	r1, r1, #4
 800fb2e:	5c59      	ldrb	r1, [r3, r1]
 800fb30:	fa34 f101 	lsrs.w	r1, r4, r1
 800fb34:	6041      	str	r1, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 800fb36:	6854      	ldr	r4, [r2, #4]
 800fb38:	f404 6ce0 	and.w	ip, r4, #1792	; 0x700
  tmp = tmp >> 8;
  presc = APBAHBPrescTable[tmp];

  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800fb3c:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
 800fb40:	f813 400c 	ldrb.w	r4, [r3, ip]
 800fb44:	fa31 f404 	lsrs.w	r4, r1, r4
 800fb48:	6084      	str	r4, [r0, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 800fb4a:	6854      	ldr	r4, [r2, #4]
 800fb4c:	f404 5c60 	and.w	ip, r4, #14336	; 0x3800
  tmp = tmp >> 11;
  presc = APBAHBPrescTable[tmp];

  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800fb50:	ea4f 2cdc 	mov.w	ip, ip, lsr #11
 800fb54:	f813 c00c 	ldrb.w	ip, [r3, ip]
 800fb58:	fa21 f10c 	lsr.w	r1, r1, ip
 800fb5c:	60c1      	str	r1, [r0, #12]

  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 800fb5e:	6852      	ldr	r2, [r2, #4]
 800fb60:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
  tmp = tmp >> 14;
  presc = ADCPrescTable[tmp];

  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 800fb64:	eb03 3392 	add.w	r3, r3, r2, lsr #14
 800fb68:	7c1b      	ldrb	r3, [r3, #16]
 800fb6a:	fbb1 f1f3 	udiv	r1, r1, r3
 800fb6e:	6101      	str	r1, [r0, #16]
}
 800fb70:	bd10      	pop	{r4, pc}
 800fb72:	bf00      	nop
 800fb74:	40021000 	.word	0x40021000
 800fb78:	003d0900 	.word	0x003d0900
 800fb7c:	007a1200 	.word	0x007a1200
 800fb80:	08010648 	.word	0x08010648

0800fb84 <RCC_AHBPeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800fb84:	b119      	cbz	r1, 800fb8e <RCC_AHBPeriphClockCmd+0xa>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 800fb86:	4b05      	ldr	r3, [pc, #20]	; (800fb9c <RCC_AHBPeriphClockCmd+0x18>)
 800fb88:	695a      	ldr	r2, [r3, #20]
 800fb8a:	4310      	orrs	r0, r2
 800fb8c:	e003      	b.n	800fb96 <RCC_AHBPeriphClockCmd+0x12>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 800fb8e:	4b03      	ldr	r3, [pc, #12]	; (800fb9c <RCC_AHBPeriphClockCmd+0x18>)
 800fb90:	695a      	ldr	r2, [r3, #20]
 800fb92:	ea22 0000 	bic.w	r0, r2, r0
 800fb96:	6158      	str	r0, [r3, #20]
 800fb98:	4770      	bx	lr
 800fb9a:	bf00      	nop
 800fb9c:	40021000 	.word	0x40021000

0800fba0 <RCC_APB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800fba0:	b119      	cbz	r1, 800fbaa <RCC_APB2PeriphClockCmd+0xa>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 800fba2:	4b05      	ldr	r3, [pc, #20]	; (800fbb8 <RCC_APB2PeriphClockCmd+0x18>)
 800fba4:	699a      	ldr	r2, [r3, #24]
 800fba6:	4310      	orrs	r0, r2
 800fba8:	e003      	b.n	800fbb2 <RCC_APB2PeriphClockCmd+0x12>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800fbaa:	4b03      	ldr	r3, [pc, #12]	; (800fbb8 <RCC_APB2PeriphClockCmd+0x18>)
 800fbac:	699a      	ldr	r2, [r3, #24]
 800fbae:	ea22 0000 	bic.w	r0, r2, r0
 800fbb2:	6198      	str	r0, [r3, #24]
 800fbb4:	4770      	bx	lr
 800fbb6:	bf00      	nop
 800fbb8:	40021000 	.word	0x40021000

0800fbbc <RCC_APB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800fbbc:	b119      	cbz	r1, 800fbc6 <RCC_APB1PeriphClockCmd+0xa>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 800fbbe:	4b05      	ldr	r3, [pc, #20]	; (800fbd4 <RCC_APB1PeriphClockCmd+0x18>)
 800fbc0:	69da      	ldr	r2, [r3, #28]
 800fbc2:	4310      	orrs	r0, r2
 800fbc4:	e003      	b.n	800fbce <RCC_APB1PeriphClockCmd+0x12>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 800fbc6:	4b03      	ldr	r3, [pc, #12]	; (800fbd4 <RCC_APB1PeriphClockCmd+0x18>)
 800fbc8:	69da      	ldr	r2, [r3, #28]
 800fbca:	ea22 0000 	bic.w	r0, r2, r0
 800fbce:	61d8      	str	r0, [r3, #28]
 800fbd0:	4770      	bx	lr
 800fbd2:	bf00      	nop
 800fbd4:	40021000 	.word	0x40021000

0800fbd8 <RCC_APB2PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800fbd8:	b119      	cbz	r1, 800fbe2 <RCC_APB2PeriphResetCmd+0xa>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 800fbda:	4b05      	ldr	r3, [pc, #20]	; (800fbf0 <RCC_APB2PeriphResetCmd+0x18>)
 800fbdc:	68da      	ldr	r2, [r3, #12]
 800fbde:	4310      	orrs	r0, r2
 800fbe0:	e003      	b.n	800fbea <RCC_APB2PeriphResetCmd+0x12>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 800fbe2:	4b03      	ldr	r3, [pc, #12]	; (800fbf0 <RCC_APB2PeriphResetCmd+0x18>)
 800fbe4:	68da      	ldr	r2, [r3, #12]
 800fbe6:	ea22 0000 	bic.w	r0, r2, r0
 800fbea:	60d8      	str	r0, [r3, #12]
 800fbec:	4770      	bx	lr
 800fbee:	bf00      	nop
 800fbf0:	40021000 	.word	0x40021000

0800fbf4 <RCC_APB1PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800fbf4:	b119      	cbz	r1, 800fbfe <RCC_APB1PeriphResetCmd+0xa>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 800fbf6:	4b05      	ldr	r3, [pc, #20]	; (800fc0c <RCC_APB1PeriphResetCmd+0x18>)
 800fbf8:	691a      	ldr	r2, [r3, #16]
 800fbfa:	4310      	orrs	r0, r2
 800fbfc:	e003      	b.n	800fc06 <RCC_APB1PeriphResetCmd+0x12>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 800fbfe:	4b03      	ldr	r3, [pc, #12]	; (800fc0c <RCC_APB1PeriphResetCmd+0x18>)
 800fc00:	691a      	ldr	r2, [r3, #16]
 800fc02:	ea22 0000 	bic.w	r0, r2, r0
 800fc06:	6118      	str	r0, [r3, #16]
 800fc08:	4770      	bx	lr
 800fc0a:	bf00      	nop
 800fc0c:	40021000 	.word	0x40021000

0800fc10 <RCC_BackupResetCmd>:
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) BDCR_BDRST_BB = (u32)NewState;
 800fc10:	4b01      	ldr	r3, [pc, #4]	; (800fc18 <RCC_BackupResetCmd+0x8>)
 800fc12:	6018      	str	r0, [r3, #0]
}
 800fc14:	4770      	bx	lr
 800fc16:	bf00      	nop
 800fc18:	42420440 	.word	0x42420440

0800fc1c <RCC_ClockSecuritySystemCmd>:
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_CSSON_BB = (u32)NewState;
 800fc1c:	4b01      	ldr	r3, [pc, #4]	; (800fc24 <RCC_ClockSecuritySystemCmd+0x8>)
 800fc1e:	6018      	str	r0, [r3, #0]
}
 800fc20:	4770      	bx	lr
 800fc22:	bf00      	nop
 800fc24:	4242004c 	.word	0x4242004c

0800fc28 <RCC_MCOConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCO));

  /* Perform Byte access to MCO[26:24] bits to select the MCO source */
  *(vu8 *) 0x40021007 = RCC_MCO;
 800fc28:	4b01      	ldr	r3, [pc, #4]	; (800fc30 <RCC_MCOConfig+0x8>)
 800fc2a:	7018      	strb	r0, [r3, #0]
}
 800fc2c:	4770      	bx	lr
 800fc2e:	bf00      	nop
 800fc30:	40021007 	.word	0x40021007

0800fc34 <RCC_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 800fc34:	0943      	lsrs	r3, r0, #5

  if (tmp == 1)               /* The flag to check is in CR register */
 800fc36:	2b01      	cmp	r3, #1
 800fc38:	d102      	bne.n	800fc40 <RCC_GetFlagStatus+0xc>
  {
    statusreg = RCC->CR;
 800fc3a:	4b07      	ldr	r3, [pc, #28]	; (800fc58 <RCC_GetFlagStatus+0x24>)
 800fc3c:	681b      	ldr	r3, [r3, #0]
 800fc3e:	e004      	b.n	800fc4a <RCC_GetFlagStatus+0x16>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 800fc40:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 800fc42:	4b05      	ldr	r3, [pc, #20]	; (800fc58 <RCC_GetFlagStatus+0x24>)
 800fc44:	bf0c      	ite	eq
 800fc46:	6a1b      	ldreq	r3, [r3, #32]
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 800fc48:	6a5b      	ldrne	r3, [r3, #36]	; 0x24
 800fc4a:	f000 001f 	and.w	r0, r0, #31
 800fc4e:	fa33 f000 	lsrs.w	r0, r3, r0
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
}
 800fc52:	f000 0001 	and.w	r0, r0, #1
 800fc56:	4770      	bx	lr
 800fc58:	40021000 	.word	0x40021000

0800fc5c <RCC_WaitForHSEStartUp>:
* Return         : An ErrorStatus enumuration value:
*                         - SUCCESS: HSE oscillator is stable and ready to use
*                         - ERROR: HSE oscillator not yet ready
*******************************************************************************/
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 800fc5c:	b508      	push	{r3, lr}
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 800fc5e:	2031      	movs	r0, #49	; 0x31
 800fc60:	f7ff ffe8 	bl	800fc34 <RCC_GetFlagStatus>
 800fc64:	4b08      	ldr	r3, [pc, #32]	; (800fc88 <RCC_WaitForHSEStartUp+0x2c>)
 800fc66:	7018      	strb	r0, [r3, #0]
    StartUpCounter++;  
 800fc68:	685a      	ldr	r2, [r3, #4]
 800fc6a:	3201      	adds	r2, #1
 800fc6c:	605a      	str	r2, [r3, #4]
  } while((HSEStatus == RESET) && (StartUpCounter != HSEStartUp_TimeOut));
 800fc6e:	781a      	ldrb	r2, [r3, #0]
 800fc70:	b912      	cbnz	r2, 800fc78 <RCC_WaitForHSEStartUp+0x1c>
 800fc72:	685b      	ldr	r3, [r3, #4]
 800fc74:	2bff      	cmp	r3, #255	; 0xff
 800fc76:	d1f2      	bne.n	800fc5e <RCC_WaitForHSEStartUp+0x2>


  if(RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 800fc78:	2031      	movs	r0, #49	; 0x31
 800fc7a:	f7ff ffdb 	bl	800fc34 <RCC_GetFlagStatus>
  }
  else
  {
    return ERROR;
  }  
}
 800fc7e:	3800      	subs	r0, #0
 800fc80:	bf18      	it	ne
 800fc82:	2001      	movne	r0, #1
 800fc84:	bd08      	pop	{r3, pc}
 800fc86:	bf00      	nop
 800fc88:	20004da8 	.word	0x20004da8

0800fc8c <RCC_ClearFlag>:
* Return         : None
*******************************************************************************/
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= CSR_RMVF_Set;
 800fc8c:	4b02      	ldr	r3, [pc, #8]	; (800fc98 <RCC_ClearFlag+0xc>)
 800fc8e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800fc90:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800fc94:	625a      	str	r2, [r3, #36]	; 0x24
}
 800fc96:	4770      	bx	lr
 800fc98:	40021000 	.word	0x40021000

0800fc9c <RCC_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (u32)RESET)
 800fc9c:	4b03      	ldr	r3, [pc, #12]	; (800fcac <RCC_GetITStatus+0x10>)
 800fc9e:	689b      	ldr	r3, [r3, #8]
 800fca0:	4218      	tst	r0, r3
    bitstatus = RESET;
  }

  /* Return the RCC_IT status */
  return  bitstatus;
}
 800fca2:	bf0c      	ite	eq
 800fca4:	2000      	moveq	r0, #0
 800fca6:	2001      	movne	r0, #1
 800fca8:	4770      	bx	lr
 800fcaa:	bf00      	nop
 800fcac:	40021000 	.word	0x40021000

0800fcb0 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(vu8 *) 0x4002100A = RCC_IT;
 800fcb0:	4b01      	ldr	r3, [pc, #4]	; (800fcb8 <RCC_ClearITPendingBit+0x8>)
 800fcb2:	7018      	strb	r0, [r3, #0]
}
 800fcb4:	4770      	bx	lr
 800fcb6:	bf00      	nop
 800fcb8:	4002100a 	.word	0x4002100a

0800fcbc <int64_add>:
 800fcbc:	b082      	sub	sp, #8
 800fcbe:	b513      	push	{r0, r1, r4, lr}
 800fcc0:	46ec      	mov	ip, sp
 800fcc2:	e88c 0006 	stmia.w	ip, {r1, r2}
 800fcc6:	9a01      	ldr	r2, [sp, #4]
 800fcc8:	9900      	ldr	r1, [sp, #0]
 800fcca:	9c06      	ldr	r4, [sp, #24]
 800fccc:	1859      	adds	r1, r3, r1
 800fcce:	1912      	adds	r2, r2, r4
 800fcd0:	9305      	str	r3, [sp, #20]
 800fcd2:	d201      	bcs.n	800fcd8 <int64_add+0x1c>
 800fcd4:	4299      	cmp	r1, r3
 800fcd6:	da00      	bge.n	800fcda <int64_add+0x1e>
 800fcd8:	3101      	adds	r1, #1
 800fcda:	6042      	str	r2, [r0, #4]
 800fcdc:	6001      	str	r1, [r0, #0]
 800fcde:	e8bd 401c 	ldmia.w	sp!, {r2, r3, r4, lr}
 800fce2:	b002      	add	sp, #8
 800fce4:	4770      	bx	lr

0800fce6 <int64_shift>:
 800fce6:	b082      	sub	sp, #8
 800fce8:	46ec      	mov	ip, sp
 800fcea:	e88c 0006 	stmia.w	ip, {r1, r2}
 800fcee:	2b00      	cmp	r3, #0
 800fcf0:	460a      	mov	r2, r1
 800fcf2:	9901      	ldr	r1, [sp, #4]
 800fcf4:	dd0a      	ble.n	800fd0c <int64_shift+0x26>
 800fcf6:	2b1f      	cmp	r3, #31
 800fcf8:	dc0e      	bgt.n	800fd18 <int64_shift+0x32>
 800fcfa:	f1c3 0c20 	rsb	ip, r3, #32
 800fcfe:	fa21 fc0c 	lsr.w	ip, r1, ip
 800fd02:	409a      	lsls	r2, r3
 800fd04:	4099      	lsls	r1, r3
 800fd06:	ea4c 0202 	orr.w	r2, ip, r2
 800fd0a:	e013      	b.n	800fd34 <int64_shift+0x4e>
 800fd0c:	425b      	negs	r3, r3
 800fd0e:	fa4f fc83 	sxtb.w	ip, r3
 800fd12:	f1bc 0f1f 	cmp.w	ip, #31
 800fd16:	dd03      	ble.n	800fd20 <int64_shift+0x3a>
 800fd18:	2300      	movs	r3, #0
 800fd1a:	6003      	str	r3, [r0, #0]
 800fd1c:	6043      	str	r3, [r0, #4]
 800fd1e:	e00b      	b.n	800fd38 <int64_shift+0x52>
 800fd20:	f1cc 0320 	rsb	r3, ip, #32
 800fd24:	fa12 f303 	lsls.w	r3, r2, r3
 800fd28:	fa21 f10c 	lsr.w	r1, r1, ip
 800fd2c:	fa42 f20c 	asr.w	r2, r2, ip
 800fd30:	ea43 0101 	orr.w	r1, r3, r1
 800fd34:	6041      	str	r1, [r0, #4]
 800fd36:	6002      	str	r2, [r0, #0]
 800fd38:	b002      	add	sp, #8
 800fd3a:	4770      	bx	lr

0800fd3c <int64_mul_i32_i32>:
 800fd3c:	b570      	push	{r4, r5, r6, lr}
 800fd3e:	140d      	asrs	r5, r1, #16
 800fd40:	1414      	asrs	r4, r2, #16
 800fd42:	b292      	uxth	r2, r2
 800fd44:	fb05 fc02 	mul.w	ip, r5, r2
 800fd48:	b289      	uxth	r1, r1
 800fd4a:	fb01 cc04 	mla	ip, r1, r4, ip
 800fd4e:	ea4f 462c 	mov.w	r6, ip, asr #16
 800fd52:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 800fd56:	fb05 6404 	mla	r4, r5, r4, r6
 800fd5a:	fb01 c102 	mla	r1, r1, r2, ip
 800fd5e:	6004      	str	r4, [r0, #0]
 800fd60:	6041      	str	r1, [r0, #4]
 800fd62:	bd70      	pop	{r4, r5, r6, pc}

0800fd64 <fix16_mul>:
 800fd64:	ea4f 4c20 	mov.w	ip, r0, asr #16
 800fd68:	140b      	asrs	r3, r1, #16
 800fd6a:	b289      	uxth	r1, r1
 800fd6c:	fb0c f201 	mul.w	r2, ip, r1
 800fd70:	b280      	uxth	r0, r0
 800fd72:	fb00 2203 	mla	r2, r0, r3, r2
 800fd76:	4348      	muls	r0, r1
 800fd78:	fb0c f303 	mul.w	r3, ip, r3
 800fd7c:	eb03 4322 	add.w	r3, r3, r2, asr #16
 800fd80:	eb00 4202 	add.w	r2, r0, r2, lsl #16
 800fd84:	4282      	cmp	r2, r0
 800fd86:	bf38      	it	cc
 800fd88:	3301      	addcc	r3, #1
 800fd8a:	f5a2 4100 	sub.w	r1, r2, #32768	; 0x8000
 800fd8e:	eb01 71e3 	add.w	r1, r1, r3, asr #31
 800fd92:	4291      	cmp	r1, r2
 800fd94:	bf88      	it	hi
 800fd96:	3b01      	subhi	r3, #1
 800fd98:	0c09      	lsrs	r1, r1, #16
 800fd9a:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 800fd9e:	1c58      	adds	r0, r3, #1
 800fda0:	4770      	bx	lr

0800fda2 <fix16_lerp8>:
 800fda2:	b570      	push	{r4, r5, r6, lr}
 800fda4:	b086      	sub	sp, #24
 800fda6:	ac04      	add	r4, sp, #16
 800fda8:	4603      	mov	r3, r0
 800fdaa:	460e      	mov	r6, r1
 800fdac:	4615      	mov	r5, r2
 800fdae:	4619      	mov	r1, r3
 800fdb0:	4620      	mov	r0, r4
 800fdb2:	f5c2 7280 	rsb	r2, r2, #256	; 0x100
 800fdb6:	f7ff ffc1 	bl	800fd3c <int64_mul_i32_i32>
 800fdba:	a802      	add	r0, sp, #8
 800fdbc:	4631      	mov	r1, r6
 800fdbe:	462a      	mov	r2, r5
 800fdc0:	f7ff ffbc 	bl	800fd3c <int64_mul_i32_i32>
 800fdc4:	9b03      	ldr	r3, [sp, #12]
 800fdc6:	4620      	mov	r0, r4
 800fdc8:	9300      	str	r3, [sp, #0]
 800fdca:	e894 0006 	ldmia.w	r4, {r1, r2}
 800fdce:	9b02      	ldr	r3, [sp, #8]
 800fdd0:	f7ff ff74 	bl	800fcbc <int64_add>
 800fdd4:	e894 0006 	ldmia.w	r4, {r1, r2}
 800fdd8:	4620      	mov	r0, r4
 800fdda:	f06f 0307 	mvn.w	r3, #7
 800fdde:	f7ff ff82 	bl	800fce6 <int64_shift>
 800fde2:	9805      	ldr	r0, [sp, #20]
 800fde4:	b006      	add	sp, #24
 800fde6:	bd70      	pop	{r4, r5, r6, pc}

0800fde8 <fix16_lerp16>:
 800fde8:	b570      	push	{r4, r5, r6, lr}
 800fdea:	b086      	sub	sp, #24
 800fdec:	ac04      	add	r4, sp, #16
 800fdee:	4603      	mov	r3, r0
 800fdf0:	460e      	mov	r6, r1
 800fdf2:	4615      	mov	r5, r2
 800fdf4:	4619      	mov	r1, r3
 800fdf6:	4620      	mov	r0, r4
 800fdf8:	f5c2 3280 	rsb	r2, r2, #65536	; 0x10000
 800fdfc:	f7ff ff9e 	bl	800fd3c <int64_mul_i32_i32>
 800fe00:	a802      	add	r0, sp, #8
 800fe02:	4631      	mov	r1, r6
 800fe04:	462a      	mov	r2, r5
 800fe06:	f7ff ff99 	bl	800fd3c <int64_mul_i32_i32>
 800fe0a:	9b03      	ldr	r3, [sp, #12]
 800fe0c:	4620      	mov	r0, r4
 800fe0e:	9300      	str	r3, [sp, #0]
 800fe10:	e894 0006 	ldmia.w	r4, {r1, r2}
 800fe14:	9b02      	ldr	r3, [sp, #8]
 800fe16:	f7ff ff51 	bl	800fcbc <int64_add>
 800fe1a:	e894 0006 	ldmia.w	r4, {r1, r2}
 800fe1e:	4620      	mov	r0, r4
 800fe20:	f06f 030f 	mvn.w	r3, #15
 800fe24:	f7ff ff5f 	bl	800fce6 <int64_shift>
 800fe28:	9805      	ldr	r0, [sp, #20]
 800fe2a:	b006      	add	sp, #24
 800fe2c:	bd70      	pop	{r4, r5, r6, pc}

0800fe2e <fix16_div>:
 800fe2e:	b5d0      	push	{r4, r6, r7, lr}
 800fe30:	4603      	mov	r3, r0
 800fe32:	460a      	mov	r2, r1
 800fe34:	b911      	cbnz	r1, 800fe3c <fix16_div+0xe>
 800fe36:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800fe3a:	bdd0      	pop	{r4, r6, r7, pc}
 800fe3c:	ea81 71e1 	eor.w	r1, r1, r1, asr #31
 800fe40:	eba1 71e2 	sub.w	r1, r1, r2, asr #31
 800fe44:	0d0c      	lsrs	r4, r1, #20
 800fe46:	ea80 70e0 	eor.w	r0, r0, r0, asr #31
 800fe4a:	0524      	lsls	r4, r4, #20
 800fe4c:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
 800fe50:	b15c      	cbz	r4, 800fe6a <fix16_div+0x3c>
 800fe52:	0c4c      	lsrs	r4, r1, #17
 800fe54:	3401      	adds	r4, #1
 800fe56:	fbb0 f4f4 	udiv	r4, r0, r4
 800fe5a:	fba4 6701 	umull	r6, r7, r4, r1
 800fe5e:	ea4f 4c56 	mov.w	ip, r6, lsr #17
 800fe62:	ea4c 3cc7 	orr.w	ip, ip, r7, lsl #15
 800fe66:	ebcc 0000 	rsb	r0, ip, r0
 800fe6a:	f04f 0c11 	mov.w	ip, #17
 800fe6e:	e002      	b.n	800fe76 <fix16_div+0x48>
 800fe70:	0909      	lsrs	r1, r1, #4
 800fe72:	f1ac 0c04 	sub.w	ip, ip, #4
 800fe76:	f011 0f0f 	tst.w	r1, #15
 800fe7a:	d115      	bne.n	800fea8 <fix16_div+0x7a>
 800fe7c:	f1bc 0f01 	cmp.w	ip, #1
 800fe80:	d1f6      	bne.n	800fe70 <fix16_div+0x42>
 800fe82:	e011      	b.n	800fea8 <fix16_div+0x7a>
 800fe84:	fab0 f680 	clz	r6, r0
 800fe88:	4566      	cmp	r6, ip
 800fe8a:	bfa8      	it	ge
 800fe8c:	4666      	movge	r6, ip
 800fe8e:	40b0      	lsls	r0, r6
 800fe90:	ebc6 0c0c 	rsb	ip, r6, ip
 800fe94:	fbb0 f6f1 	udiv	r6, r0, r1
 800fe98:	fb01 0016 	mls	r0, r1, r6, r0
 800fe9c:	fa06 f60c 	lsl.w	r6, r6, ip
 800fea0:	0040      	lsls	r0, r0, #1
 800fea2:	19a4      	adds	r4, r4, r6
 800fea4:	f10c 3cff 	add.w	ip, ip, #4294967295
 800fea8:	b110      	cbz	r0, 800feb0 <fix16_div+0x82>
 800feaa:	f1bc 0f00 	cmp.w	ip, #0
 800feae:	dae9      	bge.n	800fe84 <fix16_div+0x56>
 800feb0:	3401      	adds	r4, #1
 800feb2:	0860      	lsrs	r0, r4, #1
 800feb4:	ea92 0f03 	teq	r2, r3
 800feb8:	bf48      	it	mi
 800feba:	4240      	negmi	r0, r0
 800febc:	bdd0      	pop	{r4, r6, r7, pc}
	...

0800fec0 <memset>:
 800fec0:	2a03      	cmp	r2, #3
 800fec2:	b2c9      	uxtb	r1, r1
 800fec4:	b430      	push	{r4, r5}
 800fec6:	d807      	bhi.n	800fed8 <memset+0x18>
 800fec8:	b122      	cbz	r2, 800fed4 <memset+0x14>
 800feca:	2300      	movs	r3, #0
 800fecc:	54c1      	strb	r1, [r0, r3]
 800fece:	3301      	adds	r3, #1
 800fed0:	4293      	cmp	r3, r2
 800fed2:	d1fb      	bne.n	800fecc <memset+0xc>
 800fed4:	bc30      	pop	{r4, r5}
 800fed6:	4770      	bx	lr
 800fed8:	eb00 0c02 	add.w	ip, r0, r2
 800fedc:	4603      	mov	r3, r0
 800fede:	e001      	b.n	800fee4 <memset+0x24>
 800fee0:	f803 1c01 	strb.w	r1, [r3, #-1]
 800fee4:	f003 0403 	and.w	r4, r3, #3
 800fee8:	461a      	mov	r2, r3
 800feea:	3301      	adds	r3, #1
 800feec:	2c00      	cmp	r4, #0
 800feee:	d1f7      	bne.n	800fee0 <memset+0x20>
 800fef0:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
 800fef4:	ebc2 040c 	rsb	r4, r2, ip
 800fef8:	fb03 f301 	mul.w	r3, r3, r1
 800fefc:	e01f      	b.n	800ff3e <memset+0x7e>
 800fefe:	f842 3c40 	str.w	r3, [r2, #-64]
 800ff02:	f842 3c3c 	str.w	r3, [r2, #-60]
 800ff06:	f842 3c38 	str.w	r3, [r2, #-56]
 800ff0a:	f842 3c34 	str.w	r3, [r2, #-52]
 800ff0e:	f842 3c30 	str.w	r3, [r2, #-48]
 800ff12:	f842 3c2c 	str.w	r3, [r2, #-44]
 800ff16:	f842 3c28 	str.w	r3, [r2, #-40]
 800ff1a:	f842 3c24 	str.w	r3, [r2, #-36]
 800ff1e:	f842 3c20 	str.w	r3, [r2, #-32]
 800ff22:	f842 3c1c 	str.w	r3, [r2, #-28]
 800ff26:	f842 3c18 	str.w	r3, [r2, #-24]
 800ff2a:	f842 3c14 	str.w	r3, [r2, #-20]
 800ff2e:	f842 3c10 	str.w	r3, [r2, #-16]
 800ff32:	f842 3c0c 	str.w	r3, [r2, #-12]
 800ff36:	f842 3c08 	str.w	r3, [r2, #-8]
 800ff3a:	f842 3c04 	str.w	r3, [r2, #-4]
 800ff3e:	4615      	mov	r5, r2
 800ff40:	3240      	adds	r2, #64	; 0x40
 800ff42:	2c3f      	cmp	r4, #63	; 0x3f
 800ff44:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
 800ff48:	dcd9      	bgt.n	800fefe <memset+0x3e>
 800ff4a:	462a      	mov	r2, r5
 800ff4c:	ebc5 040c 	rsb	r4, r5, ip
 800ff50:	e007      	b.n	800ff62 <memset+0xa2>
 800ff52:	f842 3c10 	str.w	r3, [r2, #-16]
 800ff56:	f842 3c0c 	str.w	r3, [r2, #-12]
 800ff5a:	f842 3c08 	str.w	r3, [r2, #-8]
 800ff5e:	f842 3c04 	str.w	r3, [r2, #-4]
 800ff62:	4615      	mov	r5, r2
 800ff64:	3210      	adds	r2, #16
 800ff66:	2c0f      	cmp	r4, #15
 800ff68:	f1a4 0410 	sub.w	r4, r4, #16
 800ff6c:	dcf1      	bgt.n	800ff52 <memset+0x92>
 800ff6e:	462a      	mov	r2, r5
 800ff70:	ebc5 050c 	rsb	r5, r5, ip
 800ff74:	e001      	b.n	800ff7a <memset+0xba>
 800ff76:	f842 3c04 	str.w	r3, [r2, #-4]
 800ff7a:	4614      	mov	r4, r2
 800ff7c:	3204      	adds	r2, #4
 800ff7e:	2d03      	cmp	r5, #3
 800ff80:	f1a5 0504 	sub.w	r5, r5, #4
 800ff84:	dcf7      	bgt.n	800ff76 <memset+0xb6>
 800ff86:	e001      	b.n	800ff8c <memset+0xcc>
 800ff88:	f804 1b01 	strb.w	r1, [r4], #1
 800ff8c:	4564      	cmp	r4, ip
 800ff8e:	d3fb      	bcc.n	800ff88 <memset+0xc8>
 800ff90:	e7a0      	b.n	800fed4 <memset+0x14>
 800ff92:	bf00      	nop

0800ff94 <strcpy>:
 800ff94:	ea80 0201 	eor.w	r2, r0, r1
 800ff98:	4684      	mov	ip, r0
 800ff9a:	f012 0f03 	tst.w	r2, #3
 800ff9e:	d14f      	bne.n	8010040 <strcpy+0xac>
 800ffa0:	f011 0f03 	tst.w	r1, #3
 800ffa4:	d132      	bne.n	801000c <strcpy+0x78>
 800ffa6:	f84d 4d04 	str.w	r4, [sp, #-4]!
 800ffaa:	f011 0f04 	tst.w	r1, #4
 800ffae:	f851 3b04 	ldr.w	r3, [r1], #4
 800ffb2:	d00b      	beq.n	800ffcc <strcpy+0x38>
 800ffb4:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 800ffb8:	439a      	bics	r2, r3
 800ffba:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 800ffbe:	bf04      	itt	eq
 800ffc0:	f84c 3b04 	streq.w	r3, [ip], #4
 800ffc4:	f851 3b04 	ldreq.w	r3, [r1], #4
 800ffc8:	d116      	bne.n	800fff8 <strcpy+0x64>
 800ffca:	bf00      	nop
 800ffcc:	f851 4b04 	ldr.w	r4, [r1], #4
 800ffd0:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 800ffd4:	439a      	bics	r2, r3
 800ffd6:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 800ffda:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 800ffde:	d10b      	bne.n	800fff8 <strcpy+0x64>
 800ffe0:	f84c 3b04 	str.w	r3, [ip], #4
 800ffe4:	43a2      	bics	r2, r4
 800ffe6:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 800ffea:	bf04      	itt	eq
 800ffec:	f851 3b04 	ldreq.w	r3, [r1], #4
 800fff0:	f84c 4b04 	streq.w	r4, [ip], #4
 800fff4:	d0ea      	beq.n	800ffcc <strcpy+0x38>
 800fff6:	4623      	mov	r3, r4
 800fff8:	f80c 3b01 	strb.w	r3, [ip], #1
 800fffc:	f013 0fff 	tst.w	r3, #255	; 0xff
 8010000:	ea4f 2333 	mov.w	r3, r3, ror #8
 8010004:	d1f8      	bne.n	800fff8 <strcpy+0x64>
 8010006:	f85d 4b04 	ldr.w	r4, [sp], #4
 801000a:	4770      	bx	lr
 801000c:	f011 0f01 	tst.w	r1, #1
 8010010:	d006      	beq.n	8010020 <strcpy+0x8c>
 8010012:	f811 2b01 	ldrb.w	r2, [r1], #1
 8010016:	f80c 2b01 	strb.w	r2, [ip], #1
 801001a:	2a00      	cmp	r2, #0
 801001c:	bf08      	it	eq
 801001e:	4770      	bxeq	lr
 8010020:	f011 0f02 	tst.w	r1, #2
 8010024:	d0bf      	beq.n	800ffa6 <strcpy+0x12>
 8010026:	f831 2b02 	ldrh.w	r2, [r1], #2
 801002a:	f012 0fff 	tst.w	r2, #255	; 0xff
 801002e:	bf16      	itet	ne
 8010030:	f82c 2b02 	strhne.w	r2, [ip], #2
 8010034:	f88c 2000 	strbeq.w	r2, [ip]
 8010038:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
 801003c:	d1b3      	bne.n	800ffa6 <strcpy+0x12>
 801003e:	4770      	bx	lr
 8010040:	f811 2b01 	ldrb.w	r2, [r1], #1
 8010044:	f80c 2b01 	strb.w	r2, [ip], #1
 8010048:	2a00      	cmp	r2, #0
 801004a:	d1f9      	bne.n	8010040 <strcpy+0xac>
 801004c:	4770      	bx	lr
 801004e:	bf00      	nop

08010050 <strlen>:
 8010050:	f020 0103 	bic.w	r1, r0, #3
 8010054:	f010 0003 	ands.w	r0, r0, #3
 8010058:	f1c0 0000 	rsb	r0, r0, #0
 801005c:	f851 3b04 	ldr.w	r3, [r1], #4
 8010060:	f100 0c04 	add.w	ip, r0, #4
 8010064:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8010068:	f06f 0200 	mvn.w	r2, #0
 801006c:	bf1c      	itt	ne
 801006e:	fa22 f20c 	lsrne.w	r2, r2, ip
 8010072:	4313      	orrne	r3, r2
 8010074:	f04f 0c01 	mov.w	ip, #1
 8010078:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 801007c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8010080:	eba3 020c 	sub.w	r2, r3, ip
 8010084:	ea22 0203 	bic.w	r2, r2, r3
 8010088:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 801008c:	bf04      	itt	eq
 801008e:	f851 3b04 	ldreq.w	r3, [r1], #4
 8010092:	3004      	addeq	r0, #4
 8010094:	d0f4      	beq.n	8010080 <strlen+0x30>
 8010096:	f013 0fff 	tst.w	r3, #255	; 0xff
 801009a:	bf1f      	itttt	ne
 801009c:	3001      	addne	r0, #1
 801009e:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 80100a2:	3001      	addne	r0, #1
 80100a4:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 80100a8:	bf18      	it	ne
 80100aa:	3001      	addne	r0, #1
 80100ac:	4770      	bx	lr
 80100ae:	bf00      	nop

080100b0 <strncmp>:
 80100b0:	b430      	push	{r4, r5}
 80100b2:	4613      	mov	r3, r2
 80100b4:	2a00      	cmp	r2, #0
 80100b6:	d043      	beq.n	8010140 <strncmp+0x90>
 80100b8:	ea41 0200 	orr.w	r2, r1, r0
 80100bc:	f012 0f03 	tst.w	r2, #3
 80100c0:	d125      	bne.n	801010e <strncmp+0x5e>
 80100c2:	2b03      	cmp	r3, #3
 80100c4:	4604      	mov	r4, r0
 80100c6:	460d      	mov	r5, r1
 80100c8:	d93d      	bls.n	8010146 <strncmp+0x96>
 80100ca:	6802      	ldr	r2, [r0, #0]
 80100cc:	6809      	ldr	r1, [r1, #0]
 80100ce:	428a      	cmp	r2, r1
 80100d0:	d139      	bne.n	8010146 <strncmp+0x96>
 80100d2:	3b04      	subs	r3, #4
 80100d4:	d034      	beq.n	8010140 <strncmp+0x90>
 80100d6:	f1a2 3101 	sub.w	r1, r2, #16843009	; 0x1010101
 80100da:	ea21 0202 	bic.w	r2, r1, r2
 80100de:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 80100e2:	d00d      	beq.n	8010100 <strncmp+0x50>
 80100e4:	e02c      	b.n	8010140 <strncmp+0x90>
 80100e6:	6822      	ldr	r2, [r4, #0]
 80100e8:	6829      	ldr	r1, [r5, #0]
 80100ea:	f1a2 3001 	sub.w	r0, r2, #16843009	; 0x1010101
 80100ee:	428a      	cmp	r2, r1
 80100f0:	ea20 0002 	bic.w	r0, r0, r2
 80100f4:	d127      	bne.n	8010146 <strncmp+0x96>
 80100f6:	3b04      	subs	r3, #4
 80100f8:	d022      	beq.n	8010140 <strncmp+0x90>
 80100fa:	f010 3f80 	tst.w	r0, #2155905152	; 0x80808080
 80100fe:	d11f      	bne.n	8010140 <strncmp+0x90>
 8010100:	3404      	adds	r4, #4
 8010102:	3504      	adds	r5, #4
 8010104:	2b03      	cmp	r3, #3
 8010106:	d8ee      	bhi.n	80100e6 <strncmp+0x36>
 8010108:	4620      	mov	r0, r4
 801010a:	4629      	mov	r1, r5
 801010c:	b1f3      	cbz	r3, 801014c <strncmp+0x9c>
 801010e:	7804      	ldrb	r4, [r0, #0]
 8010110:	3b01      	subs	r3, #1
 8010112:	f891 c000 	ldrb.w	ip, [r1]
 8010116:	4564      	cmp	r4, ip
 8010118:	d10f      	bne.n	801013a <strncmp+0x8a>
 801011a:	b18b      	cbz	r3, 8010140 <strncmp+0x90>
 801011c:	b184      	cbz	r4, 8010140 <strncmp+0x90>
 801011e:	3b01      	subs	r3, #1
 8010120:	2200      	movs	r2, #0
 8010122:	e002      	b.n	801012a <strncmp+0x7a>
 8010124:	b163      	cbz	r3, 8010140 <strncmp+0x90>
 8010126:	b15c      	cbz	r4, 8010140 <strncmp+0x90>
 8010128:	3b01      	subs	r3, #1
 801012a:	1884      	adds	r4, r0, r2
 801012c:	188d      	adds	r5, r1, r2
 801012e:	3201      	adds	r2, #1
 8010130:	7864      	ldrb	r4, [r4, #1]
 8010132:	f895 c001 	ldrb.w	ip, [r5, #1]
 8010136:	4564      	cmp	r4, ip
 8010138:	d0f4      	beq.n	8010124 <strncmp+0x74>
 801013a:	ebcc 0004 	rsb	r0, ip, r4
 801013e:	e000      	b.n	8010142 <strncmp+0x92>
 8010140:	2000      	movs	r0, #0
 8010142:	bc30      	pop	{r4, r5}
 8010144:	4770      	bx	lr
 8010146:	4620      	mov	r0, r4
 8010148:	4629      	mov	r1, r5
 801014a:	e7e0      	b.n	801010e <strncmp+0x5e>
 801014c:	7824      	ldrb	r4, [r4, #0]
 801014e:	f895 c000 	ldrb.w	ip, [r5]
 8010152:	ebcc 0004 	rsb	r0, ip, r4
 8010156:	e7f4      	b.n	8010142 <strncmp+0x92>

08010158 <Reset_Handler>:
 8010158:	2100      	movs	r1, #0
 801015a:	e003      	b.n	8010164 <LoopCopyDataInit>

0801015c <CopyDataInit>:
 801015c:	4b09      	ldr	r3, [pc, #36]	; (8010184 <LoopFillZerobss+0xc>)
 801015e:	585b      	ldr	r3, [r3, r1]
 8010160:	5043      	str	r3, [r0, r1]
 8010162:	3104      	adds	r1, #4

08010164 <LoopCopyDataInit>:
 8010164:	4808      	ldr	r0, [pc, #32]	; (8010188 <LoopFillZerobss+0x10>)
 8010166:	4b09      	ldr	r3, [pc, #36]	; (801018c <LoopFillZerobss+0x14>)
 8010168:	1842      	adds	r2, r0, r1
 801016a:	429a      	cmp	r2, r3
 801016c:	d3f6      	bcc.n	801015c <CopyDataInit>
 801016e:	4a08      	ldr	r2, [pc, #32]	; (8010190 <LoopFillZerobss+0x18>)
 8010170:	e002      	b.n	8010178 <LoopFillZerobss>

08010172 <FillZerobss>:
 8010172:	2300      	movs	r3, #0
 8010174:	f842 3b04 	str.w	r3, [r2], #4

08010178 <LoopFillZerobss>:
 8010178:	4b06      	ldr	r3, [pc, #24]	; (8010194 <LoopFillZerobss+0x1c>)
 801017a:	429a      	cmp	r2, r3
 801017c:	d3f9      	bcc.n	8010172 <FillZerobss>
 801017e:	f7fc fdaf 	bl	800cce0 <main>
 8010182:	4770      	bx	lr
 8010184:	0801144c 	.word	0x0801144c
 8010188:	20001800 	.word	0x20001800
 801018c:	20001838 	.word	0x20001838
 8010190:	20001838 	.word	0x20001838
 8010194:	20004db0 	.word	0x20004db0

08010198 <Default_Handler>:
 8010198:	e7fe      	b.n	8010198 <Default_Handler>
	...

0801019c <msgufe>:
 801019c:	065c 0801                                   \...

080101a0 <msgbfe>:
 80101a0:	0672 0801                                   r...

080101a4 <msgmm>:
 80101a4:	0686 0801                                   ....

080101a8 <msghard>:
 80101a8:	06a2 0801                                   ....

080101ac <msg_app_ver>:
 80101ac:	06e4 0801                                   ....

080101b0 <msg_chans>:
 80101b0:	0704 0801                                   ....

080101b4 <msg_free>:
 80101b4:	071b 0801                                   ....

080101b8 <msg_warr>:
 80101b8:	0736 0801                                   6...

080101bc <Scan_PSC>:
 80101bc:	000b 000b 000b 000b 000b 000f 000f 000f     ................
 80101cc:	000f 000f 000f 001f 003f 003f 007f 00ff     ........?.?.....
 80101dc:	00ff 00ff 01ff 01ff 01ff 03ff               ............

080101e8 <Scan_ARR>:
 80101e8:	0006 0006 0006 0006 0006 0008 0011 0023     ..............#.
 80101f8:	0059 00b3 0167 01c1 01c1 0383 0464 0464     Y...g.......d.d.
 8010208:	08c9 15f8 15f8 2bf1 6ddc 6ddc               .......+.m.m

08010214 <Fout_PSC>:
	...
 8010234:	0003 0000 0003 0000 000f 0000 000f 0000     ................
 8010244:	003f 0000 003f 0000 007f 0000 007f 0000     ?...?...........

08010254 <Fout_ARR>:
 8010254:	0047 0000 008f 0000 0167 0000 02cf 0000     G.......g.......
 8010264:	059f 0000 0e0f 0000 1c1f 0000 383f 0000     ............?8..
 8010274:	2327 0000 464f 0000 2327 0000 57e3 0000     '#..OF..'#...W..
 8010284:	2bf1 0000 57e3 0000 6ddc 0000 dbb9 0000     .+...W...m......

08010294 <msgt>:
 8010294:	0f09 0801                                   ....

08010298 <msgf>:
 8010298:	0f0f 0801                                   ....

0801029c <menu>:
 801029c:	0f1d 0801 0000 0000 0000 0000 0000 0000     ................
	...
 80102b4:	0f3c 0801 0009 0000 3acf 2000 0001 0000     <........:. ....
 80102c4:	0000 0000 0001 0000 0f5b 0801 000d 0000     ........[.......
 80102d4:	3b00 2000 0001 0000 0000 0000 ffff 0000     .;. ............
 80102e4:	0f7a 0801 0005 0000 0000 0000 0000 0000     z...............
	...
 80102fc:	0f99 0801 0006 0000 0000 0000 0000 0000     ................
	...
 8010314:	0fb8 0801 0003 0000 0000 0000 0000 0000     ................
	...
 801032c:	0fd7 0801 0008 0000 3ad0 2000 0000 0000     .........:. ....
 801033c:	0000 0000 0001 0000 0ff6 0801 0010 0000     ................
 801034c:	3b20 2000 01f4 0000 0001 0000 4240 000f      ;. ........@B..
 801035c:	1015 0801 0008 0000 3b28 2000 0000 0000     ........(;. ....
 801036c:	0000 0000 0001 0000 1034 0801 0000 0000     ........4.......
	...
 801038c:	1053 0801 0008 0000 3b02 2000 0000 0000     S........;. ....
 801039c:	0000 0000 0001 0000 1072 0801 000e 0000     ........r.......
 80103ac:	3b04 2000 0001 0000 0001 0000 07d0 0000     .;. ............
 80103bc:	1091 0801 000e 0000 3b06 2000 0001 0000     .........;. ....
 80103cc:	0100 0000 0800 0000 10b0 0801 0000 0000     ................
	...
 80103ec:	10cf 0801 0013 0000 3b14 2000 0000 0000     .........;. ....
 80103fc:	0000 0000 ffff 7fff 10ee 0801 0013 0000     ................
 801040c:	3b18 2000 0000 0000 0000 0000 ffff 7fff     .;. ............
 801041c:	110d 0801 0013 0000 3b1c 2000 0000 0000     .........;. ....
 801042c:	0000 0000 ffff 7fff 112c 0801 0000 0000     ........,.......
	...
 801044c:	114b 0801 0008 0000 3b24 2000 0000 0000     K.......$;. ....
 801045c:	0000 0000 0001 0000 116a 0801 000e 0000     ........j.......
 801046c:	3b26 2000 0001 0000 0000 0000 0708 0000     &;. ............
 801047c:	1189 0801 0000 0000 0000 0000 0000 0000     ................
	...
 8010494:	11a8 0801 0009 0000 3ae2 2000 0001 0000     .........:. ....
 80104a4:	0000 0000 0001 0000 11c7 0801 0008 0000     ................
 80104b4:	3ae8 2000 0000 0000 0000 0000 0001 0000     .:. ............
 80104c4:	11e6 0801 0013 0000 3aec 2000 2710 0000     .........:. .'..
 80104d4:	bdc0 fff0 4240 000f 1205 0801 0013 0000     ....@B..........
 80104e4:	3af0 2000 1388 0000 0000 0000 4000 001f     .:. .........@..
 80104f4:	1224 0801 0013 0000 3af4 2000 1388 0000     $........:. ....
 8010504:	0000 0000 4000 001f 1243 0801 0013 0000     .....@..C.......
 8010514:	3afc 2000 01f4 0000 0000 0000 1770 0000     .:. ........p...
 8010524:	1262 0801 0002 0000 0000 0000 0000 0000     b...............
	...
 801053c:	1281 0801 0000 0000 0000 0000 0000 0000     ................
	...
 8010554:	12a0 0801 000e 0000 3ad2 2000 0001 0000     .........:. ....
 8010564:	0001 0000 5180 0001 12bf 0801 0009 0000     .....Q..........
 8010574:	3ad4 2000 0001 0000 0000 0000 0002 0000     .:. ............
 8010584:	12de 0801 0009 0000 3ad6 2000 0001 0000     .........:. ....
 8010594:	0000 0000 0001 0000 12fd 0801 0009 0000     ................
 80105a4:	3ad7 2000 0001 0000 0000 0000 0004 0000     .:. ............
 80105b4:	131c 0801 0000 0000 0000 0000 0000 0000     ................
	...
 80105cc:	133b 0801 0007 0000 0000 0000 0000 0000     ;...............
	...
 80105e4:	135a 0801 000e 0000 3b2c 2000 0001 0000     Z.......,;. ....
 80105f4:	0000 0000 0064 0000 1379 0801 0000 0000     ....d...y.......
	...

08010614 <Battery_Color>:
 8010614:	001f 07ff 07e0 07e0 07e0 0000               ............

08010620 <Battery_Status>:
 8010620:	139c 0801 13a0 0801 13a4 0801 13a8 0801     ................
 8010630:	13ac 0801                                   ....

08010634 <msg_rate0>:
 8010634:	13b0 0801                                   ....

08010638 <msg_rate1>:
 8010638:	13cf 0801                                   ....

0801063c <msg_pha0>:
 801063c:	13ee 0801                                   ....

08010640 <msg_pha1_cal>:
 8010640:	140d 0801                                   ....

08010644 <msg_pha1_nocal>:
 8010644:	142c 0801                                   ,...

08010648 <APBAHBPrescTable>:
 8010648:	0000 0000 0201 0403 0201 0403 0706 0908     ................

08010658 <ADCPrescTable>:
 8010658:	0402 0806 7355 6761 2065 6146 6c75 2074     ....Usage Fault 
 8010668:	7845 6563 7470 6f69 006e 7542 2073 6146     Exception.Bus Fa
 8010678:	6c75 2074 7845 6563 7470 6f69 006e 654d     ult Exception.Me
 8010688:	6f6d 7972 4d20 6e61 6761 6d65 6e65 2074     mory Management 
 8010698:	7845 6563 7470 6f69 006e 6148 6472 4620     Exception.Hard F
 80106a8:	7561 746c 4520 6378 7065 6974 6e6f 4400     ault Exception.D
 80106b8:	5f6f 654b 7379 525f 7461 0065 6f44 4b5f     o_Keys_Rate.Do_K
 80106c8:	7965 5f73 4850 0041 6c43 6165 5f72 6c41     eys_PHA.Clear_Al
 80106d8:	5f6c 6144 6174 6d00 6961 006e 2020 5041     l_Data.main.  AP
 80106e8:	2050 6552 6976 6973 6e6f 3020 312e 2032     P Revision 0.12 
 80106f8:	3228 3130 2f32 2f39 3531 0029 2020 2020     (2012/9/15).    
 8010708:	2020 2020 3220 3430 2038 6843 6e61 656e          2048 Channe
 8010718:	736c 2000 2020 2020 4f20 6570 206e 6f53     ls.      Open So
 8010728:	7275 6563 5320 666f 7774 7261 0065 2020     urce Software.  
 8010738:	2020 2020 2020 2020 6f4e 5720 7261 6172             No Warra
 8010748:	746e 0079 654e 7478 6c43 7375 2874 0029     nty.NextClust().
 8010758:	654e 7478 6c43 7375 2874 2029 7543 4672     NextClust() CurF
 8010768:	6c69 4165 6464 0072 654e 7478 6c43 7375     ileAddr.NextClus
 8010778:	2874 2029 6f52 746f 415f 6464 0072 654e     t() Root_Addr.Ne
 8010788:	7478 6c43 7375 2874 2029 7543 4372 756c     xtClust() CurClu
 8010798:	7473 7265 4600 5441 495f 666e 286f 0029     ster.FAT_Info().
 80107a8:	4146 5f54 6e49 6f66 2928 7220 6165 2064     FAT_Info() read 
 80107b8:	6170 7472 7469 6f69 206e 6166 6c69 6465     partition failed
 80107c8:	4600 5441 495f 666e 286f 2029 6472 6220     .FAT_Info() rd b
 80107d8:	6f6f 2074 6573 7463 6620 6961 656c 0064     oot sect failed.
 80107e8:	4146 5f54 6e49 6f66 2928 4620 5441 3631     FAT_Info() FAT16
 80107f8:	4600 5441 495f 666e 286f 2029 6553 7463     .FAT_Info() Sect
 8010808:	726f 6953 657a 4600 5441 495f 666e 286f     orSize.FAT_Info(
 8010818:	2029 6553 5063 7265 6c43 7375 4600 5441     ) SecPerClus.FAT
 8010828:	495f 666e 286f 2029 4146 5f54 6441 7264     _Info() FAT_Addr
 8010838:	4600 5441 495f 666e 286f 2029 6f52 746f     .FAT_Info() Root
 8010848:	415f 6464 0072 4146 5f54 6e49 6f66 2928     _Addr.FAT_Info()
 8010858:	4420 7269 6c42 4e6b 6d75 4600 5441 495f      DirBlkNum.FAT_I
 8010868:	666e 286f 2029 4446 5f54 7453 7261 0074     nfo() FDT_Start.
 8010878:	4146 5f54 6e49 6f66 2928 4620 5444 435f     FAT_Info() FDT_C
 8010888:	756c 7473 7265 4300 6f6c 6573 2928 4320     luster.Close() C
 8010898:	7275 6944 0072 6c43 736f 2865 2029 7245     urDir.Close() Er
 80108a8:	6f72 2072 6e6f 7720 6972 6974 676e 6620     ror on writing f
 80108b8:	6c69 2965 4300 6f6c 6573 2928 4520 7272     ile).Close() Err
 80108c8:	6f20 206e 6964 6572 7463 726f 2079 6572      on directory re
 80108d8:	6461 0029 6c43 736f 2865 2029 7245 2072     ad).Close() Err 
 80108e8:	6e6f 6420 7269 6365 6f74 7972 7720 6972     on directory wri
 80108f8:	6574 4300 6f6c 6573 2928 6620 6c69 2065     te.Close() file 
 8010908:	6973 657a 4400 7269 6f54 6375 0068 6547     size.DirTouch.Ge
 8010918:	4374 756c 7473 2928 4700 7465 6c43 7375     tClust().GetClus
 8010928:	2874 2029 4146 5f54 6441 7264 4700 7465     t() FAT_Addr.Get
 8010938:	6c43 7375 2874 2029 7543 4372 756c 7473     Clust() CurClust
 8010948:	7265 4700 7465 6c43 7375 2874 2029 6461     er.GetClust() ad
 8010958:	7264 4700 7465 6c43 7375 2874 2029 0069     dr.GetClust() i.
 8010968:	6547 4374 756c 7473 2928 4320 7275 6946     GetClust() CurFi
 8010978:	656c 6441 7264 4700 7465 6c43 7375 2874     leAddr.GetClust(
 8010988:	2029 6f52 746f 415f 6464 0072 6441 4364     ) Root_Addr.AddC
 8010998:	756c 7473 2928 4620 5441 415f 6464 0072     lust() FAT_Addr.
 80109a8:	6441 4364 756c 7473 2928 6120 6464 0072     AddClust() addr.
 80109b8:	6441 4364 756c 7473 2928 6920 4100 6464     AddClust() i.Add
 80109c8:	6c43 7375 2874 2029 6547 4374 756c 7473     Clust() GetClust
 80109d8:	6620 6961 656c 0064 5f57 6144 6174 2928      failed.W_Data()
 80109e8:	4520 7272 726f 6f20 206e 6572 6461 6e69      Error on readin
 80109f8:	2067 6966 656c 0029 5f57 6144 6174 2928     g file).W_Data()
 8010a08:	6c20 6e65 0020 5f57 6144 6174 2928 6220      len .W_Data() b
 8010a18:	6f6c 6b63 6620 6c69 656c 0064 5f57 6144     lock filled.W_Da
 8010a28:	6174 2928 4520 7272 726f 6f20 206e 7277     ta() Error on wr
 8010a38:	7469 6e69 2067 6966 656c 0029 654e 2877     iting file).New(
 8010a48:	0029 654e 2877 2029 6964 6972 646e 7865     ).New() dirindex
 8010a58:	4e00 7765 2928 4d20 4453 525f 6165 4264     .New() MSD_ReadB
 8010a68:	6f6c 6b63 6620 6961 656c 0064 654e 2877     lock failed.New(
 8010a78:	2029 6f66 6e75 2064 6d65 7470 2079 6e65     ) found empty en
 8010a88:	7274 0079 654e 2877 2029 534d 5f44 7257     try.New() MSD_Wr
 8010a98:	7469 4265 6f6c 6b63 6620 6961 656c 0064     iteBlock failed.
 8010aa8:	654e 2877 2029 7543 4472 7269 4e00 7765     New() CurDir.New
 8010ab8:	2928 4320 7275 6946 656c 6441 7264 4e00     () CurFileAddr.N
 8010ac8:	7765 2928 4320 7275 6c43 7375 6574 0072     ew() CurCluster.
 8010ad8:	704f 6e65 2928 6e20 206f 6966 656c 6620     Open() no file f
 8010ae8:	756f 646e 4f00 6570 286e 0029 704f 6e65     ound.Open().Open
 8010af8:	2928 6420 7269 6e69 6564 0078 704f 6e65     () dirindex.Open
 8010b08:	2928 4d20 4453 525f 6165 4264 6f6c 6b63     () MSD_ReadBlock
 8010b18:	6620 6961 656c 0064 704f 6e65 2928 4320      failed.Open() C
 8010b28:	7275 6944 0072 704f 6e65 2928 4320 7275     urDir.Open() Cur
 8010b38:	6946 656c 6441 7264 4f00 6570 286e 2029     FileAddr.Open() 
 8010b48:	7543 4372 756c 7473 7265 4600 4c49 3045     CurCluster.FILE0
 8010b58:	3030 0030 4144 0054 4d3c 6165 7573 6572     000.DAT.<Measure
 8010b68:	656d 746e 0a3e 2000 2020 3c20 6552 616d     ment>..    <Rema
 8010b78:	6b72 3e73 000a 2020 2020 000a 2020 2020     rks>..    ..    
 8010b88:	493c 736e 7274 6d75 6e65 4974 666e 726f     <InstrumentInfor
 8010b98:	616d 6974 6e6f 0a3e 2000 2020 2020 2020     mation>..       
 8010ba8:	3c20 6e49 7473 7572 656d 746e 7954 6570      <InstrumentType
 8010bb8:	0a3e 2000 2020 2020 2020 3c20 492f 736e     >..        </Ins
 8010bc8:	7274 6d75 6e65 5474 7079 3e65 000a 2020     trumentType>..  
 8010bd8:	2020 2020 2020 4d3c 6e61 6675 6361 7574           <Manufactu
 8010be8:	6572 3e72 000a 2020 2020 2020 2020 2f3c     rer>..        </
 8010bf8:	614d 756e 6166 7463 7275 7265 0a3e 2000     Manufacturer>.. 
 8010c08:	2020 2020 2020 3c20 6e49 7473 7572 656d            <Instrume
 8010c18:	746e 6f4d 6564 3e6c 000a 2020 2020 2020     ntModel>..      
 8010c28:	2020 2f3c 6e49 7473 7572 656d 746e 6f4d       </InstrumentMo
 8010c38:	6564 3e6c 000a 2020 2020 2020 2020 493c     del>..        <I
 8010c48:	736e 7274 6d75 6e65 4974 3e44 000a 2020     nstrumentID>..  
 8010c58:	2020 2020 2020 2f3c 6e49 7473 7572 656d           </Instrume
 8010c68:	746e 4449 0a3e 2000 2020 3c20 492f 736e     ntID>..    </Ins
 8010c78:	7274 6d75 6e65 4974 666e 726f 616d 6974     trumentInformati
 8010c88:	6e6f 0a3e 2000 2020 3c20 654d 7361 7275     on>..    <Measur
 8010c98:	6465 7449 6d65 6e49 6f66 6d72 7461 6f69     edItemInformatio
 8010ca8:	3e6e 000a 2020 2020 2020 2020 4d3c 6165     n>..        <Mea
 8010cb8:	7573 6572 656d 746e 6f4c 6163 6974 6e6f     surementLocation
 8010cc8:	0a3e 2000 2020 2020 2020 2020 2020 3c20     >..            <
 8010cd8:	6f43 726f 6964 616e 6574 3e73 000a 2020     Coordinates>..  
 8010ce8:	2020 2020 2020 2020 2020 2f3c 6f43 726f               </Coor
 8010cf8:	6964 616e 6574 3e73 000a 2020 2020 2020     dinates>..      
 8010d08:	2020 2f3c 654d 7361 7275 6d65 6e65 4c74       </MeasurementL
 8010d18:	636f 7461 6f69 3e6e 000a 2020 2020 2f3c     ocation>..    </
 8010d28:	654d 7361 7275 6465 7449 6d65 6e49 6f66     MeasuredItemInfo
 8010d38:	6d72 7461 6f69 3e6e 000a 2020 2020 533c     rmation>..    <S
 8010d48:	6570 7463 7572 3e6d 000a 2020 2020 2020     pectrum>..      
 8010d58:	2020 533c 6174 7472 6954 656d 0a3e 2000       <StartTime>.. 
 8010d68:	2020 2020 2020 3c20 532f 6174 7472 6954            </StartTi
 8010d78:	656d 0a3e 2000 2020 2020 2020 3c20 6552     me>..        <Re
 8010d88:	6c61 6954 656d 0a3e 2000 2020 2020 2020     alTime>..       
 8010d98:	3c20 522f 6165 546c 6d69 3e65 000a 2020      </RealTime>..  
 8010da8:	2020 2020 2020 4c3c 7669 5465 6d69 3e65           <LiveTime>
 8010db8:	000a 2020 2020 2020 2020 2f3c 694c 6576     ..        </Live
 8010dc8:	6954 656d 0a3e 2000 2020 2020 2020 3c20     Time>..        <
 8010dd8:	6143 696c 7262 7461 6f69 3e6e 000a 2020     Calibration>..  
 8010de8:	2020 2020 2020 2020 2020 453c 7571 7461               <Equat
 8010df8:	6f69 3e6e 000a 2020 2020 2020 2020 2020     ion>..          
 8010e08:	2020 2f3c 7145 6175 6974 6e6f 0a3e 2000       </Equation>.. 
 8010e18:	2020 2020 2020 3c20 432f 6c61 6269 6172            </Calibra
 8010e28:	6974 6e6f 0a3e 2000 2020 2020 2020 3c20     tion>..        <
 8010e38:	6843 6e61 656e 446c 7461 3e61 000a 2020     ChannelData>..  
 8010e48:	2020 2020 2020 2f3c 6843 6e61 656e 446c           </ChannelD
 8010e58:	7461 3e61 000a 2020 2020 2f3c 7053 6365     ata>..    </Spec
 8010e68:	7274 6d75 0a3e 3c00 4d2f 6165 7573 6572     trum>..</Measure
 8010e78:	656d 746e 0a3e 5300 4550 5443 3030 0030     ment>..SPECT000.
 8010e88:	5343 0056 6147 6d6d 2061 7247 7061 6568     CSV.Gamma Graphe
 8010e98:	2072 6556 7372 6f69 206e 2c32 000a 6f43     r Version 2,..Co
 8010ea8:	6d6d 2061 6553 6170 6172 6574 2064 6156     mma Separated Va
 8010eb8:	756c 7365 0a2c 5700 6972 6574 4520 7272     lues,..Write Err
 8010ec8:	4e00 206f 6946 656c 5300 2044 7245 0072     .No File.SD Err.
 8010ed8:	6f4e 4320 7261 0064 6153 6576 4f20 006b     No Card.Save Ok.
 8010ee8:	6146 6c69 6465 5200 6165 2064 7245 0072     Failed.Read Err.
 8010ef8:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
 8010f08:	5400 5552 2045 4600 4c41 4553 5300 6375     .TRUE .FALSE.Suc
 8010f18:	6563 7373 4600 4552 5551 4e45 4c54 2059     cess.FREQUENTLY 
 8010f28:	5355 4445 203a 2020 2020 2020 2020 2020     USED:           
 8010f38:	2020 0020 4d20 646f 3a65 5020 4148 202c        . Mode: PHA, 
 8010f48:	6152 6574 2020 2020 2020 2020 2020 2020     Rate            
 8010f58:	2020 2000 6946 656c 5320 7165 5320 6174       . File Seq Sta
 8010f68:	7472 203a 2020 2020 2020 2020 2020 2020     rt:             
 8010f78:	0020 5320 7661 2065 7053 6365 7274 6d75      . Save Spectrum
 8010f88:	5420 206f 5343 2056 6946 656c 2020 2020      To CSV File    
 8010f98:	2000 532a 7661 2065 7053 6365 7274 6d75     . *Save Spectrum
 8010fa8:	5420 206f 344e 2032 6946 656c 2020 0020      To N42 File   .
 8010fb8:	4320 656c 7261 4120 6c6c 2020 2020 2020      Clear All      
 8010fc8:	2020 2020 2020 2020 2020 2020 2020 2000                   . 
 8010fd8:	6c41 7261 206d 6e45 6261 656c 203a 2020     Alarm Enable:   
 8010fe8:	2020 2020 2020 2020 2020 2020 0020 4120                  . A
 8010ff8:	616c 6d72 4c20 7665 6c65 203a 2020 2020     larm Level:     
 8011008:	2020 2020 2020 2020 7063 206d 2000 6542             cpm . Be
 8011018:	7065 203a 2020 2020 2020 2020 2020 2020     ep:             
 8011028:	2020 2020 2020 2020 2020 0020 4850 2041                .PHA 
 8011038:	4f4d 4544 5320 5445 5055 203a 2020 2020     MODE SETUP:     
 8011048:	2020 2020 2020 2020 2020 2000 6e45 7265               . Ener
 8011058:	7967 4320 6d6f 3a70 2020 2020 2020 2020     gy Comp:        
 8011068:	2020 2020 2020 2020 0020 2a20 7543 7372              . *Curs
 8011078:	726f 5720 6469 6874 203a 2020 2020 2020     or Width:       
 8011088:	2020 2020 6863 206e 2000 432a 6168 6e6e         chn . *Chann
 8011098:	6c65 3a73 2020 2020 2020 2020 2020 2020     els:            
 80110a8:	2020 2020 2020 0020 2a20 6143 696c 7262            . *Calibr
 80110b8:	7461 6f69 206e 6f46 6d72 2820 7861 325e     ation Form (ax^2
 80110c8:	622b 2b78 2963 2000 432a 656f 2066 3a61     +bx+c). *Coef a:
 80110d8:	2020 2020 2020 2020 2020 2020 2020 2020                     
 80110e8:	2020 2020 0020 2a20 6f43 6665 6220 203a          . *Coef b: 
 80110f8:	2020 2020 2020 2020 2020 2020 2020 2020                     
 8011108:	2020 2020 2000 432a 656f 2066 3a63 2020         . *Coef c:  
 8011118:	2020 2020 2020 2020 2020 2020 2020 2020                     
 8011128:	2020 0020 4152 4554 4d20 444f 2045 4553        .RATE MODE SE
 8011138:	5554 3a50 2020 2020 2020 2020 2020 2020     TUP:            
 8011148:	2020 2000 6f4c 2077 6150 7373 4620 6c69       . Low Pass Fil
 8011158:	6574 3a72 2020 2020 2020 2020 2020 2020     ter:            
 8011168:	0020 4620 6c69 6574 2072 6f43 6665 203a      . Filter Coef: 
 8011178:	2020 2020 2020 2020 2020 2020 2020 2053                   S 
 8011188:	4900 504e 5455 5320 4749 414e 204c 4553     .INPUT SIGNAL SE
 8011198:	5554 3a50 2020 2020 2020 2020 2020 0020     TUP:           .
 80111a8:	5020 6c75 6573 203a 6f50 2c73 654e 2067      Pulse: Pos,Neg 
 80111b8:	2020 2020 2020 2020 2020 2020 2020 2000                   . 
 80111c8:	6147 7375 6973 6e61 4120 7070 6f72 3a78     Gaussian Approx:
 80111d8:	2020 2020 2020 2020 2020 2020 0020 6420                  . d
 80111e8:	2f76 7464 5420 7268 7365 203a 2020 2020     v/dt Thres:     
 80111f8:	2020 2020 2020 2020 2020 2020 2000 6f4c                 . Lo
 8011208:	2077 694c 696d 3a74 2020 2020 2020 2020     w Limit:        
 8011218:	2020 2020 2020 6b20 7665 0020 4820 6769            kev . Hig
 8011228:	2068 694c 696d 3a74 2020 2020 2020 2020     h Limit:        
 8011238:	2020 2020 2020 656b 2076 2000 6152 676e           kev . Rang
 8011248:	2065 2f2b 3a2d 2020 2020 2020 2020 2020     e +/-:          
 8011258:	2020 2020 2020 7620 0020 5220 6365 6c61            v . Recal
 8011268:	4120 4344 2020 2020 2020 2020 2020 2020      ADC            
 8011278:	2020 2020 2020 2020 4400 5349 4c50 5941             .DISPLAY
 8011288:	5320 5445 5055 203a 2020 2020 2020 2020      SETUP:         
 8011298:	2020 2020 2020 0020 5220 6665 6572 6873            . Refresh
 80112a8:	5420 6d69 3a65 2020 2020 2020 2020 2020      Time:          
 80112b8:	2020 2020 2053 2000 6c50 746f 203a 6f44         S . Plot: Do
 80112c8:	2c74 694c 656e 572c 6469 2065 2020 2020     t,Line,Wide     
 80112d8:	2020 2020 0020 4f20 6972 6e65 6174 6974          . Orientati
 80112e8:	6e6f 203a 6f48 7a72 562c 7265 2074 2020     on: Horz,Vert   
 80112f8:	2020 2020 2000 614c 676e 6175 6567 203a         . Language: 
 8011308:	4e45 2020 2020 2020 2020 2020 2020 2020     EN              
 8011318:	2020 0020 4441 494d 494e 5453 4152 4954        .ADMINISTRATI
 8011328:	4556 203a 2020 2020 2020 2020 2020 2020     VE:             
 8011338:	2020 2000 6552 6573 2074 6553 7474 6e69       . Reset Settin
 8011348:	7367 7420 206f 6544 6166 6c75 2074 2020     gs to Default   
 8011358:	0020 4420 6265 6775 4c20 7665 6c65 203a      . Debug Level: 
 8011368:	2020 2020 2020 2020 2020 2020 2020 2020                     
 8011378:	2a00 3d20 6e20 746f 6920 706d 656c 656d     .* = not impleme
 8011388:	746e 6465 7920 7465 2020 2020 2020 0020     nted yet       .
 8011398:	0023 0022 607e 0027 607e 007d 7c7e 007d     #.".~`'.~`}.~|}.
 80113a8:	7c7b 007d 5355 0042 6152 6574 2020 2020     {|}.USB.Rate    
 80113b8:	7820 7878 7878 2078 7063 206d 2020 3e20      xxxxxx cpm    >
 80113c8:	2020 5355 2042 4000 4320 7275 6f73 2072       USB .@ Cursor 
 80113d8:	7878 7878 7878 6320 6d70 2020 2020 2020     xxxxxx cpm      
 80113e8:	2020 2020 0020 4850 2041 2020 2020 2020          .PHA       
 80113f8:	2020 7820 7878 313a 2020 2020 3e20 2020        xxx:1     >  
 8011408:	5355 2042 7800 7878 7878 7878 7878 7878     USB .xxxxxxxxxxx
 8011418:	7878 4020 7878 7878 7878 782e 7878 6b20     xx @xxxxxx.xxx k
 8011428:	5665 0020 7878 7878 7878 7878 7878 7878     eV .xxxxxxxxxxxx
 8011438:	2078 7840 7878 7878 2e78 7878 2078 6863     x @xxxxxx.xxx ch
 8011448:	6e61 0000                                   an..
